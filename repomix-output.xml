This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/
  alembic/
    versions/
      001_initial_schema.py
    env.py
  app/
    api/
      routes/
        __init__.py
        activities.py
        auth.py
        clients.py
      __init__.py
      deps.py
    core/
      __init__.py
      config.py
      database.py
      security.py
    middleware/
      __init__.py
      logging.py
      rate_limit.py
    models/
      __init__.py
      activity.py
      api_key.py
      client.py
      user.py
    schemas/
      __init__.py
      activity.py
      api_key.py
      client.py
      user.py
    services/
      __init__.py
      activity_service.py
      auth_service.py
      client_service.py
    tests/
      __init__.py
      conftest.py
      test_activities.py
      test_auth.py
      test_clients.py
    __init__.py
    main.py
  .env.example
  .gitignore
  alembic.ini
  docker-entrypoint.sh
  Dockerfile
  init-db.sql
  README.md
  requirements.txt
clients/
  linux_desktop/
    config.json
    monitor.py
    requirements.txt
  linux_server/
    config.json
    monitor.py
    requirements.txt
  shared/
    __init__.py
    base_client.py
    config_manager.py
    requierements.txt
    utils.py
  windows_desktop/
    config.json
    monitor.py
    requirements.txt
  windows_server/
    config.json
    monitor.py
    requirements.txt
frontend/
  public/
    favicon.ico
    robots.txt
  src/
    components/
      common/
        Alert.jsx
        Button.jsx
        Card.jsx
        index.js
        Input.jsx
        LoadingSpinner.jsx
        Modal.jsx
        Table.jsx
      features/
        activities/
          ActivitiesList.jsx
          ActivityDetails.jsx
          ActivityFilters.jsx
          index.js
        auth/
          ChangePassword.jsx
          index.js
          Login.jsx
        clients/
          ClientDetails.jsx
          ClientsList.jsx
          ClientStats.jsx
          index.js
        dashboard/
          Dashboard.jsx
          index.js
          RecentActivity.jsx
          StatsCards.jsx
        settings/
          ApiKeys.jsx
          index.js
          SecuritySettings.jsx
      layout/
        Header.jsx
        index.js
        Layout.jsx
        Sidebar.jsx
      ui/
        Button.jsx
        Card.jsx
        Input.jsx
        LoadingSpinner.jsx
        Modal.jsx
        Table.jsx
      index.js
    contexts/
      AuthContext.jsx
      index.js
      NotificationContext.jsx
    hooks/
      index.js
      useActivities.js
      useApi.js
      useAuth.js
      useClients.js
    pages/
      ActivitiesPage.jsx
      ApiKeysPage.jsx
      ClientsPage.jsx
      DashboardPage.jsx
      LoginPage.jsx
      SettingsPage.jsx
    services/
      activities.service.js
      api.js
      auth.service.js
      clients.service.js
      index.js
    styles/
      components.css
      globals.css
      utilities.css
    utils/
      constants.js
      formatters.js
      index.js
      validators.js
    App.jsx
    main.jsx
    router.jsx
  .env.development
  .env.example
  .env.production
  .gitignore
  Dockerfile
  index.html
  nginx.conf
  package.json
  README.md
  vite.config.js
docker-compose.yml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/alembic/versions/001_initial_schema.py">
"""Initial schema

Revision ID: 001
Revises: 
Create Date: 2024-01-01 00:00:00.000000

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers
revision = '001'
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    # Users table
    op.create_table(
        'users',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('username', sa.String(50), nullable=False),
        sa.Column('email', sa.String(255), nullable=True),
        sa.Column('hashed_password', sa.String(255), nullable=False),
        sa.Column('is_admin', sa.Boolean(), nullable=False, server_default='false'),
        sa.Column('is_active', sa.Boolean(), nullable=False, server_default='true'),
        sa.Column('force_password_change', sa.Boolean(), nullable=False, server_default='false'),
        sa.Column('failed_login_attempts', sa.Integer(), nullable=False, server_default='0'),
        sa.Column('last_login', sa.DateTime(), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('username'),
        sa.UniqueConstraint('email')
    )
    op.create_index('ix_users_username', 'users', ['username'])
    op.create_index('ix_users_email', 'users', ['email'])
    
    # Clients table
    op.create_table(
        'clients',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('client_id', sa.String(255), nullable=False),
        sa.Column('client_type', sa.String(50), nullable=False),
        sa.Column('hostname', sa.String(255), nullable=True),
        sa.Column('ip_address', sa.String(50), nullable=True),
        sa.Column('platform_info', sa.Text(), nullable=True),
        sa.Column('is_active', sa.Boolean(), nullable=False, server_default='true'),
        sa.Column('last_seen', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('employee_consent', sa.Boolean(), nullable=False, server_default='false'),
        sa.Column('consent_date', sa.DateTime(), nullable=True),
        sa.Column('consent_ip', sa.String(50), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('client_id')
    )
    op.create_index('ix_clients_client_id', 'clients', ['client_id'])
    op.create_index('ix_clients_last_seen', 'clients', ['last_seen'])
    op.create_index('ix_clients_type_active', 'clients', ['client_type', 'is_active'])
    
    # Activities table
    op.create_table(
        'activities',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('client_id', sa.String(255), nullable=False),
        sa.Column('timestamp', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('active_window', sa.Text(), nullable=True),
        sa.Column('active_application', sa.String(255), nullable=True),
        sa.Column('active_url', sa.Text(), nullable=True),
        sa.Column('processes', sa.Text(), nullable=True),
        sa.Column('process_count', sa.Integer(), nullable=False, server_default='0'),
        sa.Column('system_metrics', sa.Text(), nullable=True),
        sa.Column('cpu_percent', sa.Float(), nullable=True),
        sa.Column('memory_percent', sa.Float(), nullable=True),
        sa.Column('disk_percent', sa.Float(), nullable=True),
        sa.Column('activity_category', sa.String(50), nullable=True),
        sa.Column('productivity_score', sa.Integer(), nullable=True),
        sa.Column('additional_data', sa.Text(), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index('ix_activities_client_id', 'activities', ['client_id'])
    op.create_index('ix_activities_timestamp', 'activities', ['timestamp'])
    op.create_index('ix_activities_client_timestamp', 'activities', ['client_id', 'timestamp'])
    op.create_index('ix_activities_category', 'activities', ['activity_category'])
    
# API Keys table (continued from previous)
    op.create_table(
        'api_keys',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('key_hash', sa.String(255), nullable=False),
        sa.Column('key_prefix', sa.String(20), nullable=False),
        sa.Column('is_active', sa.Boolean(), nullable=False, server_default='true'),
        sa.Column('last_used', sa.DateTime(), nullable=True),
        sa.Column('usage_count', sa.Integer(), nullable=False, server_default='0'),
        sa.Column('allowed_ips', sa.Text(), nullable=True),
        sa.Column('rate_limit', sa.Integer(), nullable=True),
        sa.Column('expires_at', sa.DateTime(), nullable=True),
        sa.Column('created_by', sa.Integer(), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('key_hash')
    )
    op.create_index('ix_api_keys_key_hash', 'api_keys', ['key_hash'])


def downgrade() -> None:
    op.drop_table('api_keys')
    op.drop_table('activities')
    op.drop_table('clients')
    op.drop_table('users')
</file>

<file path="backend/alembic/env.py">
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context
import os
import sys

# Add parent directory to path
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from app.core.config import settings
from app.core.database import Base
from app.models import User, Client, Activity, ApiKey

# Alembic Config object
config = context.config

# Interpret the config file for Python logging
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# Set SQLAlchemy URL from settings
config.set_main_option("sqlalchemy.url", settings.DATABASE_URL)

# Target metadata
target_metadata = Base.metadata


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="backend/app/api/routes/__init__.py">
from app.api.routes.auth import router as auth_router
from app.api.routes.clients import router as clients_router
from app.api.routes.activities import router as activities_router

__all__ = ["auth_router", "clients_router", "activities_router"]
</file>

<file path="backend/app/api/routes/activities.py">
from fastapi import APIRouter, Depends, HTTPException, Query, status, Header
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime, timedelta

from app.core.database import get_db
from app.core.config import settings
from app.api.deps import get_current_user, verify_api_key
from app.models.user import User
from app.schemas.activity import ActivityCreate, ActivityOut, ActivityStats
from app.schemas.client import ClientCreate
from app.services.activity_service import ActivityService
from app.services.client_service import ClientService

router = APIRouter()


@router.post("/report")
async def report_activity(
    activity: ActivityCreate,
    x_api_key: str = Header(..., alias="X-API-Key"),
    db: Session = Depends(get_db)
):
    """
    Report client activity (protected by API key)
    This endpoint is used by monitoring clients to submit activity data
    """
    # Verify API key
    await verify_api_key(x_api_key, db)
    
    # Check if compliance mode is enabled
    if settings.REQUIRE_EMPLOYEE_CONSENT:
        client_service = ClientService(db)
        client = client_service.get_client(activity.client_id)
        
        # Only block if client exists and consent is explicitly missing
        if client and not client.employee_consent:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Employee consent required for monitoring. Please contact administrator."
            )
    
    # Update or create client
    client_service = ClientService(db)
    client_data = ClientCreate(
        client_id=activity.client_id,
        client_type="unknown",
        employee_consent=False
    )
    
    # Extract client info from additional_data if available
    if activity.additional_data:
        client_data.client_type = activity.additional_data.get('client_type', 'unknown')
        client_data.hostname = activity.additional_data.get('hostname')
        client_data.ip_address = activity.additional_data.get('ip_address')
        client_data.platform_info = activity.additional_data.get('platform_info')
    
    client, is_new = client_service.create_or_update_client(client_data)
    
    # Create activity record
    activity_service = ActivityService(db)
    new_activity, error = activity_service.create_activity(activity)
    
    if not new_activity:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error
        )
    
    return {
        "status": "success",
        "message": "Activity recorded successfully",
        "activity_id": new_activity.id,
        "new_client": is_new
    }


@router.get("/", response_model=List[ActivityOut])
async def get_activities(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    client_id: Optional[str] = Query(None),
    start_date: Optional[datetime] = Query(None),
    end_date: Optional[datetime] = Query(None),
    category: Optional[str] = Query(None),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get activities with filtering and pagination"""
    activity_service = ActivityService(db)
    activities = activity_service.get_activities(
        skip=skip,
        limit=limit,
        client_id=client_id,
        start_date=start_date,
        end_date=end_date,
        category=category
    )
    # Pydantic handles JSON parsing automatically now
    return activities


@router.get("/stats", response_model=ActivityStats)
async def get_activity_stats(
    client_id: Optional[str] = Query(None),
    days: int = Query(7, ge=1, le=90),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get activity statistics"""
    activity_service = ActivityService(db)
    
    start_date = datetime.utcnow() - timedelta(days=days)
    stats = activity_service.get_activity_stats(
        client_id=client_id,
        start_date=start_date
    )
    
    return ActivityStats(**stats)


@router.get("/{activity_id}", response_model=ActivityOut)
async def get_activity(
    activity_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get specific activity by ID"""
    activity_service = ActivityService(db)
    activity = activity_service.get_activity(activity_id)
    
    if not activity:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Activity not found"
        )
    
    return activity


@router.post("/cleanup")
async def cleanup_old_activities(
    days: int = Query(90, ge=7, le=365),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Cleanup activities older than specified days (admin only)"""
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin privileges required"
        )
    
    activity_service = ActivityService(db)
    deleted_count = activity_service.cleanup_old_activities(days=days)
    
    return {
        "message": f"Cleanup completed",
        "deleted_count": deleted_count,
        "retention_days": days
    }
</file>

<file path="backend/app/api/routes/auth.py">
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from app.core.database import get_db
from app.core.config import settings
from app.api.deps import get_current_user, get_current_admin_user
from app.models.user import User
from app.schemas.user import (
    UserLogin, UserCreate, UserOut, Token, ChangePassword
)
from app.schemas.api_key import ApiKeyCreate, ApiKeyOut, ApiKeyResponse
from app.services.auth_service import AuthService

router = APIRouter()


@router.post("/login", response_model=Token)
async def login(
    user_data: UserLogin,
    db: Session = Depends(get_db)
):
    """Login user and return access token"""
    auth_service = AuthService(db)
    user, error = auth_service.authenticate_user(
        user_data.username,
        user_data.password
    )
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=error,
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token = auth_service.create_access_token_for_user(user)
    
    return Token(
        access_token=access_token,
        token_type="bearer",
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,
        force_password_change=user.force_password_change
    )


@router.post("/register", response_model=UserOut)
async def register(
    user_data: UserCreate,
    current_user: User = Depends(get_current_admin_user),
    db: Session = Depends(get_db)
):
    """Register new user (admin only)"""
    auth_service = AuthService(db)
    user, error = auth_service.create_user(
        username=user_data.username,
        password=user_data.password,
        email=user_data.email,
        is_admin=user_data.is_admin
    )
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error
        )
    
    return user


@router.get("/me", response_model=UserOut)
async def get_current_user_info(
    current_user: User = Depends(get_current_user)
):
    """Get current user information"""
    return current_user


@router.post("/change-password")
async def change_password(
    password_data: ChangePassword,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Change user password"""
    auth_service = AuthService(db)
    success, error = auth_service.change_password(
        current_user,
        password_data.current_password,
        password_data.new_password
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error
        )
    
    return {
        "message": "Password changed successfully",
        "force_password_change": False
    }


@router.post("/keys", response_model=ApiKeyResponse)
async def create_api_key(
    key_data: ApiKeyCreate,
    current_user: User = Depends(get_current_admin_user),
    db: Session = Depends(get_db)
):
    """Create new API key (admin only)"""
    auth_service = AuthService(db)
    
    # Convert list of IPs to comma-separated string
    allowed_ips = ",".join(key_data.allowed_ips) if key_data.allowed_ips else None
    
    api_key, plain_key, error = auth_service.create_api_key(
        name=key_data.name,
        created_by=current_user.id,
        allowed_ips=allowed_ips,
        rate_limit=key_data.rate_limit,
        expires_at=key_data.expires_at
    )
    
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error
        )
    
    return ApiKeyResponse(
        id=api_key.id,
        name=api_key.name,
        key=plain_key,
        key_prefix=api_key.key_prefix,
        created_at=api_key.created_at
    )


@router.get("/keys", response_model=List[ApiKeyOut])
async def list_api_keys(
    current_user: User = Depends(get_current_admin_user),
    db: Session = Depends(get_db)
):
    """List all API keys (admin only)"""
    auth_service = AuthService(db)
    return auth_service.list_api_keys()


@router.delete("/keys/{key_id}")
async def revoke_api_key(
    key_id: int,
    current_user: User = Depends(get_current_admin_user),
    db: Session = Depends(get_db)
):
    """Revoke API key (admin only)"""
    auth_service = AuthService(db)
    success, error = auth_service.revoke_api_key(key_id)
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=error
        )
    
    return {"message": "API key revoked successfully"}


@router.post("/logout")
async def logout(
    current_user: User = Depends(get_current_user)
):
    """Logout user (client-side token removal)"""
    return {"message": "Logged out successfully"}
</file>

<file path="backend/app/api/routes/clients.py">
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.orm import Session
from typing import List, Optional

from app.core.database import get_db
from app.api.deps import get_current_user
from app.models.user import User
from app.schemas.client import ClientOut, ClientUpdate
from app.services.client_service import ClientService

router = APIRouter()


@router.get("/", response_model=List[ClientOut])
async def get_clients(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    is_active: Optional[bool] = Query(None),
    client_type: Optional[str] = Query(None),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get all clients with filtering and pagination"""
    client_service = ClientService(db)
    clients = client_service.get_clients(
        skip=skip,
        limit=limit,
        is_active=is_active,
        client_type=client_type
    )
    # Pydantic handles JSON parsing automatically
    return clients


@router.get("/online", response_model=List[ClientOut])
async def get_online_clients(
    minutes: int = Query(5, ge=1, le=60),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get clients that were active in the last N minutes"""
    client_service = ClientService(db)
    clients = client_service.get_online_clients(minutes=minutes)
    return clients


@router.get("/stats")
async def get_client_stats(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get client statistics"""
    client_service = ClientService(db)
    
    total_clients = client_service.get_client_count()
    online_clients = len(client_service.get_online_clients(minutes=5))
    
    # Get clients by type
    clients_by_type = {}
    for client_type in ['linux_desktop', 'linux_server', 'windows_desktop', 'windows_server', 'macos_desktop']:
        count = len(client_service.get_clients(client_type=client_type, limit=1000))
        if count > 0:
            clients_by_type[client_type] = count
    
    return {
        "total_clients": total_clients,
        "online_clients": online_clients,
        "offline_clients": total_clients - online_clients,
        "clients_by_type": clients_by_type
    }


@router.get("/{client_id}", response_model=ClientOut)
async def get_client(
    client_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get specific client by ID"""
    client_service = ClientService(db)
    client = client_service.get_client(client_id)
    
    if not client:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Client not found"
        )
    
    return client


@router.put("/{client_id}", response_model=ClientOut)
async def update_client(
    client_id: str,
    update_data: ClientUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update client information"""
    client_service = ClientService(db)
    client, error = client_service.update_client(client_id, update_data)
    
    if not client:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=error
        )
    
    return client


@router.delete("/{client_id}")
async def delete_client(
    client_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete client and all associated activities"""
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin privileges required"
        )
    
    client_service = ClientService(db)
    success, error = client_service.delete_client(client_id)
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=error
        )
    
    return {"message": "Client deleted successfully"}
</file>

<file path="backend/app/api/__init__.py">
"""API routes package"""
</file>

<file path="backend/app/api/deps.py">
from fastapi import Depends, HTTPException, status, Header
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from typing import Optional

from app.core.database import get_db
from app.core.security import verify_token
from app.models.user import User
from app.services.auth_service import AuthService

security = HTTPBearer()


async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    """Get current authenticated user from JWT token"""
    try:
        token = credentials.credentials
        payload = verify_token(token)
        username: str = payload.get("sub")
        
        if username is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication credentials",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        user = db.query(User).filter(User.username == username).first()
        if user is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        if not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Inactive user"
            )
        
        return user
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(e),
            headers={"WWW-Authenticate": "Bearer"},
        )


async def get_current_admin_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """Get current user and verify admin privileges"""
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin privileges required"
        )
    return current_user


async def verify_api_key(
    x_api_key: Optional[str] = Header(None, alias="X-API-Key"),
    db: Session = Depends(get_db)
) -> bool:
    """Verify API key from header"""
    if not x_api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API key required",
            headers={"WWW-Authenticate": "ApiKey"},
        )
    
    auth_service = AuthService(db)
    api_key, error = auth_service.verify_api_key(x_api_key)
    
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=error,
            headers={"WWW-Authenticate": "ApiKey"},
        )
    
    return True
</file>

<file path="backend/app/core/__init__.py">
"""
Core application configuration and utilities
"""
</file>

<file path="backend/app/core/config.py">
from pydantic_settings import BaseSettings
from typing import List, Optional
import secrets


class Settings(BaseSettings):
    """Application settings with validation"""
    
    # Application
    PROJECT_NAME: str = "Sentinel"
    ENVIRONMENT: str = "development"
    DEBUG: bool = False
    API_VERSION: str = "v1"
    
    # Database
    DATABASE_URL: str
    DATABASE_POOL_SIZE: int = 20
    DATABASE_MAX_OVERFLOW: int = 40
    
    # Security
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 1440  # 24 hours
    
    # CORS - Changed to handle comma-separated string
    ALLOWED_ORIGINS: str = "http://localhost:3000"
    
    # Rate Limiting
    RATE_LIMIT_PER_MINUTE: int = 60
    RATE_LIMIT_PER_HOUR: int = 1000
    
    # Admin
    INITIAL_ADMIN_USERNAME: str = "admin"
    INITIAL_ADMIN_PASSWORD: str
    FORCE_ADMIN_PASSWORD_CHANGE: bool = True
    
    # Data Retention
    ACTIVITY_RETENTION_DAYS: int = 90
    LOG_RETENTION_DAYS: int = 30
    
    # Compliance
    REQUIRE_EMPLOYEE_CONSENT: bool = True
    ENABLE_AUDIT_LOGGING: bool = True
    
    # Redis
    REDIS_URL: Optional[str] = None
    
    # TLS
    REQUIRE_HTTPS: bool = False
    
    class Config:
        env_file = ".env"
        case_sensitive = True
    
    def get_allowed_origins(self) -> List[str]:
        """Parse ALLOWED_ORIGINS from comma-separated string"""
        if isinstance(self.ALLOWED_ORIGINS, str):
            return [origin.strip() for origin in self.ALLOWED_ORIGINS.split(",")]
        return self.ALLOWED_ORIGINS
    
    def validate_settings(self) -> List[str]:
        """Validate critical settings"""
        errors = []
        
        if self.SECRET_KEY == "CHANGE_THIS_TO_A_SECURE_RANDOM_KEY_AT_LEAST_32_CHARS":
            errors.append("SECRET_KEY must be changed from default value")
        
        if len(self.SECRET_KEY) < 32:
            errors.append("SECRET_KEY must be at least 32 characters")
        
        if self.INITIAL_ADMIN_PASSWORD == "CHANGE_THIS_IMMEDIATELY":
            errors.append("INITIAL_ADMIN_PASSWORD must be changed")
        
        if not self.DATABASE_URL.startswith("postgresql://"):
            errors.append("DATABASE_URL must be PostgreSQL")
        
        if self.ENVIRONMENT == "production" and self.DEBUG:
            errors.append("DEBUG must be False in production")
        
        if self.ENVIRONMENT == "production" and "*" in self.ALLOWED_ORIGINS:
            errors.append("ALLOWED_ORIGINS cannot contain '*' in production")
        
        return errors


settings = Settings()

# Validate settings on startup
validation_errors = settings.validate_settings()
if validation_errors and settings.ENVIRONMENT == "production":
    raise ValueError(f"Configuration errors: {', '.join(validation_errors)}")
elif validation_errors:
    print("⚠️  Configuration warnings:")
    for error in validation_errors:
        print(f"  - {error}")
</file>

<file path="backend/app/core/database.py">
from sqlalchemy import create_engine, event, text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.pool import NullPool
import logging

from app.core.config import settings

logger = logging.getLogger(__name__)

# Create engine with connection pooling
engine = create_engine(
    settings.DATABASE_URL,
    pool_size=settings.DATABASE_POOL_SIZE,
    max_overflow=settings.DATABASE_MAX_OVERFLOW,
    pool_pre_ping=True,  # Verify connections before using
    echo=settings.DEBUG,
)

# Create session factory
SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

# Base class for models
Base = declarative_base()


def get_db():
    """Dependency to get database session"""
    db = SessionLocal()
    try:
        yield db
    except Exception as e:
        logger.error(f"Database error: {e}")
        db.rollback()
        raise
    finally:
        db.close()


def init_db():
    """Initialize database tables"""
    try:
        Base.metadata.create_all(bind=engine)
        logger.info("✅ Database tables created successfully")
    except Exception as e:
        logger.error(f"❌ Error creating database tables: {e}")
        raise


def check_db_connection() -> bool:
    """Check if database connection is working"""
    try:
        with engine.connect() as conn:
            conn.execute(text("SELECT 1"))
        return True
    except Exception as e:
        logger.error(f"Database connection failed: {e}")
        return False
</file>

<file path="backend/app/core/security.py">
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from jose import JWTError, jwt
from passlib.context import CryptContext
import secrets
import hashlib
import re

from app.core.config import settings

# Password hashing context
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against a hash"""
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    """Hash a password"""
    return pwd_context.hash(password)


def validate_password_strength(password: str) -> tuple[bool, str]:
    """
    Validate password meets security requirements
    Returns: (is_valid, error_message)
    """
    if len(password) < 8:
        return False, "Password must be at least 8 characters long"
    
    if len(password) > 128:
        return False, "Password must be less than 128 characters"
    
    if not re.search(r"[a-z]", password):
        return False, "Password must contain at least one lowercase letter"
    
    if not re.search(r"[A-Z]", password):
        return False, "Password must contain at least one uppercase letter"
    
    if not re.search(r"\d", password):
        return False, "Password must contain at least one number"
    
    if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
        return False, "Password must contain at least one special character"
    
    # Check for common passwords
    common_passwords = ["Password123!", "Admin123!", "Welcome123!"]
    if password in common_passwords:
        return False, "Password is too common"
    
    return True, ""


def create_access_token(
    data: Dict[str, Any],
    expires_delta: Optional[timedelta] = None
) -> str:
    """Create JWT access token"""
    to_encode = data.copy()
    
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(
            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
        )
    
    to_encode.update({
        "exp": expire,
        "iat": datetime.utcnow(),
        "type": "access"
    })
    
    encoded_jwt = jwt.encode(
        to_encode,
        settings.SECRET_KEY,
        algorithm=settings.ALGORITHM
    )
    return encoded_jwt


def verify_token(token: str) -> Dict[str, Any]:
    """Verify JWT token and return payload"""
    try:
        payload = jwt.decode(
            token,
            settings.SECRET_KEY,
            algorithms=[settings.ALGORITHM]
        )
        return payload
    except JWTError as e:
        raise ValueError(f"Invalid token: {str(e)}")


def generate_api_key() -> str:
    """Generate a secure API key"""
    # Generate 32 bytes of random data
    random_bytes = secrets.token_bytes(32)
    # Create a hash for additional security
    hash_object = hashlib.sha256(random_bytes)
    # Encode as URL-safe base64
    key = secrets.token_urlsafe(32)
    return f"sk_{key}"


def hash_api_key(api_key: str) -> str:
    """Hash an API key for storage"""
    return hashlib.sha256(api_key.encode()).hexdigest()


def verify_api_key(plain_key: str, hashed_key: str) -> bool:
    """Verify an API key against its hash"""
    return hash_api_key(plain_key) == hashed_key
</file>

<file path="backend/app/middleware/__init__.py">
from app.middleware.rate_limit import RateLimitMiddleware
from app.middleware.logging import LoggingMiddleware

__all__ = ["RateLimitMiddleware", "LoggingMiddleware"]
</file>

<file path="backend/app/middleware/logging.py">
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
import time
import logging

logger = logging.getLogger(__name__)


class LoggingMiddleware(BaseHTTPMiddleware):
    """Log all requests and responses"""
    
    async def dispatch(self, request: Request, call_next):
        start_time = time.time()
        
        # Log request
        logger.info(f"Request: {request.method} {request.url.path}")
        
        try:
            response = await call_next(request)
            process_time = time.time() - start_time
            
            # Log response
            logger.info(
                f"Response: {request.method} {request.url.path} "
                f"Status: {response.status_code} "
                f"Duration: {process_time:.3f}s"
            )
            
            # Add custom header
            response.headers["X-Process-Time"] = str(process_time)
            
            return response
        except Exception as e:
            process_time = time.time() - start_time
            logger.error(
                f"Error: {request.method} {request.url.path} "
                f"Duration: {process_time:.3f}s "
                f"Error: {str(e)}"
            )
            raise
</file>

<file path="backend/app/middleware/rate_limit.py">
from fastapi import Request, HTTPException, status
from starlette.middleware.base import BaseHTTPMiddleware
from datetime import datetime, timedelta
from typing import Dict, List
import logging

logger = logging.getLogger(__name__)


class RateLimitMiddleware(BaseHTTPMiddleware):
    """
    Production-safe rate limiting middleware with Proxy support
    """

    def __init__(self, app, requests_per_minute: int = 100):
        super().__init__(app)
        self.requests_per_minute = requests_per_minute
        self.requests: Dict[str, List[datetime]] = {}
        # Trust traffic from Docker internal networks
        self.trusted_proxies = ("172.", "10.", "192.168.", "127.0.0.1")
        
        self.excluded_paths = {
            "/health",
            "/api/v1/auth/me",
            "/docs",
            "/redoc",
            "/openapi.json"
        }

    def _is_internal(self, ip: str) -> bool:
        """Check if IP is from internal network"""
        return ip.startswith(self.trusted_proxies)
    
    def _is_excluded_path(self, path: str) -> bool:
        return path in self.excluded_paths or path.startswith("/static/")

    def _get_client_ip(self, request: Request) -> str:
        """
        Get real client IP, respecting X-Forwarded-For only from trusted proxies.
        """
        client_host = request.client.host
        
        # If request comes from a trusted proxy (Nginx), use X-Forwarded-For
        if self._is_internal(client_host):
            forwarded_for = request.headers.get("X-Forwarded-For")
            if forwarded_for:
                # Get the first IP in the list (original client)
                return forwarded_for.split(",")[0].strip()
        
        return client_host

    def _get_identity(self, request: Request) -> str:
        user_id = getattr(request.state, "user_id", None)
        if user_id:
            return f"user:{user_id}"

        return f"ip:{self._get_client_ip(request)}"

    async def dispatch(self, request: Request, call_next):
        # Skip excluded paths
        if self._is_excluded_path(request.url.path):
            return await call_next(request)

        # We do NOT skip internal IPs here anymore, because Nginx is internal.
        # We now identify based on the _real_ IP resolved in _get_identity.
        
        identity = self._get_identity(request)
        now = datetime.utcnow()

        # Remove timestamps older than 1 minute
        bucket = self.requests.get(identity, [])
        bucket = [t for t in bucket if now - t < timedelta(minutes=1)]

        if len(bucket) >= self.requests_per_minute:
            logger.warning(f"Rate limit exceeded for {identity} on path {request.url.path}")
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail="Rate limit exceeded. Please try again later.",
                headers={"Retry-After": "60"}
            )

        bucket.append(now)
        self.requests[identity] = bucket

        return await call_next(request)
</file>

<file path="backend/app/models/__init__.py">
from app.models.user import User
from app.models.client import Client
from app.models.activity import Activity
from app.models.api_key import ApiKey

__all__ = ["User", "Client", "Activity", "ApiKey"]
</file>

<file path="backend/app/models/activity.py">
from sqlalchemy import Column, Integer, String, DateTime, Text, Index, Float
from datetime import datetime
from app.core.database import Base


class Activity(Base):
    __tablename__ = "activities"
    
    id = Column(Integer, primary_key=True, index=True)
    client_id = Column(String(255), index=True, nullable=False)
    timestamp = Column(DateTime, default=datetime.utcnow, index=True, nullable=False)
    
    # Activity data
    active_window = Column(Text, nullable=True)
    active_application = Column(String(255), nullable=True)
    active_url = Column(Text, nullable=True)
    
    # Process information
    processes = Column(Text, nullable=True)  # JSON string
    process_count = Column(Integer, default=0)
    
    # System metrics
    system_metrics = Column(Text, nullable=True)  # JSON string
    cpu_percent = Column(Float, nullable=True)
    memory_percent = Column(Float, nullable=True)
    disk_percent = Column(Float, nullable=True)
    
    # Categorization
    activity_category = Column(String(50), nullable=True)  # work, break, idle, etc.
    productivity_score = Column(Integer, nullable=True)  # 0-100
    
    # Additional data
    additional_data = Column(Text, nullable=True)  # JSON string
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Indexes for performance
    __table_args__ = (
        Index('ix_activities_client_timestamp', 'client_id', 'timestamp'),
        Index('ix_activities_category', 'activity_category'),
        Index('ix_activities_timestamp_desc', 'timestamp'),
    )
    
    def __repr__(self):
        return f"<Activity(id={self.id}, client_id='{self.client_id}', timestamp={self.timestamp})>"
</file>

<file path="backend/app/models/api_key.py">
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text
from datetime import datetime
from app.core.database import Base


class ApiKey(Base):
    __tablename__ = "api_keys"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False)
    key_hash = Column(String(255), unique=True, index=True, nullable=False)
    key_prefix = Column(String(20), nullable=False)  # First few chars for identification
    
    # Status
    is_active = Column(Boolean, default=True, nullable=False)
    
    # Usage tracking
    last_used = Column(DateTime, nullable=True)
    usage_count = Column(Integer, default=0, nullable=False)
    
    # Restrictions
    allowed_ips = Column(Text, nullable=True)  # Comma-separated IPs
    rate_limit = Column(Integer, nullable=True)  # Requests per minute
    expires_at = Column(DateTime, nullable=True)
    
    # Metadata
    created_by = Column(Integer, nullable=True)  # User ID
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f"<ApiKey(id={self.id}, name='{self.name}', active={self.is_active})>"
</file>

<file path="backend/app/models/client.py">
from sqlalchemy import Column, Integer, String, DateTime, Text, Boolean, Index
from datetime import datetime
from app.core.database import Base


class Client(Base):
    __tablename__ = "clients"
    
    id = Column(Integer, primary_key=True, index=True)
    client_id = Column(String(255), unique=True, index=True, nullable=False)
    client_type = Column(String(50), nullable=False)
    hostname = Column(String(255), nullable=True)
    ip_address = Column(String(50), nullable=True)
    platform_info = Column(Text, nullable=True)  # JSON string
    
    # Status
    is_active = Column(Boolean, default=True, nullable=False)
    last_seen = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Consent and compliance
    employee_consent = Column(Boolean, default=False, nullable=False)
    consent_date = Column(DateTime, nullable=True)
    consent_ip = Column(String(50), nullable=True)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Indexes for performance
    __table_args__ = (
        Index('ix_clients_last_seen', 'last_seen'),
        Index('ix_clients_type_active', 'client_type', 'is_active'),
    )
    
    def __repr__(self):
        return f"<Client(id={self.id}, client_id='{self.client_id}', type='{self.client_type}')>"
</file>

<file path="backend/app/models/user.py">
from sqlalchemy import Column, Integer, String, Boolean, DateTime
from datetime import datetime
from app.core.database import Base


class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, index=True, nullable=False)
    email = Column(String(255), unique=True, index=True, nullable=True)
    hashed_password = Column(String(255), nullable=False)
    is_admin = Column(Boolean, default=False, nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    force_password_change = Column(Boolean, default=False, nullable=False)
    failed_login_attempts = Column(Integer, default=0, nullable=False)
    last_login = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f"<User(id={self.id}, username='{self.username}', is_admin={self.is_admin})>"
</file>

<file path="backend/app/schemas/__init__.py">
from app.schemas.user import (
    UserLogin, UserCreate, UserOut, UserUpdate,
    Token, ChangePassword
)
from app.schemas.client import ClientOut, ClientCreate, ClientUpdate
from app.schemas.activity import ActivityOut, ActivityCreate, ActivityStats
from app.schemas.api_key import ApiKeyCreate, ApiKeyOut, ApiKeyResponse

__all__ = [
    "UserLogin", "UserCreate", "UserOut", "UserUpdate",
    "Token", "ChangePassword",
    "ClientOut", "ClientCreate", "ClientUpdate",
    "ActivityOut", "ActivityCreate", "ActivityStats",
    "ApiKeyCreate", "ApiKeyOut", "ApiKeyResponse"
]
</file>

<file path="backend/app/schemas/activity.py">
from pydantic import BaseModel, field_validator
from typing import Optional, List, Dict, Any
from datetime import datetime
import json


class ActivityCreate(BaseModel):
    client_id: str
    timestamp: Optional[datetime] = None
    active_window: Optional[str] = None
    active_application: Optional[str] = None
    active_url: Optional[str] = None
    processes: Optional[List[Dict[str, Any]]] = None
    system_metrics: Optional[Dict[str, Any]] = None
    additional_data: Optional[Dict[str, Any]] = None


class ActivityOut(BaseModel):
    id: int
    client_id: str
    timestamp: datetime
    active_window: Optional[str] = None
    active_application: Optional[str] = None
    active_url: Optional[str] = None
    processes: Optional[List[Dict[str, Any]]] = None
    process_count: int
    system_metrics: Optional[Dict[str, Any]] = None
    cpu_percent: Optional[float] = None
    memory_percent: Optional[float] = None
    disk_percent: Optional[float] = None
    activity_category: Optional[str] = None
    productivity_score: Optional[int] = None
    
    @field_validator('processes', 'system_metrics', mode='before')
    @classmethod
    def parse_json_fields(cls, v):
        if isinstance(v, str):
            try:
                return json.loads(v)
            except json.JSONDecodeError:
                return None
        return v

    class Config:
        from_attributes = True


class ActivityStats(BaseModel):
    total_activities: int
    active_clients: int
    avg_cpu: Optional[float] = None
    avg_memory: Optional[float] = None
    top_applications: List[Dict[str, Any]] = []
    productivity_breakdown: Dict[str, int] = {}
</file>

<file path="backend/app/schemas/api_key.py">
from pydantic import BaseModel, validator
from typing import Optional, List
from datetime import datetime


class ApiKeyCreate(BaseModel):
    name: str
    allowed_ips: Optional[List[str]] = None
    rate_limit: Optional[int] = None
    expires_at: Optional[datetime] = None
    
    @validator('name')
    def name_length(cls, v):
        if len(v) < 3 or len(v) > 255:
            raise ValueError('Name must be between 3 and 255 characters')
        return v


class ApiKeyOut(BaseModel):
    id: int
    name: str
    key_prefix: str
    is_active: bool
    last_used: Optional[datetime] = None
    usage_count: int
    allowed_ips: Optional[str] = None
    rate_limit: Optional[int] = None
    expires_at: Optional[datetime] = None
    created_at: datetime
    
    class Config:
        from_attributes = True


class ApiKeyResponse(BaseModel):
    """Response when creating a new API key - includes full key"""
    id: int
    name: str
    key: str  # Full API key - only shown once
    key_prefix: str
    created_at: datetime
    
    class Config:
        from_attributes = True
</file>

<file path="backend/app/schemas/client.py">
from pydantic import BaseModel, validator, field_validator
from typing import Optional, Dict, Any
from datetime import datetime
import json


class ClientCreate(BaseModel):
    client_id: str
    client_type: str
    hostname: Optional[str] = None
    ip_address: Optional[str] = None
    platform_info: Optional[Dict[str, Any]] = None
    employee_consent: bool = False
    
    @validator('client_type')
    def validate_client_type(cls, v):
        valid_types = ['linux_desktop', 'linux_server', 'windows_desktop', 'windows_server', 'macos_desktop']
        if v not in valid_types:
            raise ValueError(f'client_type must be one of {valid_types}')
        return v


class ClientUpdate(BaseModel):
    hostname: Optional[str] = None
    ip_address: Optional[str] = None
    platform_info: Optional[Dict[str, Any]] = None
    is_active: Optional[bool] = None
    employee_consent: Optional[bool] = None


class ClientOut(BaseModel):
    id: int
    client_id: str
    client_type: str
    hostname: Optional[str] = None
    ip_address: Optional[str] = None
    platform_info: Optional[Dict[str, Any]] = None
    is_active: bool
    last_seen: datetime
    employee_consent: bool
    consent_date: Optional[datetime] = None
    created_at: datetime
    updated_at: datetime
    
    @field_validator('platform_info', mode='before')
    @classmethod
    def parse_platform_info(cls, v):
        if isinstance(v, str):
            try:
                return json.loads(v)
            except json.JSONDecodeError:
                return None
        return v

    class Config:
        from_attributes = True
</file>

<file path="backend/app/schemas/user.py">
from pydantic import BaseModel, EmailStr, validator
from typing import Optional
from datetime import datetime


class UserLogin(BaseModel):
    username: str
    password: str


class UserCreate(BaseModel):
    username: str
    email: Optional[EmailStr] = None
    password: str
    is_admin: bool = False
    
    @validator('username')
    def username_alphanumeric(cls, v):
        if not v.replace('_', '').replace('-', '').isalnum():
            raise ValueError('Username must be alphanumeric (with _ or -)')
        if len(v) < 3 or len(v) > 50:
            raise ValueError('Username must be between 3 and 50 characters')
        return v


class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    is_active: Optional[bool] = None


class UserOut(BaseModel):
    id: int
    username: str
    email: Optional[str] = None
    is_admin: bool
    is_active: bool
    force_password_change: bool
    last_login: Optional[datetime] = None
    created_at: datetime
    
    class Config:
        from_attributes = True


class Token(BaseModel):
    access_token: str
    token_type: str
    expires_in: int
    force_password_change: bool = False


class ChangePassword(BaseModel):
    current_password: str
    new_password: str
    
    @validator('new_password')
    def password_strength(cls, v):
        from app.core.security import validate_password_strength
        is_valid, error = validate_password_strength(v)
        if not is_valid:
            raise ValueError(error)
        return v
</file>

<file path="backend/app/services/__init__.py">
from app.services.auth_service import AuthService
from app.services.client_service import ClientService
from app.services.activity_service import ActivityService

__all__ = ["AuthService", "ClientService", "ActivityService"]
</file>

<file path="backend/app/services/activity_service.py">
from sqlalchemy.orm import Session
from sqlalchemy import func, desc
from typing import Optional, List, Dict, Any, Tuple
from datetime import datetime, timedelta
import json
import logging

from app.models.activity import Activity
from app.schemas.activity import ActivityCreate

logger = logging.getLogger(__name__)


class ActivityService:
    def __init__(self, db: Session):
        self.db = db
    
    def create_activity(self, activity_data: ActivityCreate) -> Tuple[Optional[Activity], str]:
        """
        Create new activity record
        Returns: (activity, error_message)
        """
        try:
            # Extract metrics for indexing
            cpu_percent = None
            memory_percent = None
            disk_percent = None
            
            if activity_data.system_metrics:
                cpu_percent = activity_data.system_metrics.get('cpu_percent')
                memory_percent = activity_data.system_metrics.get('memory_percent')
                disk_percent = activity_data.system_metrics.get('disk_percent')
            
            # Count processes
            process_count = len(activity_data.processes) if activity_data.processes else 0
            
            # Categorize activity
            category = self._categorize_activity(
                activity_data.active_window,
                activity_data.active_application,
                activity_data.active_url
            )
            
            # Calculate productivity score
            productivity_score = self._calculate_productivity_score(
                category,
                process_count,
                cpu_percent
            )
            
            activity = Activity(
                client_id=activity_data.client_id,
                timestamp=activity_data.timestamp or datetime.utcnow(),
                active_window=activity_data.active_window,
                active_application=activity_data.active_application,
                active_url=activity_data.active_url,
                processes=json.dumps(activity_data.processes) if activity_data.processes else None,
                process_count=process_count,
                system_metrics=json.dumps(activity_data.system_metrics) if activity_data.system_metrics else None,
                cpu_percent=cpu_percent,
                memory_percent=memory_percent,
                disk_percent=disk_percent,
                activity_category=category,
                productivity_score=productivity_score,
                additional_data=json.dumps(activity_data.additional_data) if activity_data.additional_data else None
            )
            
            self.db.add(activity)
            self.db.commit()
            self.db.refresh(activity)
            
            return activity, ""
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error creating activity: {e}")
            return None, "Error creating activity"
    
    def get_activity(self, activity_id: int) -> Optional[Activity]:
        """Get activity by ID"""
        return self.db.query(Activity).filter(Activity.id == activity_id).first()
    
    def get_activities(
        self,
        skip: int = 0,
        limit: int = 100,
        client_id: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        category: Optional[str] = None
    ) -> List[Activity]:
        """Get activities with filtering"""
        query = self.db.query(Activity)
        
        if client_id:
            query = query.filter(Activity.client_id == client_id)
        
        if start_date:
            query = query.filter(Activity.timestamp >= start_date)
        
        if end_date:
            query = query.filter(Activity.timestamp <= end_date)
        
        if category:
            query = query.filter(Activity.activity_category == category)
        
        return query.order_by(Activity.timestamp.desc()).offset(skip).limit(limit).all()
    
    def get_activity_stats(
        self,
        client_id: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> Dict[str, Any]:
        """Get activity statistics"""
        query = self.db.query(Activity)
        
        if client_id:
            query = query.filter(Activity.client_id == client_id)
        
        if start_date:
            query = query.filter(Activity.timestamp >= start_date)
        
        if end_date:
            query = query.filter(Activity.timestamp <= end_date)
        
        total = query.count()
        
        # Average metrics
        avg_cpu = query.with_entities(func.avg(Activity.cpu_percent)).scalar()
        avg_memory = query.with_entities(func.avg(Activity.memory_percent)).scalar()
        avg_productivity = query.with_entities(func.avg(Activity.productivity_score)).scalar()
        
        # Top applications
        top_apps = query.filter(Activity.active_application.isnot(None)).with_entities(
            Activity.active_application,
            func.count(Activity.id).label('count')
        ).group_by(Activity.active_application).order_by(desc('count')).limit(10).all()
        
        # Category breakdown
        category_stats = query.filter(Activity.activity_category.isnot(None)).with_entities(
            Activity.activity_category,
            func.count(Activity.id).label('count')
        ).group_by(Activity.activity_category).all()
        
        # Active clients
        active_clients = query.with_entities(
            func.count(func.distinct(Activity.client_id))
        ).scalar()
        
        return {
            'total_activities': total,
            'active_clients': active_clients or 0,
            'avg_cpu': round(avg_cpu, 2) if avg_cpu else None,
            'avg_memory': round(avg_memory, 2) if avg_memory else None,
            'avg_productivity': round(avg_productivity, 2) if avg_productivity else None,
            'top_applications': [
                {'application': app, 'count': count}
                for app, count in top_apps
            ],
            'category_breakdown': {
                category: count
                for category, count in category_stats
            }
        }
    
    def cleanup_old_activities(self, days: int = 90) -> int:
        """Delete activities older than specified days"""
        threshold = datetime.utcnow() - timedelta(days=days)
        
        try:
            deleted = self.db.query(Activity).filter(
                Activity.timestamp < threshold
            ).delete()
            
            self.db.commit()
            logger.info(f"Cleaned up {deleted} old activities")
            return deleted
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error cleaning up activities: {e}")
            return 0
    
    def _categorize_activity(
        self,
        window: Optional[str],
        application: Optional[str],
        url: Optional[str]
    ) -> str:
        """Categorize activity based on context"""
        if not window and not application:
            return 'idle'
        
        # Work-related keywords
        work_keywords = [
            'vscode', 'visual studio', 'pycharm', 'intellij', 'eclipse',
            'terminal', 'cmd', 'powershell', 'bash',
            'excel', 'word', 'powerpoint', 'outlook',
            'slack', 'teams', 'zoom', 'meet',
            'jira', 'confluence', 'github', 'gitlab'
        ]
        
        # Break/personal keywords
        break_keywords = [
            'youtube', 'facebook', 'twitter', 'instagram', 'reddit',
            'netflix', 'spotify', 'steam', 'game'
        ]
        
        text = f"{window or ''} {application or ''} {url or ''}".lower()
        
        if any(keyword in text for keyword in work_keywords):
            return 'work'
        elif any(keyword in text for keyword in break_keywords):
            return 'break'
        else:
            return 'other'
    
    def _calculate_productivity_score(
        self,
        category: str,
        process_count: int,
        cpu_percent: Optional[float]
    ) -> int:
        """Calculate productivity score (0-100)"""
        score = 50  # Base score
        
        # Category impact
        if category == 'work':
            score += 30
        elif category == 'break':
            score -= 20
        elif category == 'idle':
            score -= 30
        
        # Process count impact
        if process_count > 20:
            score += 10
        elif process_count < 5:
            score -= 10
        
        # CPU usage impact
        if cpu_percent:
            if 20 <= cpu_percent <= 70:
                score += 10  # Active work
            elif cpu_percent > 90:
                score -= 10  # System overload
        
        # Clamp between 0 and 100
        return max(0, min(100, score))
</file>

<file path="backend/app/services/auth_service.py">
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from typing import Optional, Tuple
import logging
from fastapi import Request

from app.core.security import (
    verify_password,
    get_password_hash,
    create_access_token,
    validate_password_strength,
)
from app.models.user import User
from app.models.api_key import ApiKey
from app.core.security import hash_api_key, verify_api_key, generate_api_key
from app.core.config import settings

logger = logging.getLogger(__name__)


class AuthService:
    def __init__(self, db: Session):
        self.db = db

    def authenticate_user(
        self,
        username: str,
        password: str,
        request: Optional[Request] = None,
    ) -> Tuple[Optional[User], str]:
        """
        Authenticate a user by username + password.
        Uses constant-time comparison principles where possible to reduce timing leaks.
        """
        user = self.db.query(User).filter(User.username == username).first()
        
        # If user doesn't exist, we still verify a dummy password to prevent timing attacks
        if not user:
            # This is a dummy verify to take up time
            verify_password(password, "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWrn.96pprCtk.iYF3d4.n.n.n.n")
            logger.warning(f"Login attempt for non-existent user: {username}")
            return None, "Invalid credentials"

        if not verify_password(password, user.hashed_password):
            user.failed_login_attempts += 1
            self.db.commit()
            logger.warning(f"Failed login attempt for user: {username}")
            return None, "Invalid credentials"

        # Check status after password verification to verify credentials first
        if not user.is_active:
            logger.warning(f"Login attempt for inactive user: {username}")
            return None, "Account is disabled"

        if user.failed_login_attempts >= 5:
            logger.warning(f"Account locked due to failed attempts: {username}")
            return None, "Account is temporarily locked. Contact administrator."

        # Successful login
        user.failed_login_attempts = 0
        user.last_login = datetime.utcnow()
        self.db.commit()

        # Inject user_id for rate limiting if request context is provided
        if request is not None:
            request.state.user_id = user.id

        logger.info(f"Successful login: {username}")
        return user, ""

    def create_user(
        self,
        username: str,
        password: str,
        email: Optional[str] = None,
        is_admin: bool = False,
    ) -> Tuple[Optional[User], str]:

        existing_user = self.db.query(User).filter(User.username == username).first()
        if existing_user:
            return None, "Username already exists"

        if email:
            existing_email = self.db.query(User).filter(User.email == email).first()
            if existing_email:
                return None, "Email already exists"

        is_valid, error = validate_password_strength(password)
        if not is_valid:
            return None, error

        try:
            user = User(
                username=username,
                email=email,
                hashed_password=get_password_hash(password),
                is_admin=is_admin,
                is_active=True,
            )
            self.db.add(user)
            self.db.commit()
            self.db.refresh(user)

            logger.info(f"User created: {username}")
            return user, ""
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error creating user: {e}")
            return None, "Error creating user"

    def change_password(
        self, user: User, current_password: str, new_password: str
    ) -> Tuple[bool, str]:
        if not verify_password(current_password, user.hashed_password):
            logger.warning(f"Failed password change attempt for user: {user.username}")
            return False, "Current password is incorrect"

        is_valid, error = validate_password_strength(new_password)
        if not is_valid:
            return False, error

        if verify_password(new_password, user.hashed_password):
            return False, "New password must be different from current password"

        try:
            user.hashed_password = get_password_hash(new_password)
            user.force_password_change = False
            self.db.commit()

            logger.info(f"Password changed for user: {user.username}")
            return True, ""
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error changing password: {e}")
            return False, "Error changing password"

    def create_access_token_for_user(self, user: User) -> str:
        access_token_expires = timedelta(
            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
        )
        access_token = create_access_token(
            data={"sub": user.username, "admin": user.is_admin},
            expires_delta=access_token_expires,
        )
        return access_token

    def create_api_key(
        self,
        name: str,
        created_by: int,
        allowed_ips: Optional[str] = None,
        rate_limit: Optional[int] = None,
        expires_at: Optional[datetime] = None,
    ) -> Tuple[Optional[ApiKey], Optional[str], str]:

        try:
            plain_key = generate_api_key()
            key_hash = hash_api_key(plain_key)
            key_prefix = plain_key[:10]

            api_key = ApiKey(
                name=name,
                key_hash=key_hash,
                key_prefix=key_prefix,
                created_by=created_by,
                allowed_ips=allowed_ips,
                rate_limit=rate_limit,
                expires_at=expires_at,
                is_active=True,
            )

            self.db.add(api_key)
            self.db.commit()
            self.db.refresh(api_key)

            logger.info(f"API key created: {name}")
            return api_key, plain_key, ""
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error creating API key: {e}")
            return None, None, "Error creating API key"

    def verify_api_key(self, api_key: str) -> Tuple[Optional[ApiKey], str]:
        if not api_key or not api_key.startswith("sk_"):
            return None, "Invalid API key format"

        key_hash = hash_api_key(api_key)

        db_api_key = (
            self.db.query(ApiKey)
            .filter(ApiKey.key_hash == key_hash, ApiKey.is_active == True)
            .first()
        )

        if not db_api_key:
            logger.warning(f"Invalid API key attempt: {api_key[:10]}...")
            return None, "Invalid API key"

        if db_api_key.expires_at and db_api_key.expires_at < datetime.utcnow():
            logger.warning(f"Expired API key used: {db_api_key.name}")
            return None, "API key has expired"

        db_api_key.last_used = datetime.utcnow()
        db_api_key.usage_count += 1
        self.db.commit()

        return db_api_key, ""

    def revoke_api_key(self, key_id: int) -> Tuple[bool, str]:
        api_key = self.db.query(ApiKey).filter(ApiKey.id == key_id).first()
        if not api_key:
            return False, "API key not found"

        try:
            api_key.is_active = False
            self.db.commit()
            logger.info(f"API key revoked: {api_key.name}")
            return True, ""
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error revoking API key: {e}")
            return False, "Error revoking API key"

    def list_api_keys(self) -> list[ApiKey]:
        return (
            self.db.query(ApiKey)
            .filter(ApiKey.is_active == True)  # <--- Add this filter
            .order_by(ApiKey.created_at.desc())
            .all()
        )


def create_initial_admin():
    from app.core.database import SessionLocal

    db = SessionLocal()
    try:
        admin = (
            db.query(User)
            .filter(User.username == settings.INITIAL_ADMIN_USERNAME)
            .first()
        )
        if not admin:
            is_valid, error = validate_password_strength(
                settings.INITIAL_ADMIN_PASSWORD
            )
            if not is_valid:
                logger.error(
                    f"Initial admin password not strong enough: {error}"
                )
                return

            admin = User(
                username=settings.INITIAL_ADMIN_USERNAME,
                email=None,
                hashed_password=get_password_hash(
                    settings.INITIAL_ADMIN_PASSWORD
                ),
                is_admin=True,
                is_active=True,
                force_password_change=settings.FORCE_ADMIN_PASSWORD_CHANGE,
            )
            db.add(admin)
            db.commit()
            logger.info(
                f"Created initial admin user: {settings.INITIAL_ADMIN_USERNAME}"
            )
        else:
            logger.info("Admin user already exists")
    except Exception as e:
        db.rollback()
        logger.error(f"Error creating initial admin: {e}")
    finally:
        db.close()
</file>

<file path="backend/app/services/client_service.py">
from sqlalchemy.orm import Session
from typing import Optional, List, Tuple
from datetime import datetime, timedelta
import json
import logging

from app.models.client import Client
from app.schemas.client import ClientCreate, ClientUpdate

logger = logging.getLogger(__name__)


class ClientService:
    def __init__(self, db: Session):
        self.db = db
    
    def get_client(self, client_id: str) -> Optional[Client]:
        """Get client by ID"""
        return self.db.query(Client).filter(Client.client_id == client_id).first()
    
    def get_clients(
        self,
        skip: int = 0,
        limit: int = 100,
        is_active: Optional[bool] = None,
        client_type: Optional[str] = None
    ) -> List[Client]:
        """Get clients with filtering"""
        query = self.db.query(Client)
        
        if is_active is not None:
            query = query.filter(Client.is_active == is_active)
        
        if client_type:
            query = query.filter(Client.client_type == client_type)
        
        return query.order_by(Client.last_seen.desc()).offset(skip).limit(limit).all()
    
    def create_or_update_client(
        self,
        client_data: ClientCreate
    ) -> Tuple[Client, bool]:
        """
        Create or update client
        Returns: (client, is_new)
        """
        client = self.get_client(client_data.client_id)
        is_new = False
        
        try:
            if client:
                # Update existing client
                client.last_seen = datetime.utcnow()
                if client_data.hostname:
                    client.hostname = client_data.hostname
                if client_data.ip_address:
                    client.ip_address = client_data.ip_address
                if client_data.platform_info:
                    client.platform_info = json.dumps(client_data.platform_info)
                if client_data.employee_consent:
                    if not client.employee_consent:
                        client.employee_consent = True
                        client.consent_date = datetime.utcnow()
                        client.consent_ip = client_data.ip_address
            else:
                # Create new client
                is_new = True
                client = Client(
                    client_id=client_data.client_id,
                    client_type=client_data.client_type,
                    hostname=client_data.hostname,
                    ip_address=client_data.ip_address,
                    platform_info=json.dumps(client_data.platform_info) if client_data.platform_info else None,
                    employee_consent=client_data.employee_consent,
                    consent_date=datetime.utcnow() if client_data.employee_consent else None,
                    consent_ip=client_data.ip_address if client_data.employee_consent else None,
                    is_active=True
                )
                self.db.add(client)
            
            self.db.commit()
            self.db.refresh(client)
            
            if is_new:
                logger.info(f"New client registered: {client.client_id}")
            
            return client, is_new
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error creating/updating client: {e}")
            raise
    
    def update_client(
        self,
        client_id: str,
        update_data: ClientUpdate
    ) -> Tuple[Optional[Client], str]:
        """
        Update client
        Returns: (client, error_message)
        """
        client = self.get_client(client_id)
        if not client:
            return None, "Client not found"
        
        try:
            if update_data.hostname is not None:
                client.hostname = update_data.hostname
            if update_data.ip_address is not None:
                client.ip_address = update_data.ip_address
            if update_data.platform_info is not None:
                client.platform_info = json.dumps(update_data.platform_info)
            if update_data.is_active is not None:
                client.is_active = update_data.is_active
            if update_data.employee_consent is not None and update_data.employee_consent:
                if not client.employee_consent:
                    client.employee_consent = True
                    client.consent_date = datetime.utcnow()
            
            client.updated_at = datetime.utcnow()
            self.db.commit()
            self.db.refresh(client)
            
            logger.info(f"Client updated: {client_id}")
            return client, ""
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error updating client: {e}")
            return None, "Error updating client"
    
    def delete_client(self, client_id: str) -> Tuple[bool, str]:
        """
        Delete client
        Returns: (success, error_message)
        """
        client = self.get_client(client_id)
        if not client:
            return False, "Client not found"
        
        try:
            self.db.delete(client)
            self.db.commit()
            logger.info(f"Client deleted: {client_id}")
            return True, ""
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error deleting client: {e}")
            return False, "Error deleting client"
    
    def get_online_clients(self, minutes: int = 5) -> List[Client]:
        """Get clients that were active in the last N minutes"""
        threshold = datetime.utcnow() - timedelta(minutes=minutes)
        return self.db.query(Client).filter(
            Client.last_seen >= threshold,
            Client.is_active == True
        ).all()
    
    def get_client_count(self) -> int:
        """Get total client count"""
        return self.db.query(Client).filter(Client.is_active == True).count()
</file>

<file path="backend/app/tests/__init__.py">
"""
Test suite for Sentinel backend
"""
</file>

<file path="backend/app/tests/conftest.py">
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool

from app.main import app
from app.core.database import Base, get_db
from app.core.security import get_password_hash
from app.models.user import User

# Test database URL
SQLALCHEMY_DATABASE_URL = "sqlite:///:memory:"

# Create test engine
engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    connect_args={"check_same_thread": False},
    poolclass=StaticPool,
)

TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


@pytest.fixture(scope="function")
def db_session():
    """Create a fresh database for each test"""
    Base.metadata.create_all(bind=engine)
    session = TestingSessionLocal()
    try:
        yield session
    finally:
        session.close()
        Base.metadata.drop_all(bind=engine)


@pytest.fixture(scope="function")
def client(db_session):
    """Create test client with test database"""
    def override_get_db():
        try:
            yield db_session
        finally:
            pass
    
    app.dependency_overrides[get_db] = override_get_db
    with TestClient(app) as test_client:
        yield test_client
    app.dependency_overrides.clear()


@pytest.fixture(scope="function")
def test_user(db_session):
    """Create a test user"""
    user = User(
        username="testuser",
        email="test@example.com",
        hashed_password=get_password_hash("Test123!@#"),
        is_admin=False,
        is_active=True
    )
    db_session.add(user)
    db_session.commit()
    db_session.refresh(user)
    return user


@pytest.fixture(scope="function")
def test_admin(db_session):
    """Create a test admin user"""
    admin = User(
        username="admin",
        email="admin@example.com",
        hashed_password=get_password_hash("Admin123!@#"),
        is_admin=True,
        is_active=True
    )
    db_session.add(admin)
    db_session.commit()
    db_session.refresh(admin)
    return admin


@pytest.fixture(scope="function")
def auth_headers(client, test_user):
    """Get authentication headers for test user"""
    response = client.post(
        "/api/v1/auth/login",
        json={"username": "testuser", "password": "Test123!@#"}
    )
    token = response.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}


@pytest.fixture(scope="function")
def admin_headers(client, test_admin):
    """Get authentication headers for admin user"""
    response = client.post(
        "/api/v1/auth/login",
        json={"username": "admin", "password": "Admin123!@#"}
    )
    token = response.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}
</file>

<file path="backend/app/tests/test_activities.py">
import pytest
from datetime import datetime


def test_get_activities(client, auth_headers):
    """Test getting list of activities"""
    response = client.get("/api/v1/activities/", headers=auth_headers)
    assert response.status_code == 200
    assert isinstance(response.json(), list)


def test_get_activities_unauthorized(client):
    """Test getting activities without authentication"""
    response = client.get("/api/v1/activities/")
    assert response.status_code == 403


def test_get_activity_stats(client, auth_headers):
    """Test getting activity statistics"""
    response = client.get("/api/v1/activities/stats", headers=auth_headers)
    assert response.status_code == 200
    data = response.json()
    assert "total_activities" in data
    assert "active_clients" in data
</file>

<file path="backend/app/tests/test_auth.py">
import pytest
from app.core.security import get_password_hash, verify_password, validate_password_strength


def test_password_hashing():
    """Test password hashing and verification"""
    password = "TestPassword123!@#"
    hashed = get_password_hash(password)
    
    assert verify_password(password, hashed) is True
    assert verify_password("WrongPassword", hashed) is False


def test_password_strength_validation():
    """Test password strength validation"""
    # Valid password
    is_valid, error = validate_password_strength("ValidPass123!@#")
    assert is_valid is True
    assert error == ""
    
    # Too short
    is_valid, error = validate_password_strength("Short1!")
    assert is_valid is False
    assert "at least 8 characters" in error
    
    # No uppercase
    is_valid, error = validate_password_strength("lowercase123!")
    assert is_valid is False
    assert "uppercase" in error
    
    # No lowercase
    is_valid, error = validate_password_strength("UPPERCASE123!")
    assert is_valid is False
    assert "lowercase" in error
    
    # No number
    is_valid, error = validate_password_strength("NoNumber!@#")
    assert is_valid is False
    assert "number" in error
    
    # No special character
    is_valid, error = validate_password_strength("NoSpecial123")
    assert is_valid is False
    assert "special character" in error


def test_login_success(client, test_user):
    """Test successful login"""
    response = client.post(
        "/api/v1/auth/login",
        json={"username": "testuser", "password": "Test123!@#"}
    )
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"


def test_login_invalid_credentials(client, test_user):
    """Test login with invalid credentials"""
    response = client.post(
        "/api/v1/auth/login",
        json={"username": "testuser", "password": "WrongPassword"}
    )
    assert response.status_code == 401


def test_login_nonexistent_user(client):
    """Test login with non-existent user"""
    response = client.post(
        "/api/v1/auth/login",
        json={"username": "nonexistent", "password": "Password123!"}
    )
    assert response.status_code == 401


def test_get_current_user(client, auth_headers):
    """Test getting current user information"""
    response = client.get("/api/v1/auth/me", headers=auth_headers)
    assert response.status_code == 200
    data = response.json()
    assert data["username"] == "testuser"


def test_get_current_user_unauthorized(client):
    """Test getting current user without authentication"""
    response = client.get("/api/v1/auth/me")
    assert response.status_code == 403  # No credentials provided


def test_change_password_success(client, auth_headers):
    """Test successful password change"""
    response = client.post(
        "/api/v1/auth/change-password",
        headers=auth_headers,
        json={
            "current_password": "Test123!@#",
            "new_password": "NewPassword123!@#"
        }
    )
    assert response.status_code == 200


def test_change_password_wrong_current(client, auth_headers):
    """Test password change with wrong current password"""
    response = client.post(
        "/api/v1/auth/change-password",
        headers=auth_headers,
        json={
            "current_password": "WrongPassword",
            "new_password": "NewPassword123!@#"
        }
    )
    assert response.status_code == 400


def test_change_password_weak_new(client, auth_headers):
    """Test password change with weak new password"""
    response = client.post(
        "/api/v1/auth/change-password",
        headers=auth_headers,
        json={
            "current_password": "Test123!@#",
            "new_password": "weak"
        }
    )
    assert response.status_code == 422  # Validation error
</file>

<file path="backend/app/tests/test_clients.py">
import pytest


def test_get_clients(client, auth_headers):
    """Test getting list of clients"""
    response = client.get("/api/v1/clients/", headers=auth_headers)
    assert response.status_code == 200
    assert isinstance(response.json(), list)


def test_get_clients_unauthorized(client):
    """Test getting clients without authentication"""
    response = client.get("/api/v1/clients/")
    assert response.status_code == 403


def test_get_client_stats(client, auth_headers):
    """Test getting client statistics"""
    response = client.get("/api/v1/clients/stats", headers=auth_headers)
    assert response.status_code == 200
    data = response.json()
    assert "total_clients" in data
    assert "online_clients" in data
</file>

<file path="backend/app/__init__.py">
"""
Sentinel Backend Application
Employee Monitoring System with Enhanced Security and Compliance
"""

__version__ = "1.0.0"
__author__ = "Sentinel Team"
</file>

<file path="backend/app/main.py">
# app/main.py

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
import logging

from app.core.config import settings
from app.core.database import init_db, check_db_connection
from app.api.routes import auth_router, clients_router, activities_router
from app.middleware import LoggingMiddleware, RateLimitMiddleware
from app.services.auth_service import create_initial_admin

logging.basicConfig(
    level=logging.INFO if not settings.DEBUG else logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

app = FastAPI(
    title=settings.PROJECT_NAME,
    version=settings.API_VERSION,
    docs_url="/docs" if settings.DEBUG else None,
    redoc_url="/redoc" if settings.DEBUG else None,
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.get_allowed_origins(),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Logging middleware
app.add_middleware(LoggingMiddleware)

# Rate limiting with higher limits (200 requests per minute)
app.add_middleware(RateLimitMiddleware, requests_per_minute=200)

# HTTPS enforcement
if settings.REQUIRE_HTTPS:
    app.add_middleware(TrustedHostMiddleware, allowed_hosts=["*"])


@app.on_event("startup")
async def startup_event():
    logger.info(f"🚀 Starting {settings.PROJECT_NAME} API v{settings.API_VERSION}")
    logger.info(f"Environment: {settings.ENVIRONMENT}")
    logger.info(f"Debug mode: {settings.DEBUG}")
    
    if not check_db_connection():
        logger.error("❌ Failed to connect to database")
        raise RuntimeError("Database connection failed")
    
    logger.info("✅ Database connection successful")
    
    try:
        init_db()
    except Exception as e:
        logger.error(f"❌ DB initialization failed: {e}")
        raise
    
    try:
        create_initial_admin()
    except Exception as e:
        logger.warning(f"⚠️ Initial admin creation: {e}")
    
    logger.info("✅ Application fully started")


@app.on_event("shutdown")
async def shutdown_event():
    logger.info("👋 Shutting down application")


@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "environment": settings.ENVIRONMENT,
        "version": settings.API_VERSION
    }


# API Routes
app.include_router(
    auth_router,
    prefix=f"/api/{settings.API_VERSION}/auth",
    tags=["Authentication"]
)

app.include_router(
    clients_router,
    prefix=f"/api/{settings.API_VERSION}/clients",
    tags=["Clients"]
)

app.include_router(
    activities_router,
    prefix=f"/api/{settings.API_VERSION}/activities",
    tags=["Activities"]
)


@app.get("/")
async def root():
    return {
        "message": f"Welcome to {settings.PROJECT_NAME} API",
        "version": settings.API_VERSION,
        "docs": "/docs" if settings.DEBUG else "Documentation disabled in production"
    }


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=settings.DEBUG
    )
</file>

<file path="backend/.gitignore">
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/
env/

# Environment Variables
.env
.env.local
.env.*.local

# Database
*.db
*.sqlite
*.sqlite3
data/
backups/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# Testing
.pytest_cache/
.coverage
htmlcov/
.tox/

# Logs
*.log
logs/

# OS
.DS_Store
Thumbs.db

# Alembic
alembic/versions/*.pyc
</file>

<file path="backend/alembic.ini">
[alembic]
script_location = alembic
prepend_sys_path = .
version_path_separator = os

[post_write_hooks]

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
</file>

<file path="backend/docker-entrypoint.sh">
#!/bin/bash
set -e

echo "Waiting for PostgreSQL to be ready..."
max_retries=30
count=0
while ! pg_isready -h postgres -p 5432 -U sentinel_user > /dev/null 2>&1; do
    count=$((count + 1))
    if [ $count -gt $max_retries ]; then
        echo "PostgreSQL did not become ready in time"
        exit 1
    fi
    echo "Waiting for PostgreSQL... ($count/$max_retries)"
    sleep 2
done
echo "✅ PostgreSQL is ready!"

echo "Running database migrations..."
if [ -f "alembic.ini" ]; then
    alembic upgrade head
    echo "✅ Migrations completed successfully"
else
    echo "❌ alembic.ini not found!"
    exit 1
fi

echo "Creating initial admin user..."
python -c "
from app.services.auth_service import create_initial_admin
try:
    create_initial_admin()
    print('✅ Initial admin user created')
except Exception as e:
    print(f'ℹ️  Admin user setup: {e}')
" || echo "ℹ️  Admin user may already exist"

echo "🚀 Starting Sentinel application..."
exec uvicorn app.main:app --host 0.0.0.0 --port 8000
</file>

<file path="backend/Dockerfile">
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Set environment variables
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

# Install system dependencies
RUN apt-get update && apt-get install -y \
    postgresql-client \
    curl \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first for better caching
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy alembic configuration
COPY alembic.ini .
COPY alembic ./alembic

# Copy application code
COPY app ./app
COPY init-db.sql .

# Create startup script
COPY docker-entrypoint.sh .
RUN chmod +x docker-entrypoint.sh

# Create non-root user
RUN useradd -m -u 1000 sentinel && \
    chown -R sentinel:sentinel /app && \
    mkdir -p /app/logs && \
    chown -R sentinel:sentinel /app/logs

# Switch to non-root user
USER sentinel

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Run application
ENTRYPOINT ["/app/docker-entrypoint.sh"]
</file>

<file path="backend/init-db.sql">
-- Initial database setup
-- This file is automatically executed when PostgreSQL container starts

-- Create extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";

-- Grant permissions (tables will be created by Alembic migrations)
-- GRANT ALL PRIVILEGES ON DATABASE sentinel_db TO sentinel_user;
</file>

<file path="backend/requirements.txt">
# FastAPI and Server
fastapi==0.109.0
uvicorn[standard]==0.27.0
python-multipart==0.0.6

# Database
sqlalchemy==2.0.25
psycopg2-binary==2.9.9
alembic==1.13.1

# Security - Fixed bcrypt version
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
bcrypt==4.0.1
cryptography==42.0.0

# Validation
pydantic==2.5.3
pydantic-settings==2.1.0
email-validator==2.1.0

# Utilities
python-dotenv==1.0.0
redis==5.0.1

# Rate Limiting
slowapi==0.1.9

# Monitoring
prometheus-client==0.19.0

# Development
pytest==7.4.4
pytest-asyncio==0.23.3
httpx==0.26.0
faker==22.0.0
</file>

<file path="clients/linux_desktop/config.json">
{
  "server_url": "http://localhost:8000",
  "api_key": "your-api-key-here",
  "client_id": "linux-desktop-001",
  "interval": 30,
  "max_retries": 3,
  "retry_delay": 5,
  "log_level": "INFO",
  "offline_storage": {
    "enabled": true,
    "max_queue_size": 1000,
    "auto_flush": true
  },
  "features": {
    "track_active_window": true,
    "track_processes": true,
    "track_system_metrics": true,
    "track_browser_usage": true,
    "track_application_usage": true,
    "deep_monitoring": true
  },
  "browser_tracking": {
    "firefox": true,
    "chrome": true,
    "chromium": true,
    "max_history_items": 20
  }
}
</file>

<file path="clients/linux_desktop/monitor.py">
#!/usr/bin/env python3
"""
Enhanced Sentinel Linux Desktop Client
Deep monitoring for browser usage, applications, and system activities
"""

import time
import argparse
import platform
import psutil
import requests
import json
import os
import subprocess
import sys
import re
from datetime import datetime, timezone
from typing import Optional, List, Dict, Any
import sqlite3
import configparser

# Add shared directory to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'shared'))
from base_client import BaseMonitorClient
from config_manager import ConfigManager
from utils import setup_logging, get_system_info

class LinuxDesktopClient(BaseMonitorClient):
    def __init__(self, config_path: str):
        super().__init__(config_path, "linux_desktop")
        self.logger = setup_logging("linux_desktop")
        self.last_window = None
        self.window_start_time = None
        self.application_usage = {}
        
    def get_active_window(self) -> Optional[str]:
        """Get active window with detailed information"""
        try:
            # Try xdotool first for window title
            result = subprocess.run(
                ['xdotool', 'getactivewindow', 'getwindowname'],
                capture_output=True, text=True, timeout=2
            )
            if result.returncode == 0:
                window_name = result.stdout.strip()
                
                # Get window class for better categorization
                try:
                    class_result = subprocess.run(
                        ['xdotool', 'getactivewindow', 'getwindowclassname'],
                        capture_output=True, text=True, timeout=1
                    )
                    window_class = class_result.stdout.strip() if class_result.returncode == 0 else "Unknown"
                except:
                    window_class = "Unknown"
                
                # Track window usage time
                current_time = time.time()
                if self.last_window != window_name:
                    if self.last_window and self.window_start_time:
                        duration = current_time - self.window_start_time
                        self._track_application_usage(self.last_window, duration)
                    
                    self.last_window = window_name
                    self.window_start_time = current_time
                
                return {
                    "title": window_name,
                    "class": window_class,
                    "focused": True
                }
        except Exception as e:
            self.logger.debug(f"Error getting active window: {e}")
        
        return None
    
    def _track_application_usage(self, window_title: str, duration: float):
        """Track application usage time"""
        app_name = self._extract_application_name(window_title)
        if app_name not in self.application_usage:
            self.application_usage[app_name] = 0
        self.application_usage[app_name] += duration
    
    def _extract_application_name(self, window_title: str) -> str:
        """Extract application name from window title"""
        # Common patterns for application names
        patterns = {
            'firefox': r'Firefox|Mozilla Firefox',
            'chrome': r'Google Chrome|Chromium',
            'code': r'Visual Studio Code|VSCode',
            'terminal': r'Terminal|GNOME Terminal|Konsole',
            'files': r'Files|Nautilus|Dolphin',
            'libreoffice': r'LibreOffice|Writer|Calc|Impress'
        }
        
        for app, pattern in patterns.items():
            if re.search(pattern, window_title, re.IGNORECASE):
                return app
        
        return "Unknown"
    
    def get_browser_usage(self) -> Dict[str, Any]:
        """Get detailed browser usage information"""
        browser_data = {}
        
        # Firefox tracking
        firefox_data = self._get_firefox_usage()
        if firefox_data:
            browser_data['firefox'] = firefox_data
        
        # Chrome/Chromium tracking
        chrome_data = self._get_chrome_usage()
        if chrome_data:
            browser_data['chrome'] = chrome_data
        
        return browser_data
    
    def _get_firefox_usage(self) -> Optional[Dict[str, Any]]:
        """Get Firefox browser usage data"""
        try:
            # Try to find Firefox profile
            home_dir = os.path.expanduser("~")
            firefox_dir = os.path.join(home_dir, '.mozilla', 'firefox')
            
            if os.path.exists(firefox_dir):
                profiles = []
                for item in os.listdir(firefox_dir):
                    if item.endswith('.default-release'):
                        profile_path = os.path.join(firefox_dir, item)
                        places_db = os.path.join(profile_path, 'places.sqlite')
                        
                        if os.path.exists(places_db):
                            # Get recent history (simplified - in production, handle DB carefully)
                            conn = sqlite3.connect(places_db)
                            cursor = conn.cursor()
                            
                            try:
                                cursor.execute("""
                                    SELECT url, title, visit_count, last_visit_date 
                                    FROM moz_places 
                                    ORDER BY last_visit_date DESC 
                                    LIMIT 20
                                """)
                                history = cursor.fetchall()
                                
                                profiles.append({
                                    'profile': item,
                                    'recent_history': [
                                        {
                                            'url': row[0],
                                            'title': row[1],
                                            'visit_count': row[2],
                                            'last_visit': row[3]
                                        } for row in history
                                    ]
                                })
                            except Exception as e:
                                self.logger.debug(f"Error reading Firefox history: {e}")
                            finally:
                                conn.close()
                
                return {
                    'profiles': profiles,
                    'tabs_count': self._get_firefox_tab_count()
                }
        except Exception as e:
            self.logger.debug(f"Error getting Firefox usage: {e}")
        
        return None
    
    def _get_firefox_tab_count(self) -> int:
        """Estimate Firefox tab count"""
        try:
            result = subprocess.run(
                ['pgrep', '-c', 'firefox'],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                return int(result.stdout.strip())
        except:
            pass
        return 0
    
    def _get_chrome_usage(self) -> Optional[Dict[str, Any]]:
        """Get Chrome/Chromium usage data"""
        try:
            home_dir = os.path.expanduser("~")
            chrome_dir = os.path.join(home_dir, '.config', 'google-chrome')
            chromium_dir = os.path.join(home_dir, '.config', 'chromium')
            
            browser_dirs = []
            if os.path.exists(chrome_dir):
                browser_dirs.append(('chrome', chrome_dir))
            if os.path.exists(chromium_dir):
                browser_dirs.append(('chromium', chromium_dir))
            
            browser_data = {}
            for browser_name, browser_dir in browser_dirs:
                profiles = []
                for item in os.listdir(browser_dir):
                    if item.startswith('Profile') or item == 'Default':
                        profile_path = os.path.join(browser_dir, item)
                        history_db = os.path.join(profile_path, 'History')
                        
                        if os.path.exists(history_db):
                            # Copy the database to avoid locking issues
                            import tempfile
                            import shutil
                            
                            with tempfile.NamedTemporaryFile(delete=False) as temp_db:
                                shutil.copy2(history_db, temp_db.name)
                                
                                try:
                                    conn = sqlite3.connect(temp_db.name)
                                    cursor = conn.cursor()
                                    
                                    cursor.execute("""
                                        SELECT url, title, visit_count, last_visit_time 
                                        FROM urls 
                                        ORDER BY last_visit_time DESC 
                                        LIMIT 20
                                    """)
                                    history = cursor.fetchall()
                                    
                                    profiles.append({
                                        'profile': item,
                                        'recent_history': [
                                            {
                                                'url': row[0],
                                                'title': row[1],
                                                'visit_count': row[2],
                                                'last_visit': row[3]
                                            } for row in history
                                        ]
                                    })
                                except Exception as e:
                                    self.logger.debug(f"Error reading {browser_name} history: {e}")
                                finally:
                                    conn.close()
                                os.unlink(temp_db.name)
                
                if profiles:
                    browser_data[browser_name] = {
                        'profiles': profiles,
                        'tabs_count': self._get_chrome_tab_count(browser_name)
                    }
            
            return browser_data
        except Exception as e:
            self.logger.debug(f"Error getting Chrome usage: {e}")
        
        return None
    
    def _get_chrome_tab_count(self, browser: str) -> int:
        """Estimate Chrome tab count"""
        try:
            result = subprocess.run(
                ['pgrep', '-c', browser],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                return int(result.stdout.strip())
        except:
            pass
        return 0
    
    def get_process_list(self) -> List[Dict[str, Any]]:
        """Get detailed process information"""
        desktop_keywords = [
            'firefox', 'chrome', 'chromium', 'nautilus', 'gedit', 'libreoffice',
            'thunderbird', 'slack', 'discord', 'telegram', 'code', 'sublime',
            'terminal', 'gnome-terminal', 'konsole', 'xfce4-terminal', 'evolution',
            'outlook', 'skype', 'teams', 'zoom', 'signal', 'whatsapp', 'spotify',
            'steam', 'gimp', 'inkscape', 'blender', 'vlc', 'mpv'
        ]
        
        processes = []
        try:
            for proc in psutil.process_iter(['pid', 'name', 'username', 'memory_info', 'cpu_percent', 'create_time', 'cmdline']):
                try:
                    # Filter for user processes (not system daemons)
                    if proc.info['username'] != 'root' and proc.info['pid'] > 1000:
                        proc_name = proc.info['name'].lower()
                        is_desktop_app = any(keyword in proc_name for keyword in desktop_keywords)
                        
                        if is_desktop_app:
                            process_info = {
                                "pid": proc.info['pid'],
                                "name": proc.info['name'],
                                "user": proc.info['username'],
                                "memory_rss_mb": round(proc.info['memory_info'].rss / (1024*1024), 1) if proc.info['memory_info'] else 0,
                                "cpu_percent": round(proc.info['cpu_percent'] or 0, 1),
                                "create_time": datetime.fromtimestamp(proc.info['create_time']).isoformat() if proc.info['create_time'] else None,
                                "cmdline": ' '.join(proc.info['cmdline'] or [])[:200] if proc.info['cmdline'] else '',
                                "is_desktop": True
                            }
                            processes.append(process_info)
                except (psutil.NoSuchProcess, psutil.AccessDenied, KeyError) as e:
                    self.logger.debug(f"Error accessing process: {e}")
                    continue
            
            # Limit to prevent huge payloads
            processes = processes[:50]
            self.logger.debug(f"Collected {len(processes)} desktop processes")
            return processes
        except Exception as e:
            self.logger.error(f"Error getting process list: {e}")
            return []
    
    def get_system_metrics(self) -> Dict[str, Any]:
        """Get comprehensive system metrics"""
        try:
            # CPU metrics
            cpu_percent = psutil.cpu_percent(interval=1)
            cpu_per_core = psutil.cpu_percent(interval=1, percpu=True)
            cpu_freq = psutil.cpu_freq()
            
            # Memory metrics
            memory = psutil.virtual_memory()
            swap = psutil.swap_memory()
            
            # Disk metrics
            disk_usage = psutil.disk_usage('/home') if os.path.exists('/home') else psutil.disk_usage('/')
            disk_io = psutil.disk_io_counters()
            
            # Network metrics
            net_io = psutil.net_io_counters()
            net_connections = len(psutil.net_connections())
            
            # Battery info
            battery_info = None
            try:
                battery = psutil.sensors_battery()
                if battery:
                    battery_info = {
                        "percent": round(battery.percent, 1),
                        "power_plugged": battery.power_plugged,
                        "time_left": battery.secsleft if battery.secsleft != psutil.POWER_TIME_UNLIMITED else None
                    }
            except Exception as e:
                self.logger.debug(f"Could not get battery info: {e}")
            
            # Temperature sensors
            temp_info = {}
            try:
                temperatures = psutil.sensors_temperatures()
                for name, entries in temperatures.items():
                    if entries:
                        temp_info[name] = {
                            'current': entries[0].current,
                            'high': entries[0].high,
                            'critical': entries[0].critical
                        }
            except Exception as e:
                self.logger.debug(f"Could not get temperature info: {e}")
            
            metrics = {
                "desktop_environment": os.environ.get('XDG_CURRENT_DESKTOP', 'Unknown'),
                "session_type": os.environ.get('XDG_SESSION_TYPE', 'Unknown'),
                
                "cpu": {
                    "percent": round(cpu_percent, 1),
                    "per_core": [round(p, 1) for p in cpu_per_core],
                    "frequency_mhz": round(cpu_freq.current, 1) if cpu_freq else None,
                    "cores": psutil.cpu_count(),
                    "load_average": os.getloadavg()
                },
                
                "memory": {
                    "total_gb": round(memory.total / (1024**3), 1),
                    "used_gb": round(memory.used / (1024**3), 1),
                    "available_gb": round(memory.available / (1024**3), 1),
                    "percent": round(memory.percent, 1),
                    "swap_used_gb": round(swap.used / (1024**3), 1),
                    "swap_percent": round(swap.percent, 1) if swap.total > 0 else 0
                },
                
                "disk": {
                    "total_gb": round(disk_usage.total / (1024**3), 1),
                    "used_gb": round(disk_usage.used / (1024**3), 1),
                    "free_gb": round(disk_usage.free / (1024**3), 1),
                    "percent": round(disk_usage.percent, 1),
                    "read_mb": round(disk_io.read_bytes / (1024**2), 1) if disk_io else 0,
                    "write_mb": round(disk_io.write_bytes / (1024**2), 1) if disk_io else 0
                },
                
                "network": {
                    "bytes_sent_mb": round(net_io.bytes_sent / (1024**2), 1),
                    "bytes_recv_mb": round(net_io.bytes_recv / (1024**2), 1),
                    "packets_sent": net_io.packets_sent,
                    "packets_recv": net_io.packets_recv,
                    "active_connections": net_connections
                },
                
                "battery": battery_info,
                "temperatures": temp_info,
                "users": len([u for u in psutil.users() if u.terminal]),
                "uptime_seconds": time.time() - psutil.boot_time()
            }
            
            self.logger.debug("Collected comprehensive system metrics")
            return metrics
        except Exception as e:
            self.logger.error(f"Error getting system metrics: {e}")
            return {}
    
    def get_additional_data(self) -> Dict[str, Any]:
        """Get additional desktop-specific data"""
        return {
            "browser_usage": self.get_browser_usage(),
            "application_usage": self.application_usage,
            "logged_in_users": self._get_logged_in_users(),
            "desktop_notifications": self._get_desktop_notifications(),
            "system_updates": self._get_system_updates_info()
        }
    
    def _get_logged_in_users(self) -> List[Dict[str, Any]]:
        """Get information about logged-in users"""
        users = []
        try:
            for user in psutil.users():
                users.append({
                    "name": user.name,
                    "terminal": user.terminal,
                    "host": user.host,
                    "started": datetime.fromtimestamp(user.started).isoformat()
                })
        except Exception as e:
            self.logger.debug(f"Error getting user info: {e}")
        
        return users
    
    def _get_desktop_notifications(self) -> Dict[str, Any]:
        """Get desktop notification status"""
        # This is a placeholder - actual implementation would depend on the desktop environment
        try:
            # Check if notification daemon is running
            result = subprocess.run(
                ['pgrep', '-f', 'notification'],
                capture_output=True, text=True
            )
            return {
                "daemon_running": result.returncode == 0,
                "daemon_name": "Unknown"  # Could be determined by checking process name
            }
        except:
            return {"daemon_running": False}
    
    def _get_system_updates_info(self) -> Dict[str, Any]:
        """Get system updates information"""
        update_info = {}
        
        # Check for Ubuntu/Debian updates
        try:
            result = subprocess.run(
                ['apt-get', 'update'],
                capture_output=True, text=True,
                timeout=30
            )
            if result.returncode == 0:
                upgrade_result = subprocess.run(
                    ['apt-get', 'upgrade', '--dry-run'],
                    capture_output=True, text=True
                )
                if upgrade_result.returncode == 0:
                    # Parse output to count updates
                    lines = upgrade_result.stdout.split('\n')
                    update_count = 0
                    for line in lines:
                        if 'upgraded,' in line:
                            parts = line.split()
                            for i, part in enumerate(parts):
                                if part == 'upgraded,':
                                    update_count = int(parts[i-1])
                                    break
                    
                    update_info['apt'] = {
                        "updates_available": update_count,
                        "last_checked": datetime.now().isoformat()
                    }
        except Exception as e:
            self.logger.debug(f"Error checking system updates: {e}")
        
        return update_info
    
    def get_platform_info(self) -> Dict[str, Any]:
        """Get platform-specific information"""
        platform_info = get_system_info()
        platform_info.update({
            "client_type": "linux_desktop",
            "desktop_environment": os.environ.get('XDG_CURRENT_DESKTOP', 'Unknown'),
            "session_type": os.environ.get('XDG_SESSION_TYPE', 'Unknown'),
            "display_manager": self._get_display_manager(),
            "window_manager": self._get_window_manager()
        })
        return platform_info
    
    def _get_display_manager(self) -> str:
        """Get display manager information"""
        try:
            result = subprocess.run(
                ['systemctl', 'status', 'display-manager'],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'Loaded:' in line:
                        return line.split('Loaded:')[1].split(';')[0].strip()
        except:
            pass
        return "Unknown"
    
    def _get_window_manager(self) -> str:
        """Get window manager information"""
        try:
            # Try different methods to detect window manager
            if 'GNOME' in os.environ.get('XDG_CURRENT_DESKTOP', ''):
                return "GNOME Shell"
            elif 'KDE' in os.environ.get('XDG_CURRENT_DESKTOP', ''):
                return "KDE Plasma"
            elif 'XFCE' in os.environ.get('XDG_CURRENT_DESKTOP', ''):
                return "XFCE"
            
            # Fallback to checking process
            wm_processes = ['gnome-shell', 'kwin_x11', 'kwin_wayland', 'xfwm4', 'mutter', 'compiz']
            for wm in wm_processes:
                result = subprocess.run(['pgrep', wm], capture_output=True)
                if result.returncode == 0:
                    return wm
        except:
            pass
        
        return "Unknown"

def main():
    parser = argparse.ArgumentParser(description="Enhanced Sentinel Linux Desktop Client")
    parser.add_argument(
        "--config", 
        default="config.json",
        help="Path to configuration file (default: config.json)"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Enable verbose logging"
    )
    
    args = parser.parse_args()
    
    try:
        client = LinuxDesktopClient(args.config)
        if args.verbose:
            client.logger.setLevel("DEBUG")
        client.run()
    except KeyboardInterrupt:
        print("\nStopping Enhanced Linux Desktop Client...")
    except Exception as e:
        print(f"Failed to start client: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
</file>

<file path="clients/linux_desktop/requirements.txt">
psutil==5.9.5
requests==2.31.0
python-dotenv==1.0.0
pyxdg==0.28
# System dependencies (install via package manager):
# xdotool, wmctrl, postgresql-client (for pg_isready)
</file>

<file path="clients/linux_server/config.json">
{
  "server_url": "http://localhost:8000",
  "api_key": "your-api-key-here",
  "client_id": "linux-desktop-001",
  "interval": 30,
  "max_retries": 3,
  "retry_delay": 5,
  "log_level": "INFO",
  "offline_storage": {
    "enabled": true,
    "max_queue_size": 1000,
    "auto_flush": true
  },
  "features": {
    "track_active_window": true,
    "track_processes": true,
    "track_system_metrics": true,
    "track_browser_usage": true,
    "track_application_usage": true,
    "deep_monitoring": true
  },
  "browser_tracking": {
    "firefox": true,
    "chrome": true,
    "chromium": true,
    "max_history_items": 20
  }
}
</file>

<file path="clients/linux_server/monitor.py">
#!/usr/bin/env python3
"""
Enhanced Sentinel Linux Server Client
Comprehensive system analytics, process monitoring, and log categorization
"""

import time
import argparse
import platform
import psutil
import requests
import json
import os
import subprocess
import sys
import re
import glob
from datetime import datetime, timezone
from typing import Optional, List, Dict, Any
import gzip
import bz2

# Add shared directory to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'shared'))
from base_client import BaseMonitorClient
from config_manager import ConfigManager
from utils import setup_logging, get_system_info

class LinuxServerClient(BaseMonitorClient):
    def __init__(self, config_path: str):
        super().__init__(config_path, "linux_server")
        self.logger = setup_logging("linux_server")
        self.log_patterns = self._initialize_log_patterns()
        
    def _initialize_log_patterns(self) -> Dict[str, List[str]]:
        """Initialize log patterns for categorization"""
        return {
            "authentication": [
                r"authentication failure",
                r"failed password",
                r"invalid user",
                r"authentication succeeded",
                r"accepted password",
                r"session opened",
                r"session closed"
            ],
            "system_errors": [
                r"error:",
                r"failed",
                r"critical",
                r"panic",
                r"oom",
                r"out of memory",
                r"kernel:.*error",
                r"segfault",
                r"exception"
            ],
            "security": [
                r"firewall",
                r"iptables",
                r"ufw",
                r"intrusion",
                r"attack",
                r"brute force",
                r"port scan",
                r"malware",
                r"virus"
            ],
            "network": [
                r"network",
                r"connection",
                r"port",
                r"tcp",
                r"udp",
                r"dns",
                r"dhcp",
                r"interface",
                r"ethernet"
            ],
            "application": [
                r"apache",
                r"nginx",
                r"mysql",
                r"postgres",
                r"docker",
                r"kube",
                r"php",
                r"python",
                r"node"
            ]
        }
    
    def get_active_window(self) -> Optional[str]:
        """No active window on server"""
        return None
    
    def get_process_list(self) -> List[Dict[str, Any]]:
        """Get comprehensive process information"""
        processes = []
        try:
            for proc in psutil.process_iter(['pid', 'name', 'username', 'memory_info', 'cpu_percent', 'create_time', 'cmdline', 'status']):
                try:
                    process_info = {
                        "pid": proc.info['pid'],
                        "name": proc.info['name'],
                        "user": proc.info['username'],
                        "memory_rss_mb": round(proc.info['memory_info'].rss / (1024*1024), 1) if proc.info['memory_info'] else 0,
                        "memory_vms_mb": round(proc.info['memory_info'].vms / (1024*1024), 1) if proc.info['memory_info'] else 0,
                        "cpu_percent": round(proc.info['cpu_percent'] or 0, 1),
                        "status": proc.info['status'],
                        "create_time": datetime.fromtimestamp(proc.info['create_time']).isoformat() if proc.info['create_time'] else None,
                        "cmdline": ' '.join(proc.info['cmdline'] or [])[:500] if proc.info['cmdline'] else '',
                        "threads": proc.num_threads(),
                        "open_files": len(proc.open_files()) if hasattr(proc, 'open_files') else 0
                    }
                    
                    # Add process categorization
                    process_info['category'] = self._categorize_process(proc.info['name'], process_info['cmdline'])
                    
                    processes.append(process_info)
                except (psutil.NoSuchProcess, psutil.AccessDenied, KeyError) as e:
                    self.logger.debug(f"Error accessing process: {e}")
                    continue
            
            # Limit number of processes to prevent huge payloads
            processes = processes[:100]
            self.logger.debug(f"Collected {len(processes)} server processes")
            return processes
        except Exception as e:
            self.logger.error(f"Error getting process list: {e}")
            return []
    
    def _categorize_process(self, name: str, cmdline: str) -> str:
        """Categorize process based on name and command line"""
        categories = {
            'system': ['systemd', 'init', 'kthreadd', 'rcu_sched', 'migration'],
            'network': ['sshd', 'nginx', 'apache', 'httpd', 'postfix', 'dovecot', 'bind', 'named'],
            'database': ['mysql', 'mariadb', 'postgres', 'mongod', 'redis'],
            'web': ['nginx', 'apache', 'httpd', 'php', 'node', 'python'],
            'container': ['docker', 'containerd', 'dockerd', 'kubelet', 'k3s'],
            'monitoring': ['prometheus', 'grafana', 'zabbix', 'nagios'],
            'storage': ['lvm', 'mdadm', 'ceph', 'gluster']
        }
        
        name_lower = name.lower()
        cmdline_lower = cmdline.lower()
        
        for category, keywords in categories.items():
            if any(keyword in name_lower for keyword in keywords):
                return category
            if any(keyword in cmdline_lower for keyword in keywords):
                return category
        
        return 'application'
    
    def get_system_logs(self) -> Dict[str, List[Dict[str, Any]]]:
        """Collect and categorize system logs"""
        log_files = [
            '/var/log/syslog',
            '/var/log/messages',
            '/var/log/auth.log',
            '/var/log/secure',
            '/var/log/kern.log',
            '/var/log/dmesg'
        ]
        
        categorized_logs = {category: [] for category in self.log_patterns.keys()}
        categorized_logs['other'] = []
        
        for log_file in log_files:
            if not os.path.exists(log_file):
                continue
            
            try:
                logs = self._read_log_file(log_file, max_lines=50)
                for log_entry in logs:
                    category = self._categorize_log_entry(log_entry)
                    if len(categorized_logs[category]) < 20:  # Limit per category
                        categorized_logs[category].append({
                            'file': os.path.basename(log_file),
                            'entry': log_entry,
                            'timestamp': datetime.now().isoformat()
                        })
            except Exception as e:
                self.logger.debug(f"Error reading log file {log_file}: {e}")
        
        return categorized_logs
    
    def _read_log_file(self, file_path: str, max_lines: int = 100) -> List[str]:
        """Read log file, handling compressed files"""
        lines = []
        
        try:
            if file_path.endswith('.gz'):
                with gzip.open(file_path, 'rt', encoding='utf-8', errors='ignore') as f:
                    lines = f.readlines()[-max_lines:]
            elif file_path.endswith('.bz2'):
                with bz2.open(file_path, 'rt', encoding='utf-8', errors='ignore') as f:
                    lines = f.readlines()[-max_lines:]
            else:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    lines = f.readlines()[-max_lines:]
        except Exception as e:
            self.logger.debug(f"Error reading {file_path}: {e}")
        
        return [line.strip() for line in lines if line.strip()]
    
    def _categorize_log_entry(self, log_entry: str) -> str:
        """Categorize log entry based on patterns"""
        for category, patterns in self.log_patterns.items():
            for pattern in patterns:
                if re.search(pattern, log_entry, re.IGNORECASE):
                    return category
        return 'other'
    
    def get_container_info(self) -> List[Dict[str, Any]]:
        """Get comprehensive Docker container information"""
        containers = []
        try:
            # Get container list
            result = subprocess.run(
                ['docker', 'ps', '--format', '{{.Names}}|{{.Image}}|{{.Status}}|{{.Ports}}|{{.ID}}'],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0:
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        try:
                            name, image, status, ports, container_id = line.split('|', 4)
                            
                            # Get detailed container info
                            stats = self._get_container_stats(container_id)
                            
                            container_info = {
                                "name": name,
                                "image": image,
                                "status": status,
                                "ports": ports,
                                "id": container_id[:12],
                                "stats": stats
                            }
                            containers.append(container_info)
                        except ValueError:
                            continue
            
            self.logger.debug(f"Found {len(containers)} Docker containers")
        except (subprocess.TimeoutExpired, FileNotFoundError, subprocess.SubprocessError) as e:
            self.logger.debug(f"Docker not available or command failed: {e}")
        
        return containers
    
    def _get_container_stats(self, container_id: str) -> Dict[str, Any]:
        """Get container resource usage statistics"""
        try:
            result = subprocess.run(
                ['docker', 'stats', container_id, '--no-stream', '--format', '{{.CPUPerc}}|{{.MemUsage}}|{{.NetIO}}|{{.BlockIO}}'],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                cpu, memory, network, block_io = result.stdout.strip().split('|')
                return {
                    "cpu_percent": cpu.strip(),
                    "memory_usage": memory.strip(),
                    "network_io": network.strip(),
                    "block_io": block_io.strip()
                }
        except:
            pass
        
        return {}
    
    def get_service_status(self) -> Dict[str, Dict[str, Any]]:
        """Get comprehensive service status"""
        services = {}
        common_services = [
            'nginx', 'apache2', 'httpd', 'mysql', 'mariadb', 'postgresql', 
            'docker', 'ssh', 'sshd', 'redis', 'mongod', 'php-fpm', 'node'
        ]
        
        for service in common_services:
            try:
                # Check service status
                result = subprocess.run(
                    ['systemctl', 'is-active', service],
                    capture_output=True, text=True, timeout=2
                )
                status = result.stdout.strip()
                
                # Get service details
                if status != 'unknown':
                    # Get memory usage of service
                    memory_usage = self._get_service_memory_usage(service)
                    
                    services[service] = {
                        "status": status,
                        "memory_usage_mb": memory_usage,
                        "enabled": self._is_service_enabled(service)
                    }
            except (subprocess.TimeoutExpired, FileNotFoundError, subprocess.SubprocessError):
                services[service] = {"status": "unknown"}
        
        self.logger.debug(f"Checked status of {len(services)} services")
        return services
    
    def _get_service_memory_usage(self, service: str) -> float:
        """Get memory usage of service processes"""
        try:
            result = subprocess.run(
                ['pgrep', '-f', service],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                pids = result.stdout.strip().split('\n')
                total_memory = 0
                for pid in pids:
                    if pid.strip():
                        try:
                            proc = psutil.Process(int(pid.strip()))
                            total_memory += proc.memory_info().rss
                        except:
                            continue
                return round(total_memory / (1024*1024), 1)
        except:
            pass
        return 0.0
    
    def _is_service_enabled(self, service: str) -> bool:
        """Check if service is enabled to start on boot"""
        try:
            result = subprocess.run(
                ['systemctl', 'is-enabled', service],
                capture_output=True, text=True, timeout=2
            )
            return result.stdout.strip() == 'enabled'
        except:
            return False
    
    def get_system_metrics(self) -> Dict[str, Any]:
        """Get comprehensive server metrics"""
        try:
            # System load
            load_avg = os.getloadavg()
            
            # CPU metrics
            cpu_percent = psutil.cpu_percent(interval=1)
            cpu_count = psutil.cpu_count()
            cpu_per_core = psutil.cpu_percent(interval=1, percpu=True)
            cpu_freq = psutil.cpu_freq()
            
            # Memory metrics
            memory = psutil.virtual_memory()
            swap = psutil.swap_memory()
            
            # Disk metrics - multiple partitions
            disk_info = {}
            for partition in psutil.disk_partitions():
                try:
                    usage = psutil.disk_usage(partition.mountpoint)
                    disk_io = psutil.disk_io_counters(perdisk=True).get(partition.device.replace('/dev/', ''), {})
                    
                    disk_info[partition.mountpoint] = {
                        "device": partition.device,
                        "fstype": partition.fstype,
                        "total_gb": round(usage.total / (1024**3), 1),
                        "used_gb": round(usage.used / (1024**3), 1),
                        "free_gb": round(usage.free / (1024**3), 1),
                        "percent": round(usage.percent, 1),
                        "read_mb": round(disk_io.read_bytes / (1024**2), 1) if disk_io else 0,
                        "write_mb": round(disk_io.write_bytes / (1024**2), 1) if disk_io else 0
                    }
                except Exception:
                    continue
            
            # Network metrics
            net_io = psutil.net_io_counters()
            net_connections = psutil.net_connections()
            
            # Temperature sensors
            temp_info = {}
            try:
                temperatures = psutil.sensors_temperatures()
                for name, entries in temperatures.items():
                    if entries:
                        temp_info[name] = {
                            'current': entries[0].current,
                            'high': entries[0].high,
                            'critical': entries[0].critical
                        }
            except Exception as e:
                self.logger.debug(f"Could not get temperature info: {e}")
            
            # Uptime
            uptime = time.time() - psutil.boot_time()
            
            metrics = {
                "load_average": {
                    "1min": round(load_avg[0], 2),
                    "5min": round(load_avg[1], 2),
                    "15min": round(load_avg[2], 2)
                },
                "cpu": {
                    "percent": round(cpu_percent, 1),
                    "cores": cpu_count,
                    "load_per_core": [round(p, 1) for p in cpu_per_core],
                    "frequency_mhz": round(cpu_freq.current, 1) if cpu_freq else None
                },
                "memory": {
                    "total_gb": round(memory.total / (1024**3), 1),
                    "used_gb": round(memory.used / (1024**3), 1),
                    "available_gb": round(memory.available / (1024**3), 1),
                    "percent": round(memory.percent, 1),
                    "swap_used_gb": round(swap.used / (1024**3), 1),
                    "swap_total_gb": round(swap.total / (1024**3), 1),
                    "swap_percent": round(swap.percent, 1) if swap.total > 0 else 0
                },
                "disks": disk_info,
                "network": {
                    "bytes_sent_mb": round(net_io.bytes_sent / (1024**2), 1),
                    "bytes_recv_mb": round(net_io.bytes_recv / (1024**2), 1),
                    "packets_sent": net_io.packets_sent,
                    "packets_recv": net_io.packets_recv,
                    "active_connections": len(net_connections),
                    "tcp_connections": len([c for c in net_connections if c.type == 1]),
                    "udp_connections": len([c for c in net_connections if c.type == 2])
                },
                "temperatures": temp_info,
                "system": {
                    "uptime_days": round(uptime / (24 * 3600), 1),
                    "uptime_seconds": uptime,
                    "boot_time": datetime.fromtimestamp(psutil.boot_time()).isoformat(),
                    "users": len(psutil.users())
                }
            }
            
            self.logger.debug("Collected comprehensive system metrics")
            return metrics
        except Exception as e:
            self.logger.error(f"Error getting system metrics: {e}")
            return {}
    
    def get_additional_data(self) -> Dict[str, Any]:
        """Get additional server-specific data"""
        return {
            "services": self.get_service_status(),
            "containers": self.get_container_info(),
            "system_logs": self.get_system_logs(),
            "security_scan": self._perform_security_scan(),
            "package_updates": self._check_package_updates()
        }
    
    def _perform_security_scan(self) -> Dict[str, Any]:
        """Perform basic security checks"""
        security_checks = {}
        
        # Check for failed login attempts
        try:
            result = subprocess.run(
                ['grep', 'Failed password', '/var/log/auth.log'],
                capture_output=True, text=True
            )
            failed_logins = len(result.stdout.strip().split('\n')) if result.stdout.strip() else 0
            security_checks['failed_logins'] = failed_logins
        except:
            security_checks['failed_logins'] = 0
        
        # Check SSH configuration
        try:
            result = subprocess.run(
                ['grep', '^PermitRootLogin', '/etc/ssh/sshd_config'],
                capture_output=True, text=True
            )
            security_checks['root_ssh'] = 'yes' in result.stdout.lower() if result.stdout else False
        except:
            security_checks['root_ssh'] = False
        
        # Check firewall status
        try:
            result = subprocess.run(['ufw', 'status'], capture_output=True, text=True)
            security_checks['firewall_active'] = 'active' in result.stdout.lower()
        except:
            security_checks['firewall_active'] = False
        
        return security_checks
    
    def _check_package_updates(self) -> Dict[str, Any]:
        """Check for available package updates"""
        update_info = {}
        
        # Ubuntu/Debian
        try:
            subprocess.run(['apt-get', 'update'], capture_output=True, timeout=30)
            result = subprocess.run(
                ['apt-get', 'upgrade', '--dry-run'],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                security_updates = 0
                regular_updates = 0
                
                for line in result.stdout.split('\n'):
                    if 'upgraded,' in line:
                        parts = line.split()
                        for i, part in enumerate(parts):
                            if part == 'upgraded,':
                                regular_updates = int(parts[i-1])
                                break
                    elif 'security' in line.lower():
                        security_updates += 1
                
                update_info['apt'] = {
                    "security_updates": security_updates,
                    "regular_updates": regular_updates,
                    "last_checked": datetime.now().isoformat()
                }
        except Exception as e:
            self.logger.debug(f"Error checking APT updates: {e}")
        
        return update_info
    
    def get_platform_info(self) -> Dict[str, Any]:
        """Get platform-specific information"""
        platform_info = get_system_info()
        platform_info.update({
            "client_type": "linux_server",
            "kernel_version": platform.release(),
            "virtualization": self._get_virtualization_info(),
            "hardware": self._get_hardware_info()
        })
        return platform_info
    
    def _get_virtualization_info(self) -> Dict[str, Any]:
        """Get virtualization information"""
        try:
            result = subprocess.run(
                ['systemd-detect-virt'],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                return {
                    "type": result.stdout.strip(),
                    "detected": True
                }
        except:
            pass
        
        return {"type": "bare metal", "detected": False}
    
    def _get_hardware_info(self) -> Dict[str, Any]:
        """Get hardware information"""
        hardware_info = {}
        
        # CPU info
        try:
            with open('/proc/cpuinfo', 'r') as f:
                cpu_info = f.read()
                model_match = re.search(r'model name\s*:\s*(.+)', cpu_info)
                if model_match:
                    hardware_info['cpu_model'] = model_match.group(1).strip()
        except:
            pass
        
        # Memory info
        try:
            with open('/proc/meminfo', 'r') as f:
                mem_info = f.read()
                total_match = re.search(r'MemTotal:\s*(\d+)', mem_info)
                if total_match:
                    hardware_info['memory_total_kb'] = int(total_match.group(1))
        except:
            pass
        
        return hardware_info

def main():
    parser = argparse.ArgumentParser(description="Enhanced Sentinel Linux Server Client")
    parser.add_argument(
        "--config", 
        default="config.json",
        help="Path to configuration file (default: config.json)"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Enable verbose logging"
    )
    
    args = parser.parse_args()
    
    try:
        client = LinuxServerClient(args.config)
        if args.verbose:
            client.logger.setLevel("DEBUG")
        client.run()
    except KeyboardInterrupt:
        print("\nStopping Enhanced Linux Server Client...")
    except Exception as e:
        print(f"Failed to start client: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
</file>

<file path="clients/linux_server/requirements.txt">
psutil==5.9.5
requests==2.31.0
python-dotenv==1.0.0
docker==6.1.3
# System dependencies (install via package manager):
# docker-cli, postgresql-client
</file>

<file path="clients/shared/__init__.py">
"""
Shared components for Sentinel monitoring clients
"""

from .base_client import BaseMonitorClient
from .config_manager import ConfigManager
from .utils import setup_logging, get_system_info

__all__ = ['BaseMonitorClient', 'ConfigManager', 'setup_logging', 'get_system_info']
</file>

<file path="clients/shared/base_client.py">
"""
Enhanced Base client with offline queue system
"""

import time
import requests
import json
import logging
import socket
import threading
from datetime import datetime, timezone
from typing import Dict, Any, Optional, List
from abc import ABC, abstractmethod
import os
import queue
import pickle

from .config_manager import ConfigManager

class OfflineQueueManager:
    """Manages offline data storage and retransmission"""
    
    def __init__(self, storage_path: str, max_queue_size: int = 1000):
        self.storage_path = storage_path
        self.max_queue_size = max_queue_size
        self.queue_file = os.path.join(storage_path, 'offline_queue.pkl')
        self.lock = threading.Lock()
        
        # Ensure storage directory exists
        os.makedirs(storage_path, exist_ok=True)
        
        # Load existing queue
        self._load_queue()
    
    def _load_queue(self):
        """Load queue from disk"""
        try:
            if os.path.exists(self.queue_file):
                with open(self.queue_file, 'rb') as f:
                    self._queue = pickle.load(f)
            else:
                self._queue = []
        except Exception as e:
            logging.warning(f"Failed to load queue: {e}")
            self._queue = []
    
    def _save_queue(self):
        """Save queue to disk"""
        try:
            with open(self.queue_file, 'wb') as f:
                pickle.dump(self._queue, f)
        except Exception as e:
            logging.error(f"Failed to save queue: {e}")
    
    def add_activity(self, activity_data: Dict[str, Any]):
        """Add activity to offline queue"""
        with self.lock:
            if len(self._queue) >= self.max_queue_size:
                # Remove oldest item if queue is full
                self._queue.pop(0)
            
            self._queue.append({
                'timestamp': datetime.now(timezone.utc).isoformat(),
                'data': activity_data
            })
            self._save_queue()
    
    def get_pending_activities(self) -> List[Dict[str, Any]]:
        """Get all pending activities"""
        with self.lock:
            return self._queue.copy()
    
    def remove_activities(self, count: int):
        """Remove activities from queue after successful send"""
        with self.lock:
            if count > 0:
                self._queue = self._queue[count:]
                self._save_queue()
    
    def clear_queue(self):
        """Clear the entire queue"""
        with self.lock:
            self._queue = []
            self._save_queue()
    
    def get_queue_size(self) -> int:
        """Get current queue size"""
        return len(self._queue)

class BaseMonitorClient(ABC):
    def __init__(self, config_path: str, client_type: str):
        self.config_manager = ConfigManager(config_path)
        self.config = self.config_manager.load_config()
        self.client_type = client_type
        self.client_id = self.config.get('client_id', f"{client_type}-{self._get_hostname()}")
        self.server_url = self.config['server_url']
        self.api_key = self.config['api_key']
        self.interval = self.config.get('interval', 60)
        self.max_retries = self.config.get('max_retries', 3)
        self.retry_delay = self.config.get('retry_delay', 5)
        self.logger = logging.getLogger(client_type)
        
        # Initialize offline queue
        queue_storage = os.path.join(
            os.path.dirname(config_path), 
            'offline_storage'
        )
        self.offline_queue = OfflineQueueManager(queue_storage)
        
        # Connection state
        self.is_online = True
        self.consecutive_failures = 0
        self.max_consecutive_failures = 5
        
    def _get_hostname(self) -> str:
        """Get system hostname"""
        return socket.gethostname().lower().replace(' ', '-')
    
    @abstractmethod
    def get_active_window(self) -> Optional[str]:
        """Get active window - to be implemented by subclasses"""
        pass
    
    @abstractmethod
    def get_process_list(self) -> list:
        """Get process list - to be implemented by subclasses"""
        pass
    
    @abstractmethod
    def get_system_metrics(self) -> Dict[str, Any]:
        """Get system metrics - to be implemented by subclasses"""
        pass
    
    @abstractmethod
    def get_platform_info(self) -> Dict[str, Any]:
        """Get platform information - to be implemented by subclasses"""
        pass
    
    def get_additional_data(self) -> Dict[str, Any]:
        """Get additional data - can be overridden by subclasses"""
        return {}
    
    def collect_activity_data(self) -> Dict[str, Any]:
        """Collect comprehensive activity data"""
        try:
            data = {
                "client_id": self.client_id,
                "client_type": self.client_type,
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "active_window": self.get_active_window(),
                "processes": self.get_process_list(),
                "system_metrics": self.get_system_metrics(),
                "platform": self.get_platform_info(),
                "additional_data": self.get_additional_data()
            }
            
            # Filter out None values
            data = {k: v for k, v in data.items() if v is not None}
            
            self.logger.debug("Collected activity data")
            return data
        except Exception as e:
            self.logger.error(f"Error collecting activity data: {e}")
            return {}
    
    def flush_offline_queue(self) -> bool:
        """Send all pending activities from offline queue"""
        pending_activities = self.offline_queue.get_pending_activities()
        if not pending_activities:
            return True
        
        self.logger.info(f"Flushing {len(pending_activities)} pending activities from offline queue")
        
        successful_sends = 0
        for activity in pending_activities:
            if self._send_single_report(activity['data']):
                successful_sends += 1
            else:
                # Stop on first failure to maintain order
                break
        
        # Remove successfully sent activities
        if successful_sends > 0:
            self.offline_queue.remove_activities(successful_sends)
            self.logger.info(f"Successfully sent {successful_sends} queued activities")
        
        return successful_sends == len(pending_activities)
    
    def _send_single_report(self, data: Dict[str, Any]) -> bool:
        """Send a single activity report"""
        for attempt in range(self.max_retries):
            try:
                headers = {
                    "X-API-Key": self.api_key,
                    "Content-Type": "application/json"
                }
                
                response = requests.post(
                    f"{self.server_url}/api/v1/activities/report",
                    json=data,
                    headers=headers,
                    timeout=30
                )
                
                if response.status_code == 200:
                    return True
                elif response.status_code == 401:
                    self.logger.error("Invalid API key - check your configuration")
                    return False
                else:
                    self.logger.warning(f"Server returned error {response.status_code}: {response.text}")
                    if attempt < self.max_retries - 1:
                        time.sleep(self.retry_delay)
                        continue
                    return False
                    
            except requests.exceptions.ConnectionError:
                self.logger.warning(f"Connection error (attempt {attempt + 1}/{self.max_retries})")
                if attempt < self.max_retries - 1:
                    time.sleep(self.retry_delay)
                    continue
                return False
            except requests.exceptions.Timeout:
                self.logger.warning(f"Request timeout (attempt {attempt + 1}/{self.max_retries})")
                if attempt < self.max_retries - 1:
                    time.sleep(self.retry_delay)
                    continue
                return False
            except requests.exceptions.RequestException as e:
                self.logger.error(f"Request error: {e}")
                return False
            except Exception as e:
                self.logger.error(f"Unexpected error sending report: {e}")
                return False
        
        return False
    
    def send_report(self, data: Dict[str, Any]) -> bool:
        """Send activity report with offline queue support"""
        # First, try to flush any pending activities
        if self.offline_queue.get_queue_size() > 0:
            if self.flush_offline_queue():
                self.is_online = True
                self.consecutive_failures = 0
            else:
                self.is_online = False
                self.consecutive_failures += 1
        
        # Try to send current data
        if self.is_online:
            success = self._send_single_report(data)
            if success:
                self.consecutive_failures = 0
                return True
            else:
                self.consecutive_failures += 1
                self.is_online = False
        
        # If offline or send failed, add to queue
        if not self.is_online:
            self.offline_queue.add_activity(data)
            queue_size = self.offline_queue.get_queue_size()
            self.logger.warning(f"Added activity to offline queue (size: {queue_size})")
            
            # Check if we should try to recover connection
            if self.consecutive_failures >= self.max_consecutive_failures:
                self.logger.info("Attempting connection recovery...")
                time.sleep(self.interval * 2)  # Extended wait
                self.consecutive_failures = 0
        
        return self.is_online
    
    def run(self):
        """Main monitoring loop with offline support"""
        self.logger.info(f"Starting {self.client_type} Sentinel Client (ID: {self.client_id})")
        self.logger.info(f"Reporting to: {self.server_url}")
        self.logger.info(f"Interval: {self.interval} seconds")
        self.logger.info(f"Offline queue: {self.offline_queue.get_queue_size()} pending activities")
        self.logger.info("Press Ctrl+C to stop...")
        
        try:
            while True:
                try:
                    data = self.collect_activity_data()
                    if data:
                        success = self.send_report(data)
                        
                        if success:
                            self.logger.info(f"Report sent at {datetime.now().strftime('%H:%M:%S')}")
                        else:
                            self.logger.warning(f"Report queued offline (queue size: {self.offline_queue.get_queue_size()})")
                    else:
                        self.logger.warning("No data collected, skipping report")
                    
                except Exception as e:
                    self.logger.error(f"Error in main loop: {e}")
                
                time.sleep(self.interval)
                
        except KeyboardInterrupt:
            self.logger.info("Client stopped by user")
            # Final attempt to flush queue
            if self.offline_queue.get_queue_size() > 0:
                self.logger.info("Attempting to flush remaining queued activities...")
                self.flush_offline_queue()
        except Exception as e:
            self.logger.error(f"Fatal error: {e}")
            raise
</file>

<file path="clients/shared/config_manager.py">
"""
Configuration management for Sentinel clients
"""

import json
import os
from typing import Dict, Any

class ConfigManager:
    def __init__(self, config_path: str):
        self.config_path = config_path
    
    def load_config(self) -> Dict[str, Any]:
        """Load configuration from JSON file"""
        if not os.path.exists(self.config_path):
            raise FileNotFoundError(f"Config file not found: {self.config_path}")
            
        try:
            with open(self.config_path, 'r') as f:
                config = json.load(f)
            
            # Validate required fields
            required_fields = ['server_url', 'api_key']
            for field in required_fields:
                if field not in config:
                    raise ValueError(f"Missing required config field: {field}")
            
            return config
            
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON in config file: {e}")
        except Exception as e:
            raise ValueError(f"Error loading config: {e}")
    
    def save_config(self, config: Dict[str, Any]) -> bool:
        """Save configuration to JSON file"""
        try:
            with open(self.config_path, 'w') as f:
                json.dump(config, f, indent=2)
            return True
        except Exception as e:
            print(f"Error saving config: {e}")
            return False
    
    def validate_config(self, config: Dict[str, Any]) -> bool:
        """Validate configuration structure"""
        try:
            required_fields = ['server_url', 'api_key']
            for field in required_fields:
                if field not in config:
                    return False
            
            # Validate URL format
            if not config['server_url'].startswith(('http://', 'https://')):
                return False
            
            # Validate interval
            if 'interval' in config and (not isinstance(config['interval'], int) or config['interval'] < 10):
                return False
            
            return True
        except:
            return False
    
    def create_default_config(self, server_url: str, api_key: str, client_id: str = None) -> Dict[str, Any]:
        """Create a default configuration"""
        import socket
        if client_id is None:
            client_id = f"client-{socket.gethostname().lower().replace(' ', '-')}"
        
        return {
            "server_url": server_url,
            "api_key": api_key,
            "client_id": client_id,
            "interval": 60,
            "max_retries": 3,
            "retry_delay": 5,
            "log_level": "INFO",
            "features": {
                "track_active_window": True,
                "track_processes": True,
                "track_system_metrics": True
            }
        }
</file>

<file path="clients/shared/requierements.txt">
psutil==5.9.5
requests==2.31.0
python-dotenv==1.0.0
</file>

<file path="clients/shared/utils.py">
"""
Utility functions for Sentinel clients
"""

import logging
import platform
import os
import sys
from typing import Dict, Any

def setup_logging(name: str, level: str = "INFO") -> logging.Logger:
    """Setup logging for the client"""
    logger = logging.getLogger(name)
    
    if not logger.handlers:
        # Set log level
        log_level = getattr(logging, level.upper(), logging.INFO)
        logger.setLevel(log_level)
        
        # Create formatter
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        
        # Console handler
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(log_level)
        console_handler.setFormatter(formatter)
        logger.addHandler(console_handler)
        
        # File handler
        try:
            log_dir = "/var/log/sentinel" if os.name == 'posix' else "C:\\Logs\\Sentinel"
            if not os.path.exists(log_dir):
                os.makedirs(log_dir, exist_ok=True)
            
            log_file = os.path.join(log_dir, f"{name}.log")
            file_handler = logging.FileHandler(log_file)
            file_handler.setLevel(log_level)
            file_handler.setFormatter(formatter)
            logger.addHandler(file_handler)
        except Exception:
            pass  # Skip file logging if not possible
    
    return logger

def get_system_info() -> Dict[str, Any]:
    """Get basic system information"""
    try:
        import psutil
        
        # Get memory info
        memory = psutil.virtual_memory()
        
        # Get disk info
        disk = psutil.disk_usage('/' if os.name == 'posix' else 'C:\\')
        
        system_info = {
            "system": platform.system(),
            "release": platform.release(),
            "version": platform.version(),
            "machine": platform.machine(),
            "processor": platform.processor(),
            "node": platform.node(),
            "architecture": platform.architecture()[0],
            "memory_total_gb": round(memory.total / (1024**3), 1),
            "disk_total_gb": round(disk.total / (1024**3), 1),
            "python_version": platform.python_version()
        }
        
        # Add distribution info for Linux
        if hasattr(platform, 'linux_distribution'):
            distro = platform.linux_distribution()
            system_info["distribution"] = f"{distro[0]} {distro[1]}"
        elif os.path.exists('/etc/os-release'):
            try:
                with open('/etc/os-release', 'r') as f:
                    for line in f:
                        if line.startswith('PRETTY_NAME='):
                            system_info["distribution"] = line.split('=', 1)[1].strip().strip('"')
                            break
            except:
                pass
        
        return system_info
        
    except Exception as e:
        # Fallback without psutil
        return {
            "system": platform.system(),
            "release": platform.release(),
            "version": platform.version(),
            "machine": platform.machine(),
            "processor": platform.processor(),
            "node": platform.node(),
            "architecture": platform.architecture()[0],
            "python_version": platform.python_version()
        }

def validate_api_key(api_key: str) -> bool:
    """Validate API key format"""
    if not api_key or not isinstance(api_key, str):
        return False
    
    # Basic validation - API keys should start with "sk_" and be reasonably long
    return api_key.startswith("sk_") and len(api_key) > 20

def format_bytes(bytes_value: int) -> str:
    """Format bytes to human readable string"""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if bytes_value < 1024.0:
            return f"{bytes_value:.1f} {unit}"
        bytes_value /= 1024.0
    return f"{bytes_value:.1f} PB"

def is_connected() -> bool:
    """Check if system has internet connection"""
    try:
        import socket
        socket.create_connection(("8.8.8.8", 53), timeout=5)
        return True
    except OSError:
        return False
</file>

<file path="clients/windows_desktop/config.json">
{
  "server_url": "http://localhost:8000",
  "api_key": "your-api-key-here",
  "client_id": "windows-desktop-001",
  "interval": 30,
  "max_retries": 3,
  "retry_delay": 5,
  "log_level": "INFO",
  "offline_storage": {
    "enabled": true,
    "max_queue_size": 1000,
    "auto_flush": true
  },
  "features": {
    "track_active_window": true,
    "track_processes": true,
    "track_system_metrics": true,
    "track_browser_usage": true,
    "track_application_usage": true,
    "monitor_event_logs": true,
    "deep_monitoring": true
  },
  "browser_tracking": {
    "chrome": true,
    "firefox": true,
    "edge": true,
    "max_history_items": 20
  },
  "windows_specific": {
    "monitor_services": true,
    "monitor_event_logs": true,
    "track_installed_software": true
  }
}
</file>

<file path="clients/windows_desktop/monitor.py">
#!/usr/bin/env python3
"""
Enhanced Sentinel Windows Desktop Client
Deep monitoring for Windows desktop environments with comprehensive application tracking
"""

import time
import argparse
import platform
import psutil
import requests
import json
import os
import sys
import subprocess
import winreg
import threading
from datetime import datetime, timezone
from typing import Optional, List, Dict, Any
import sqlite3
import tempfile
import shutil

# Add shared directory to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'shared'))
from base_client import BaseMonitorClient
from config_manager import ConfigManager
from utils import setup_logging, get_system_info

try:
    import win32gui
    import win32process
    import win32api
    import win32con
    import win32evtlog
    import win32security
    import pythoncom
    import wmi
    HAS_WIN32 = True
except ImportError:
    HAS_WIN32 = False
    print("Warning: pywin32 not available. Some advanced features disabled.")

class WindowsDesktopClient(BaseMonitorClient):
    def __init__(self, config_path: str):
        super().__init__(config_path, "windows_desktop")
        self.logger = setup_logging("windows_desktop")
        self.last_window = None
        self.window_start_time = None
        self.application_usage = {}
        self.browser_monitor = BrowserMonitor(self.logger)
        
        # Initialize WMI for advanced system monitoring
        self.wmi_conn = None
        if HAS_WIN32:
            try:
                pythoncom.CoInitialize()
                self.wmi_conn = wmi.WMI()
            except Exception as e:
                self.logger.warning(f"Failed to initialize WMI: {e}")
    
    def get_active_window(self) -> Optional[Dict[str, Any]]:
        """Get active window with detailed information"""
        if not HAS_WIN32:
            self.logger.debug("pywin32 not available, window tracking disabled")
            return None
            
        try:
            hwnd = win32gui.GetForegroundWindow()
            if hwnd:
                window_title = win32gui.GetWindowText(hwnd)
                
                # Get process information
                _, pid = win32process.GetWindowThreadProcessId(hwnd)
                
                try:
                    process = psutil.Process(pid)
                    process_name = process.name()
                    process_path = process.exe()
                    
                    # Get window class
                    window_class = win32gui.GetClassName(hwnd)
                    
                    # Get window placement
                    placement = win32gui.GetWindowPlacement(hwnd)
                    
                    # Track window usage time
                    current_time = time.time()
                    window_key = f"{process_name}|{window_title}"
                    
                    if self.last_window != window_key:
                        if self.last_window and self.window_start_time:
                            duration = current_time - self.window_start_time
                            self._track_application_usage(self.last_window, duration)
                        
                        self.last_window = window_key
                        self.window_start_time = current_time
                    
                    window_info = {
                        "title": window_title,
                        "process_name": process_name,
                        "process_path": process_path,
                        "process_id": pid,
                        "window_class": window_class,
                        "placement": {
                            "show_cmd": placement[1],
                            "min_position": placement[2],
                            "max_position": placement[3],
                            "normal_position": placement[4]
                        },
                        "focused": True
                    }
                    
                    self.logger.debug(f"Active window: {process_name} - {window_title}")
                    return window_info
                    
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    self.logger.debug(f"Could not access process for window: {window_title}")
                    return {"title": window_title, "process_name": "Unknown"}
                    
        except Exception as e:
            self.logger.debug(f"Error getting active window: {e}")
        
        return None
    
    def _track_application_usage(self, window_key: str, duration: float):
        """Track application usage time"""
        if window_key not in self.application_usage:
            self.application_usage[window_key] = 0
        self.application_usage[window_key] += duration
    
    def get_browser_usage(self) -> Dict[str, Any]:
        """Get detailed browser usage information"""
        return self.browser_monitor.get_browser_usage()
    
    def get_process_list(self) -> List[Dict[str, Any]]:
        """Get detailed process information for desktop applications"""
        desktop_keywords = [
            'chrome', 'firefox', 'edge', 'msedge', 'explorer', 'notepad', 
            'word', 'excel', 'powerpoint', 'outlook', 'teams', 'slack', 
            'discord', 'code', 'vscode', 'sublime_text', 'notepad++',
            'spotify', 'steam', 'photoshop', 'illustrator', 'acrobat',
            'calculator', 'paint', 'mspaint', 'winword', 'excel', 'powerpnt',
            'outlook', 'thunderbird', 'telegram', 'whatsapp', 'signal',
            'skype', 'zoom', 'teams', 'cmd', 'powershell', 'windowsterminal'
        ]
        
        processes = []
        try:
            for proc in psutil.process_iter(['pid', 'name', 'username', 'memory_info', 'cpu_percent', 'create_time', 'cmdline']):
                try:
                    proc_name = proc.info['name'].lower().replace('.exe', '')
                    is_desktop_app = any(keyword in proc_name for keyword in desktop_keywords)
                    
                    # Also include processes with windows
                    has_window = self._process_has_window(proc.info['pid'])
                    
                    if is_desktop_app or has_window:
                        process_info = {
                            "pid": proc.info['pid'],
                            "name": proc.info['name'],
                            "user": proc.info['username'],
                            "memory_rss_mb": round(proc.info['memory_info'].rss / (1024*1024), 1) if proc.info['memory_info'] else 0,
                            "cpu_percent": round(proc.info['cpu_percent'] or 0, 1),
                            "create_time": datetime.fromtimestamp(proc.info['create_time']).isoformat() if proc.info['create_time'] else None,
                            "cmdline": ' '.join(proc.info['cmdline'] or [])[:200] if proc.info['cmdline'] else '',
                            "has_window": has_window,
                            "is_system": 'SYSTEM' in proc.info['username'] or 'NETWORK SERVICE' in proc.info['username']
                        }
                        processes.append(process_info)
                except (psutil.NoSuchProcess, psutil.AccessDenied, KeyError) as e:
                    self.logger.debug(f"Error accessing process: {e}")
                    continue
            
            # Limit to prevent huge payloads
            processes = processes[:50]
            self.logger.debug(f"Collected {len(processes)} desktop processes")
            return processes
        except Exception as e:
            self.logger.error(f"Error getting process list: {e}")
            return []
    
    def _process_has_window(self, pid: int) -> bool:
        """Check if process has visible windows"""
        if not HAS_WIN32:
            return False
            
        try:
            def enum_windows_proc(hwnd, param):
                if win32gui.IsWindowVisible(hwnd) and win32gui.GetWindowText(hwnd):
                    _, window_pid = win32process.GetWindowThreadProcessId(hwnd)
                    if window_pid == pid:
                        param['has_window'] = True
                        return False  # Stop enumeration
                return True
            
            param = {'has_window': False}
            win32gui.EnumWindows(enum_windows_proc, param)
            return param['has_window']
        except:
            return False
    
    def get_system_metrics(self) -> Dict[str, Any]:
        """Get comprehensive Windows system metrics"""
        try:
            # CPU metrics
            cpu_percent = psutil.cpu_percent(interval=1)
            cpu_per_core = psutil.cpu_percent(interval=1, percpu=True)
            
            # Memory metrics
            memory = psutil.virtual_memory()
            
            # Disk metrics - multiple drives
            disk_info = {}
            for partition in psutil.disk_partitions():
                try:
                    if 'cdrom' in partition.opts:
                        continue
                    usage = psutil.disk_usage(partition.mountpoint)
                    disk_io = psutil.disk_io_counters(perdisk=True)
                    
                    disk_info[partition.mountpoint] = {
                        "device": partition.device,
                        "fstype": partition.fstype,
                        "total_gb": round(usage.total / (1024**3), 1),
                        "used_gb": round(usage.used / (1024**3), 1),
                        "free_gb": round(usage.free / (1024**3), 1),
                        "percent": round(usage.percent, 1)
                    }
                except Exception as e:
                    self.logger.debug(f"Error getting disk info for {partition.mountpoint}: {e}")
            
            # Network metrics
            net_io = psutil.net_io_counters()
            net_connections = len(psutil.net_connections())
            
            # Battery info
            battery_info = None
            try:
                battery = psutil.sensors_battery()
                if battery:
                    battery_info = {
                        "percent": round(battery.percent, 1),
                        "power_plugged": battery.power_plugged,
                        "time_left": battery.secsleft if hasattr(battery, 'secsleft') and battery.secsleft != psutil.POWER_TIME_UNLIMITED else None
                    }
            except Exception as e:
                self.logger.debug(f"Could not get battery info: {e}")
            
            # Windows-specific metrics via WMI
            wmi_metrics = self._get_wmi_metrics()
            
            metrics = {
                "windows_version": platform.win32_ver()[0],
                "windows_build": platform.win32_ver()[1],
                "edition": self._get_windows_edition(),
                
                "cpu": {
                    "percent": round(cpu_percent, 1),
                    "per_core": [round(p, 1) for p in cpu_per_core],
                    "cores": psutil.cpu_count(),
                    "cores_logical": psutil.cpu_count(logical=True)
                },
                
                "memory": {
                    "total_gb": round(memory.total / (1024**3), 1),
                    "used_gb": round(memory.used / (1024**3), 1),
                    "available_gb": round(memory.available / (1024**3), 1),
                    "percent": round(memory.percent, 1)
                },
                
                "disks": disk_info,
                
                "network": {
                    "bytes_sent_mb": round(net_io.bytes_sent / (1024**2), 1),
                    "bytes_recv_mb": round(net_io.bytes_recv / (1024**2), 1),
                    "packets_sent": net_io.packets_sent,
                    "packets_recv": net_io.packets_recv,
                    "active_connections": net_connections
                },
                
                "battery": battery_info,
                "wmi_metrics": wmi_metrics,
                "users": self._get_logged_in_users(),
                "uptime_seconds": time.time() - psutil.boot_time(),
                "system_boot_time": datetime.fromtimestamp(psutil.boot_time()).isoformat()
            }
            
            self.logger.debug("Collected comprehensive Windows system metrics")
            return metrics
        except Exception as e:
            self.logger.error(f"Error getting system metrics: {e}")
            return {}
    
    def _get_wmi_metrics(self) -> Dict[str, Any]:
        """Get Windows-specific metrics via WMI"""
        if not self.wmi_conn:
            return {}
            
        try:
            wmi_info = {}
            
            # Temperature information
            try:
                temperatures = self.wmi_conn.Win32_TemperatureProbe()
                if temperatures:
                    wmi_info['temperatures'] = [
                        {
                            'name': temp.Name,
                            'reading': temp.CurrentReading,
                            'units': temp.Units
                        } for temp in temperatures
                    ]
            except:
                pass
            
            # Fan information
            try:
                fans = self.wmi_conn.Win32_Fan()
                if fans:
                    wmi_info['fans'] = [
                        {
                            'name': fan.Name,
                            'speed': fan.DesiredSpeed
                        } for fan in fans
                    ]
            except:
                pass
            
            # BIOS information
            try:
                bios = self.wmi_conn.Win32_BIOS()[0]
                wmi_info['bios'] = {
                    'manufacturer': bios.Manufacturer,
                    'version': bios.Version,
                    'release_date': bios.ReleaseDate
                }
            except:
                pass
            
            # Computer system information
            try:
                computer_system = self.wmi_conn.Win32_ComputerSystem()[0]
                wmi_info['computer_system'] = {
                    'manufacturer': computer_system.Manufacturer,
                    'model': computer_system.Model,
                    'total_physical_memory': int(computer_system.TotalPhysicalMemory) if computer_system.TotalPhysicalMemory else 0
                }
            except:
                pass
            
            return wmi_info
        except Exception as e:
            self.logger.debug(f"Error getting WMI metrics: {e}")
            return {}
    
    def _get_windows_edition(self) -> str:
        """Get Windows edition information"""
        try:
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows NT\CurrentVersion") as key:
                try:
                    edition = winreg.QueryValueEx(key, "EditionID")[0]
                    return edition
                except:
                    return "Unknown"
        except:
            return "Unknown"
    
    def _get_logged_in_users(self) -> List[Dict[str, Any]]:
        """Get information about logged-in users"""
        users = []
        try:
            for user in psutil.users():
                users.append({
                    "name": user.name,
                    "terminal": user.terminal or "Console",
                    "host": user.host,
                    "started": datetime.fromtimestamp(user.started).isoformat()
                })
        except Exception as e:
            self.logger.debug(f"Error getting user info: {e}")
        
        return users
    
    def get_event_logs(self) -> Dict[str, List[Dict[str, Any]]]:
        """Get Windows Event Logs"""
        if not HAS_WIN32:
            return {}
            
        event_logs = {
            "application": [],
            "system": [],
            "security": []
        }
        
        log_types = ['Application', 'System', 'Security']
        
        for log_type in log_types:
            try:
                hand = win32evtlog.OpenEventLog(None, log_type)
                total = win32evtlog.GetNumberOfEventLogRecords(hand)
                
                # Read recent events
                flags = win32evtlog.EVENTLOG_BACKWARDS_READ | win32evtlog.EVENTLOG_SEQUENTIAL_READ
                events = win32evtlog.ReadEventLog(hand, flags, 0)
                
                event_count = 0
                for event in events:
                    if event_count >= 10:  # Limit per log type
                        break
                    
                    event_info = {
                        "event_id": event.EventID,
                        "source": event.SourceName,
                        "time_generated": event.TimeGenerated.isoformat(),
                        "message": self._clean_event_message(event.StringInserts),
                        "level": self._get_event_level(event.EventType)
                    }
                    
                    event_logs[log_type.lower()].append(event_info)
                    event_count += 1
                
                win32evtlog.CloseEventLog(hand)
            except Exception as e:
                self.logger.debug(f"Error reading {log_type} event log: {e}")
        
        return event_logs
    
    def _clean_event_message(self, message_inserts):
        """Clean event message inserts"""
        if message_inserts:
            return ' '.join(str(msg) for msg in message_inserts if msg)
        return ""
    
    def _get_event_level(self, event_type):
        """Convert event type to string level"""
        levels = {
            1: "ERROR",
            2: "WARNING", 
            4: "INFORMATION",
            8: "AUDIT_SUCCESS",
            16: "AUDIT_FAILURE"
        }
        return levels.get(event_type, "UNKNOWN")
    
    def get_additional_data(self) -> Dict[str, Any]:
        """Get additional Windows-specific data"""
        return {
            "browser_usage": self.get_browser_usage(),
            "application_usage": self.application_usage,
            "event_logs": self.get_event_logs(),
            "windows_updates": self._get_windows_update_info(),
            "installed_software": self._get_installed_software(),
            "network_shares": self._get_network_shares()
        }
    
    def _get_windows_update_info(self) -> Dict[str, Any]:
        """Get Windows Update information"""
        try:
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\Results") as key:
                try:
                    last_success = winreg.QueryValueEx(key, "LastSuccessTime")[0]
                    return {
                        "last_successful_update": last_success,
                        "update_service_running": self._is_service_running("wuauserv")
                    }
                except:
                    return {"update_service_running": self._is_service_running("wuauserv")}
        except:
            return {"update_service_running": False}
    
    def _is_service_running(self, service_name: str) -> bool:
        """Check if a Windows service is running"""
        try:
            result = subprocess.run(
                ['sc', 'query', service_name], 
                capture_output=True, text=True, timeout=5
            )
            return "RUNNING" in result.stdout
        except:
            return False
    
    def _get_installed_software(self) -> List[Dict[str, str]]:
        """Get list of installed software"""
        software_list = []
        registry_paths = [
            r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
            r"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
        ]
        
        for path in registry_paths:
            try:
                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, path) as key:
                    i = 0
                    while True:
                        try:
                            subkey_name = winreg.EnumKey(key, i)
                            with winreg.OpenKey(key, subkey_name) as subkey:
                                try:
                                    display_name = winreg.QueryValueEx(subkey, "DisplayName")[0]
                                    try:
                                        version = winreg.QueryValueEx(subkey, "DisplayVersion")[0]
                                    except:
                                        version = "Unknown"
                                    
                                    software_list.append({
                                        "name": display_name,
                                        "version": version
                                    })
                                except:
                                    pass
                            i += 1
                        except WindowsError:
                            break
            except:
                pass
        
        return software_list[:20]  # Limit to 20 items
    
    def _get_network_shares(self) -> List[Dict[str, str]]:
        """Get network shares"""
        shares = []
        try:
            result = subprocess.run(['net', 'share'], capture_output=True, text=True, timeout=5)
            lines = result.stdout.split('\n')
            
            for line in lines:
                if line.strip() and not line.startswith('Share name') and not line.startswith('---'):
                    parts = line.split()
                    if len(parts) >= 2:
                        shares.append({
                            "name": parts[0],
                            "path": parts[1]
                        })
        except:
            pass
        
        return shares
    
    def get_platform_info(self) -> Dict[str, Any]:
        """Get platform-specific information"""
        platform_info = get_system_info()
        platform_info.update({
            "client_type": "windows_desktop",
            "windows_version": platform.win32_ver()[0],
            "windows_edition": self._get_windows_edition(),
            "architecture": platform.architecture()[0],
            "machine": platform.machine()
        })
        return platform_info


class BrowserMonitor:
    """Monitor browser usage and history"""
    
    def __init__(self, logger):
        self.logger = logger
    
    def get_browser_usage(self) -> Dict[str, Any]:
        """Get browser usage information for all installed browsers"""
        browser_data = {}
        
        # Chrome/Edge tracking
        chrome_data = self._get_chrome_usage()
        if chrome_data:
            browser_data['chrome'] = chrome_data
        
        # Firefox tracking
        firefox_data = self._get_firefox_usage()
        if firefox_data:
            browser_data['firefox'] = firefox_data
        
        # Internet Explorer/Edge Legacy
        ie_data = self._get_ie_usage()
        if ie_data:
            browser_data['internet_explorer'] = ie_data
        
        return browser_data
    
    def _get_chrome_usage(self) -> Optional[Dict[str, Any]]:
        """Get Chrome/Edge usage data"""
        try:
            browsers = [
                ('chrome', 'Google\\Chrome'),
                ('edge', 'Microsoft\\Edge'),
                ('brave', 'BraveSoftware\\Brave-Browser'),
                ('opera', 'Opera Software\\Opera Stable')
            ]
            
            browser_data = {}
            for browser_name, browser_path in browsers:
                profiles = self._get_chrome_profiles(browser_path)
                if profiles:
                    browser_data[browser_name] = {
                        'profiles': profiles,
                        'process_count': self._get_browser_process_count(browser_name)
                    }
            
            return browser_data
        except Exception as e:
            self.logger.debug(f"Error getting Chrome usage: {e}")
            return None
    
    def _get_chrome_profiles(self, browser_path: str) -> List[Dict[str, Any]]:
        """Get Chrome profile information"""
        profiles = []
        user_profile = os.environ.get('USERPROFILE', '')
        browser_dir = os.path.join(user_profile, 'AppData', 'Local', browser_path, 'User Data')
        
        if not os.path.exists(browser_dir):
            return profiles
        
        try:
            # Look for profile directories
            for item in os.listdir(browser_dir):
                profile_path = os.path.join(browser_dir, item)
                if os.path.isdir(profile_path) and (item.startswith('Profile') or item == 'Default'):
                    history_db = os.path.join(profile_path, 'History')
                    
                    if os.path.exists(history_db):
                        # Copy database to avoid locking
                        temp_db = tempfile.NamedTemporaryFile(delete=False, suffix='.db')
                        try:
                            shutil.copy2(history_db, temp_db.name)
                            
                            conn = sqlite3.connect(temp_db.name)
                            cursor = conn.cursor()
                            
                            try:
                                # Get recent history
                                cursor.execute("""
                                    SELECT url, title, visit_count, last_visit_time 
                                    FROM urls 
                                    ORDER BY last_visit_time DESC 
                                    LIMIT 20
                                """)
                                history = cursor.fetchall()
                                
                                profiles.append({
                                    'profile': item,
                                    'recent_history': [
                                        {
                                            'url': row[0],
                                            'title': row[1],
                                            'visit_count': row[2],
                                            'last_visit': row[3]
                                        } for row in history
                                    ]
                                })
                            except Exception as e:
                                self.logger.debug(f"Error reading browser history: {e}")
                            finally:
                                conn.close()
                            os.unlink(temp_db.name)
                        except:
                            if os.path.exists(temp_db.name):
                                os.unlink(temp_db.name)
        except Exception as e:
            self.logger.debug(f"Error processing browser profiles: {e}")
        
        return profiles
    
    def _get_firefox_usage(self) -> Optional[Dict[str, Any]]:
        """Get Firefox usage data"""
        try:
            user_profile = os.environ.get('USERPROFILE', '')
            firefox_dir = os.path.join(user_profile, 'AppData', 'Roaming', 'Mozilla', 'Firefox', 'Profiles')
            
            if not os.path.exists(firefox_dir):
                return None
            
            profiles = []
            for item in os.listdir(firefox_dir):
                profile_path = os.path.join(firefox_dir, item)
                if os.path.isdir(profile_path) and item.endswith('.default-release'):
                    places_db = os.path.join(profile_path, 'places.sqlite')
                    
                    if os.path.exists(places_db):
                        temp_db = tempfile.NamedTemporaryFile(delete=False, suffix='.db')
                        try:
                            shutil.copy2(places_db, temp_db.name)
                            
                            conn = sqlite3.connect(temp_db.name)
                            cursor = conn.cursor()
                            
                            try:
                                cursor.execute("""
                                    SELECT url, title, visit_count, last_visit_date 
                                    FROM moz_places 
                                    ORDER BY last_visit_date DESC 
                                    LIMIT 20
                                """)
                                history = cursor.fetchall()
                                
                                profiles.append({
                                    'profile': item,
                                    'recent_history': [
                                        {
                                            'url': row[0],
                                            'title': row[1],
                                            'visit_count': row[2],
                                            'last_visit': row[3]
                                        } for row in history
                                    ]
                                })
                            except Exception as e:
                                self.logger.debug(f"Error reading Firefox history: {e}")
                            finally:
                                conn.close()
                            os.unlink(temp_db.name)
                        except:
                            if os.path.exists(temp_db.name):
                                os.unlink(temp_db.name)
            
            if profiles:
                return {
                    'profiles': profiles,
                    'process_count': self._get_browser_process_count('firefox')
                }
        except Exception as e:
            self.logger.debug(f"Error getting Firefox usage: {e}")
        
        return None
    
    def _get_ie_usage(self) -> Optional[Dict[str, Any]]:
        """Get Internet Explorer usage data"""
        try:
            # IE history is stored in the registry and index.dat files
            # This is a simplified version - full implementation would be more complex
            return {
                'process_count': self._get_browser_process_count('iexplore'),
                'note': 'Detailed history tracking requires additional implementation'
            }
        except Exception as e:
            self.logger.debug(f"Error getting IE usage: {e}")
            return None
    
    def _get_browser_process_count(self, browser_name: str) -> int:
        """Get number of running browser processes"""
        try:
            count = 0
            for proc in psutil.process_iter(['name']):
                try:
                    if browser_name.lower() in proc.info['name'].lower():
                        count += 1
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            return count
        except:
            return 0


def main():
    parser = argparse.ArgumentParser(description="Enhanced Sentinel Windows Desktop Client")
    parser.add_argument(
        "--config", 
        default="config.json",
        help="Path to configuration file (default: config.json)"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Enable verbose logging"
    )
    
    args = parser.parse_args()
    
    try:
        client = WindowsDesktopClient(args.config)
        if args.verbose:
            client.logger.setLevel("DEBUG")
        client.run()
    except KeyboardInterrupt:
        print("\nStopping Enhanced Windows Desktop Client...")
    except Exception as e:
        print(f"Failed to start client: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
</file>

<file path="clients/windows_desktop/requirements.txt">
psutil==5.9.5
requests==2.31.0
python-dotenv==1.0.0
pywin32==306
WMI==1.5.1
pythoncom==1.0.0
# Note: pywin32 may require running post-install script:
# python Scripts/pywin32_postinstall.py -install
</file>

<file path="clients/windows_server/config.json">
{
  "server_url": "http://localhost:8000",
  "api_key": "your-api-key-here",
  "client_id": "windows-server-001",
  "interval": 60,
  "max_retries": 3,
  "retry_delay": 5,
  "log_level": "INFO",
  "offline_storage": {
    "enabled": true,
    "max_queue_size": 1000,
    "auto_flush": true
  },
  "features": {
    "track_processes": true,
    "track_system_metrics": true,
    "monitor_services": true,
    "monitor_event_logs": true,
    "track_iis_status": true,
    "security_scanning": true,
    "deep_monitoring": true
  },
  "windows_server": {
    "monitor_roles": true,
    "track_security_events": true,
    "monitor_windows_updates": true,
    "iis_monitoring": true
  }
}
</file>

<file path="clients/windows_server/monitor.py">
#!/usr/bin/env python3
"""
Enhanced Sentinel Windows Server Client
Comprehensive system analytics, process monitoring, and log categorization for Windows Server
"""

import time
import argparse
import platform
import psutil
import requests
import json
import os
import sys
import subprocess
import winreg
import re
from datetime import datetime, timezone
from typing import Optional, List, Dict, Any
import threading

# Add shared directory to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'shared'))
from base_client import BaseMonitorClient
from config_manager import ConfigManager
from utils import setup_logging, get_system_info

try:
    import win32evtlog
    import win32service
    import win32security
    import pythoncom
    import wmi
    HAS_WIN32 = True
except ImportError:
    HAS_WIN32 = False
    print("Warning: pywin32 not available. Some advanced features disabled.")

class WindowsServerClient(BaseMonitorClient):
    def __init__(self, config_path: str):
        super().__init__(config_path, "windows_server")
        self.logger = setup_logging("windows_server")
        self.log_patterns = self._initialize_log_patterns()
        
        # Initialize WMI for advanced system monitoring
        self.wmi_conn = None
        if HAS_WIN32:
            try:
                pythoncom.CoInitialize()
                self.wmi_conn = wmi.WMI()
            except Exception as e:
                self.logger.warning(f"Failed to initialize WMI: {e}")
    
    def _initialize_log_patterns(self) -> Dict[str, List[str]]:
        """Initialize log patterns for categorization"""
        return {
            "authentication": [
                r"logon",
                r"logoff",
                r"authentication",
                r"credential",
                r"password",
                r"user.*success",
                r"user.*fail"
            ],
            "security": [
                r"audit",
                r"security",
                r"firewall",
                r" intrusion",
                r"attack",
                r"malware",
                r"virus",
                r"threat",
                r"breach"
            ],
            "system_errors": [
                r"error",
                r"failed",
                r"critical",
                r"failure",
                r"timeout",
                r"crash",
                r"hang",
                r"unexpected"
            ],
            "application": [
                r"application",
                r"service",
                r"iis",
                r"sql",
                r"database",
                r"web",
                r"http",
                r"https"
            ],
            "network": [
                r"network",
                r"connection",
                r"tcp",
                r"udp",
                r"port",
                r"dns",
                r"dhcp",
                r"ip address"
            ]
        }
    
    def get_active_window(self) -> Optional[str]:
        """No active window on server"""
        return None
    
    def get_process_list(self) -> List[Dict[str, Any]]:
        """Get comprehensive process information for server applications"""
        server_keywords = [
            'sql', 'mysql', 'postgres', 'mongod', 'redis', 'apache', 'httpd',
            'nginx', 'iis', 'w3wp', 'tomcat', 'java', 'node', 'python', 'ruby',
            'powershell', 'cmd', 'services', 'svchost', 'lsass', 'winlogon',
            'spoolsv', 'taskhost', 'searchindexer', 'system', 'idle'
        ]
        
        processes = []
        try:
            for proc in psutil.process_iter(['pid', 'name', 'username', 'memory_info', 'cpu_percent', 'create_time', 'cmdline', 'status']):
                try:
                    proc_name = proc.info['name'].lower().replace('.exe', '')
                    
                    # Include system processes and server applications
                    is_system_process = 'SYSTEM' in proc.info['username'] or 'NETWORK SERVICE' in proc.info['username']
                    is_server_process = any(keyword in proc_name for keyword in server_keywords)
                    
                    if is_system_process or is_server_process:
                        process_info = {
                            "pid": proc.info['pid'],
                            "name": proc.info['name'],
                            "user": proc.info['username'],
                            "memory_rss_mb": round(proc.info['memory_info'].rss / (1024*1024), 1) if proc.info['memory_info'] else 0,
                            "memory_vms_mb": round(proc.info['memory_info'].vms / (1024*1024), 1) if proc.info['memory_info'] else 0,
                            "cpu_percent": round(proc.info['cpu_percent'] or 0, 1),
                            "status": proc.info['status'],
                            "create_time": datetime.fromtimestamp(proc.info['create_time']).isoformat() if proc.info['create_time'] else None,
                            "cmdline": ' '.join(proc.info['cmdline'] or [])[:500] if proc.info['cmdline'] else '',
                            "threads": proc.num_threads(),
                            "category": self._categorize_process(proc.info['name'], proc.info['cmdline'] or [])
                        }
                        processes.append(process_info)
                except (psutil.NoSuchProcess, psutil.AccessDenied, KeyError) as e:
                    self.logger.debug(f"Error accessing process: {e}")
                    continue
            
            # Limit number of processes
            processes = processes[:100]
            self.logger.debug(f"Collected {len(processes)} server processes")
            return processes
        except Exception as e:
            self.logger.error(f"Error getting process list: {e}")
            return []
    
    def _categorize_process(self, name: str, cmdline: List[str]) -> str:
        """Categorize process based on name and command line"""
        categories = {
            'system': ['system', 'svchost', 'lsass', 'winlogon', 'services', 'csrss', 'smss'],
            'network': ['iis', 'w3wp', 'httpd', 'nginx', 'apache', 'tomcat', 'node', 'python'],
            'database': ['sql', 'mysql', 'postgres', 'mongod', 'redis', 'oracle'],
            'web': ['iis', 'w3wp', 'nginx', 'apache', 'tomcat', 'httpd'],
            'security': ['defender', 'security', 'antivirus', 'firewall'],
            'storage': ['sql', 'mysql', 'postgres', 'mongod'],
            'monitoring': ['zabbix', 'nagios', 'prometheus', 'grafana']
        }
        
        name_lower = name.lower()
        cmdline_str = ' '.join(cmdline).lower()
        
        for category, keywords in categories.items():
            if any(keyword in name_lower for keyword in keywords):
                return category
            if any(keyword in cmdline_str for keyword in keywords):
                return category
        
        return 'application'
    
    def get_event_logs(self) -> Dict[str, List[Dict[str, Any]]]:
        """Get and categorize Windows Event Logs"""
        if not HAS_WIN32:
            return {}
            
        log_categories = {
            "application": [],
            "system": [],
            "security": [],
            "directory service": [],
            "dns server": [],
            "file replication service": []
        }
        
        for log_name in log_categories.keys():
            try:
                hand = win32evtlog.OpenEventLog(None, log_name)
                flags = win32evtlog.EVENTLOG_BACKWARDS_READ | win32evtlog.EVENTLOG_SEQUENTIAL_READ
                events = win32evtlog.ReadEventLog(hand, flags, 0)
                
                event_count = 0
                for event in events:
                    if event_count >= 15:  # Limit per log
                        break
                    
                    event_message = self._clean_event_message(event.StringInserts)
                    category = self._categorize_log_entry(event_message, event.SourceName)
                    
                    event_info = {
                        "event_id": event.EventID,
                        "source": event.SourceName,
                        "time_generated": event.TimeGenerated.isoformat(),
                        "message": event_message,
                        "level": self._get_event_level(event.EventType),
                        "category": category
                    }
                    
                    log_categories[log_name].append(event_info)
                    event_count += 1
                
                win32evtlog.CloseEventLog(hand)
            except Exception as e:
                self.logger.debug(f"Error reading {log_name} event log: {e}")
        
        return log_categories
    
    def _clean_event_message(self, message_inserts):
        """Clean event message inserts"""
        if message_inserts:
            return ' '.join(str(msg) for msg in message_inserts if msg)
        return ""
    
    def _get_event_level(self, event_type):
        """Convert event type to string level"""
        levels = {
            1: "ERROR",
            2: "WARNING", 
            4: "INFORMATION",
            8: "AUDIT_SUCCESS",
            16: "AUDIT_FAILURE"
        }
        return levels.get(event_type, "UNKNOWN")
    
    def _categorize_log_entry(self, message: str, source: str) -> str:
        """Categorize log entry based on patterns and source"""
        message_lower = message.lower()
        source_lower = source.lower()
        
        for category, patterns in self.log_patterns.items():
            for pattern in patterns:
                if re.search(pattern, message_lower, re.IGNORECASE):
                    return category
                if re.search(pattern, source_lower, re.IGNORECASE):
                    return category
        
        return 'other'
    
    def get_service_status(self) -> Dict[str, Dict[str, Any]]:
        """Get comprehensive Windows service status"""
        services = {}
        
        common_services = [
            'MSSQLSERVER', 'MySQL', 'PostgreSQL', 'MongoDB', 'Redis',
            'W3SVC', 'IISADMIN', 'Tomcat', 'Apache', 'nginx', 'Spooler',
            'EventLog', 'Schedule', 'Server', 'Workstation', 'BFE',
            'WinDefend', 'Dnscache', 'Dhcp', 'LanmanServer', 'LanmanWorkstation'
        ]
        
        for service in common_services:
            try:
                # Use WMI for detailed service information
                if self.wmi_conn:
                    wmi_services = self.wmi_conn.Win32_Service(Name=service)
                    if wmi_services:
                        wmi_service = wmi_services[0]
                        services[service] = {
                            "status": wmi_service.State,
                            "start_mode": wmi_service.StartMode,
                            "start_name": wmi_service.StartName,
                            "path": wmi_service.PathName,
                            "process_id": wmi_service.ProcessId
                        }
                        continue
                
                # Fallback to SC command
                result = subprocess.run(
                    ['sc', 'query', service],
                    capture_output=True, text=True, timeout=5
                )
                if result.returncode == 0:
                    lines = result.stdout.split('\n')
                    status = "UNKNOWN"
                    for line in lines:
                        if 'STATE' in line:
                            parts = line.split(':')
                            if len(parts) > 1:
                                status = parts[1].strip().split(' ')[0]
                                break
                    
                    services[service] = {
                        "status": status,
                        "process_id": self._get_service_process_id(service)
                    }
                else:
                    services[service] = {"status": "NOT_FOUND"}
            except (subprocess.TimeoutExpired, FileNotFoundError, subprocess.SubprocessError) as e:
                services[service] = {"status": "UNKNOWN"}
        
        self.logger.debug(f"Checked status of {len(services)} services")
        return services
    
    def _get_service_process_id(self, service_name: str) -> Optional[int]:
        """Get process ID for a service"""
        try:
            if self.wmi_conn:
                wmi_services = self.wmi_conn.Win32_Service(Name=service_name)
                if wmi_services:
                    return wmi_services[0].ProcessId
        except:
            pass
        return None
    
    def get_iis_status(self) -> Dict[str, Any]:
        """Get IIS server status and sites"""
        iis_info = {}
        
        try:
            # Check if IIS is installed
            result = subprocess.run(
                ['Get-WindowsFeature', 'Web-Server'],
                capture_output=True, text=True, shell=True, timeout=10
            )
            if 'Installed' in result.stdout:
                iis_info['installed'] = True
                
                # Get IIS sites (simplified - would use IIS module in production)
                try:
                    result = subprocess.run(
                        ['Import-Module', 'WebAdministration'; 'Get-IISSite'],
                        capture_output=True, text=True, shell=True, timeout=10
                    )
                    iis_info['sites'] = []
                    
                    # Parse sites from output (simplified)
                    lines = result.stdout.split('\n')
                    for line in lines:
                        if 'Name' in line and 'State' in line:
                            parts = line.split()
                            if len(parts) >= 2:
                                iis_info['sites'].append({
                                    'name': parts[0],
                                    'state': parts[1]
                                })
                except:
                    iis_info['sites'] = []
            else:
                iis_info['installed'] = False
        except:
            iis_info['installed'] = False
        
        return iis_info
    
    def get_system_metrics(self) -> Dict[str, Any]:
        """Get comprehensive Windows server metrics"""
        try:
            # System load (Windows doesn't have load average like Linux)
            cpu_percent = psutil.cpu_percent(interval=1)
            cpu_per_core = psutil.cpu_percent(interval=1, percpu=True)
            
            # Memory metrics
            memory = psutil.virtual_memory()
            swap = psutil.swap_memory()
            
            # Disk metrics - multiple drives
            disk_info = {}
            for partition in psutil.disk_partitions():
                try:
                    if 'cdrom' in partition.opts:
                        continue
                    usage = psutil.disk_usage(partition.mountpoint)
                    
                    disk_info[partition.mountpoint] = {
                        "device": partition.device,
                        "fstype": partition.fstype,
                        "total_gb": round(usage.total / (1024**3), 1),
                        "used_gb": round(usage.used / (1024**3), 1),
                        "free_gb": round(usage.free / (1024**3), 1),
                        "percent": round(usage.percent, 1)
                    }
                except Exception as e:
                    self.logger.debug(f"Error getting disk info for {partition.mountpoint}: {e}")
            
            # Network metrics
            net_io = psutil.net_io_counters()
            net_connections = psutil.net_connections()
            
            # WMI metrics for server-specific information
            wmi_metrics = self._get_wmi_server_metrics()
            
            metrics = {
                "windows_version": platform.win32_ver()[0],
                "windows_edition": self._get_windows_edition(),
                "server_role": self._get_server_role(),
                
                "cpu": {
                    "percent": round(cpu_percent, 1),
                    "per_core": [round(p, 1) for p in cpu_per_core],
                    "cores": psutil.cpu_count(),
                    "cores_logical": psutil.cpu_count(logical=True)
                },
                
                "memory": {
                    "total_gb": round(memory.total / (1024**3), 1),
                    "used_gb": round(memory.used / (1024**3), 1),
                    "available_gb": round(memory.available / (1024**3), 1),
                    "percent": round(memory.percent, 1),
                    "swap_used_gb": round(swap.used / (1024**3), 1),
                    "swap_total_gb": round(swap.total / (1024**3), 1),
                    "swap_percent": round(swap.percent, 1) if swap.total > 0 else 0
                },
                
                "disks": disk_info,
                
                "network": {
                    "bytes_sent_mb": round(net_io.bytes_sent / (1024**2), 1),
                    "bytes_recv_mb": round(net_io.bytes_recv / (1024**2), 1),
                    "packets_sent": net_io.packets_sent,
                    "packets_recv": net_io.packets_recv,
                    "active_connections": len(net_connections),
                    "tcp_connections": len([c for c in net_connections if c.type == 1]),
                    "udp_connections": len([c for c in net_connections if c.type == 2])
                },
                
                "wmi_metrics": wmi_metrics,
                "system": {
                    "uptime_seconds": time.time() - psutil.boot_time(),
                    "uptime_days": round((time.time() - psutil.boot_time()) / (24 * 3600), 1),
                    "boot_time": datetime.fromtimestamp(psutil.boot_time()).isoformat(),
                    "users": len(psutil.users())
                }
            }
            
            self.logger.debug("Collected comprehensive Windows server metrics")
            return metrics
        except Exception as e:
            self.logger.error(f"Error getting system metrics: {e}")
            return {}
    
    def _get_wmi_server_metrics(self) -> Dict[str, Any]:
        """Get Windows Server-specific metrics via WMI"""
        if not self.wmi_conn:
            return {}
            
        try:
            wmi_info = {}
            
            # Server features
            try:
                features = self.wmi_conn.Win32_ServerFeature()
                if features:
                    wmi_info['server_features'] = [feature.Name for feature in features]
            except:
                pass
            
            # Page file information
            try:
                page_files = self.wmi_conn.Win32_PageFileUsage()
                if page_files:
                    wmi_info['page_files'] = [
                        {
                            'name': pf.Name,
                            'allocated_gb': round(int(pf.AllocatedBaseSize) / 1024, 1),
                            'current_usage_gb': round(int(pf.CurrentUsage) / 1024, 1)
                        } for pf in page_files
                    ]
            except:
                pass
            
            # Logical disks with detailed info
            try:
                logical_disks = self.wmi_conn.Win32_LogicalDisk()
                if logical_disks:
                    wmi_info['logical_disks'] = [
                        {
                            'device_id': ld.DeviceID,
                            'size_gb': round(int(ld.Size) / (1024**3), 1) if ld.Size else 0,
                            'free_space_gb': round(int(ld.FreeSpace) / (1024**3), 1) if ld.FreeSpace else 0,
                            'file_system': ld.FileSystem
                        } for ld in logical_disks if ld.Size
                    ]
            except:
                pass
            
            # Network adapters
            try:
                adapters = self.wmi_conn.Win32_NetworkAdapter(NetEnabled=True)
                if adapters:
                    wmi_info['network_adapters'] = [
                        {
                            'name': adapter.Name,
                            'mac_address': adapter.MACAddress,
                            'speed_mbps': int(adapter.Speed) // 1000000 if adapter.Speed else 0
                        } for adapter in adapters
                    ]
            except:
                pass
            
            return wmi_info
        except Exception as e:
            self.logger.debug(f"Error getting WMI server metrics: {e}")
            return {}
    
    def _get_windows_edition(self) -> str:
        """Get Windows Server edition information"""
        try:
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows NT\CurrentVersion") as key:
                try:
                    edition = winreg.QueryValueEx(key, "EditionID")[0]
                    return edition
                except:
                    product_name = winreg.QueryValueEx(key, "ProductName")[0]
                    return product_name
        except:
            return "Unknown"
    
    def _get_server_role(self) -> str:
        """Get Windows Server role information"""
        try:
            # Check common server roles
            roles = []
            
            # Domain Controller
            try:
                result = subprocess.run(
                    ['dsquery', 'server'],
                    capture_output=True, text=True, timeout=5
                )
                if result.returncode == 0:
                    roles.append("Domain Controller")
            except:
                pass
            
            # DNS Server
            try:
                result = subprocess.run(
                    ['Get-WindowsFeature', 'DNS'],
                    capture_output=True, text=True, shell=True, timeout=5
                )
                if 'Installed' in result.stdout:
                    roles.append("DNS Server")
            except:
                pass
            
            # DHCP Server
            try:
                result = subprocess.run(
                    ['Get-WindowsFeature', 'DHCP'],
                    capture_output=True, text=True, shell=True, timeout=5
                )
                if 'Installed' in result.stdout:
                    roles.append("DHCP Server")
            except:
                pass
            
            # Web Server (IIS)
            try:
                result = subprocess.run(
                    ['Get-WindowsFeature', 'Web-Server'],
                    capture_output=True, text=True, shell=True, timeout=5
                )
                if 'Installed' in result.stdout:
                    roles.append("Web Server")
            except:
                pass
            
            return ', '.join(roles) if roles else "Standalone Server"
        except:
            return "Unknown"
    
    def get_additional_data(self) -> Dict[str, Any]:
        """Get additional server-specific data"""
        return {
            "services": self.get_service_status(),
            "event_logs": self.get_event_logs(),
            "iis_status": self.get_iis_status(),
            "security_scan": self._perform_security_scan(),
            "windows_updates": self._get_windows_update_info(),
            "installed_roles": self._get_installed_roles()
        }
    
    def _perform_security_scan(self) -> Dict[str, Any]:
        """Perform basic security checks for Windows Server"""
        security_checks = {}
        
        # Check UAC status
        try:
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System") as key:
                try:
                    uac_value = winreg.QueryValueEx(key, "EnableLUA")[0]
                    security_checks['uac_enabled'] = uac_value == 1
                except:
                    security_checks['uac_enabled'] = False
        except:
            security_checks['uac_enabled'] = False
        
        # Check Windows Defender status
        try:
            result = subprocess.run(
                ['Get-MpComputerStatus'],
                capture_output=True, text=True, shell=True, timeout=5
            )
            security_checks['defender_enabled'] = 'True' in result.stdout
        except:
            security_checks['defender_enabled'] = False
        
        # Check firewall status
        try:
            result = subprocess.run(
                ['netsh', 'advfirewall', 'show', 'allprofiles'],
                capture_output=True, text=True, timeout=5
            )
            security_checks['firewall_enabled'] = 'ON' in result.stdout
        except:
            security_checks['firewall_enabled'] = False
        
        # Check for failed logins
        security_checks['failed_logins'] = self._count_failed_logins()
        
        return security_checks
    
    def _count_failed_logins(self) -> int:
        """Count failed login attempts from security log"""
        if not HAS_WIN32:
            return 0
            
        try:
            hand = win32evtlog.OpenEventLog(None, "Security")
            flags = win32evtlog.EVENTLOG_BACKWARDS_READ | win32evtlog.EVENTLOG_SEQUENTIAL_READ
            events = win32evtlog.ReadEventLog(hand, flags, 0)
            
            failed_count = 0
            for event in events:
                if event.EventID in [4625, 4624]:  # Failed/Success logon
                    if event.EventID == 4625:  # Failed logon
                        failed_count += 1
                if failed_count >= 100:  # Limit check
                    break
            
            win32evtlog.CloseEventLog(hand)
            return failed_count
        except:
            return 0
    
    def _get_windows_update_info(self) -> Dict[str, Any]:
        """Get Windows Update information"""
        try:
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\Results") as key:
                try:
                    last_success = winreg.QueryValueEx(key, "LastSuccessTime")[0]
                    return {
                        "last_successful_update": last_success,
                        "update_service_running": self._is_service_running("wuauserv")
                    }
                except:
                    return {"update_service_running": self._is_service_running("wuauserv")}
        except:
            return {"update_service_running": False}
    
    def _is_service_running(self, service_name: str) -> bool:
        """Check if a Windows service is running"""
        try:
            result = subprocess.run(
                ['sc', 'query', service_name], 
                capture_output=True, text=True, timeout=5
            )
            return "RUNNING" in result.stdout
        except:
            return False
    
    def _get_installed_roles(self) -> List[str]:
        """Get installed Windows Server roles"""
        roles = []
        try:
            result = subprocess.run(
                ['Get-WindowsFeature'],
                capture_output=True, text=True, shell=True, timeout=10
            )
            lines = result.stdout.split('\n')
            for line in lines:
                if '[X]' in line:
                    role = line.split('[X]')[-1].strip()
                    if role:
                        roles.append(role)
        except:
            pass
        
        return roles[:20]  # Limit to 20 roles
    
    def get_platform_info(self) -> Dict[str, Any]:
        """Get platform-specific information"""
        platform_info = get_system_info()
        platform_info.update({
            "client_type": "windows_server",
            "windows_version": platform.win32_ver()[0],
            "windows_edition": self._get_windows_edition(),
            "server_role": self._get_server_role(),
            "architecture": platform.architecture()[0],
            "machine": platform.machine()
        })
        return platform_info


def main():
    parser = argparse.ArgumentParser(description="Enhanced Sentinel Windows Server Client")
    parser.add_argument(
        "--config", 
        default="config.json",
        help="Path to configuration file (default: config.json)"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Enable verbose logging"
    )
    
    args = parser.parse_args()
    
    try:
        client = WindowsServerClient(args.config)
        if args.verbose:
            client.logger.setLevel("DEBUG")
        client.run()
    except KeyboardInterrupt:
        print("\nStopping Enhanced Windows Server Client...")
    except Exception as e:
        print(f"Failed to start client: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
</file>

<file path="clients/windows_server/requirements.txt">
psutil==5.9.5
requests==2.31.0
python-dotenv==1.0.0
pywin32==306
WMI==1.5.1
pythoncom==1.0.0
# Note: pywin32 may require running post-install script:
# python Scripts/pywin32_postinstall.py -install
</file>

<file path="frontend/public/robots.txt">
User-agent: *
Disallow: /api/
Disallow: /login
Disallow: /settings
Disallow: /clients
Disallow: /activities
</file>

<file path="frontend/src/components/common/Alert.jsx">
import React from 'react'
import { X, AlertCircle, CheckCircle, AlertTriangle, Info } from 'lucide-react'

const icons = {
  error: AlertCircle,
  success: CheckCircle,
  warning: AlertTriangle,
  info: Info
}

const Alert = ({ type = 'info', title, message, onClose, className = '' }) => {
  const Icon = icons[type]
  
  return (
    <div className={`alert alert-${type} ${className}`}>
      <div className="alert-icon">
        <Icon size={20} />
      </div>
      <div className="alert-content">
        {title && <div className="alert-title">{title}</div>}
        {message && <div className="alert-message">{message}</div>}
      </div>
      {onClose && (
        <button className="alert-close" onClick={onClose}>
          <X size={18} />
        </button>
      )}
    </div>
  )
}

export default Alert
</file>

<file path="frontend/src/components/common/Button.jsx">
import React from 'react'
import { Loader2 } from 'lucide-react'

const Button = ({
  children,
  variant = 'primary',
  size = 'md',
  loading = false,
  disabled = false,
  onClick,
  type = 'button',
  icon: Icon,
  className = '',
  ...props
}) => {
  const baseClasses = 'btn'
  const variantClasses = `btn-${variant}`
  const sizeClasses = `btn-${size}`
  const disabledClass = (disabled || loading) ? 'btn-disabled' : ''
  
  return (
    <button
      type={type}
      className={`${baseClasses} ${variantClasses} ${sizeClasses} ${disabledClass} ${className}`.trim()}
      onClick={onClick}
      disabled={disabled || loading}
      {...props}
    >
      {loading ? (
        <>
          <Loader2 className="btn-icon animate-spin" size={16} />
          <span>Loading...</span>
        </>
      ) : (
        <>
          {Icon && <Icon className="btn-icon" size={16} />}
          <span>{children}</span>
        </>
      )}
    </button>
  )
}

export default Button
</file>

<file path="frontend/src/components/common/Card.jsx">
import React from 'react'

const Card = ({ 
  children, 
  title, 
  subtitle,
  actions, 
  footer,
  className = '',
  bodyClassName = ''
}) => {
  return (
    <div className={`card ${className}`}>
      {(title || subtitle || actions) && (
        <div className="card-header">
          <div className="card-header-content">
            {title && <h3 className="card-title">{title}</h3>}
            {subtitle && <p className="card-subtitle">{subtitle}</p>}
          </div>
          {actions && <div className="card-actions">{actions}</div>}
        </div>
      )}
      
      <div className={`card-body ${bodyClassName}`}>
        {children}
      </div>
      
      {footer && (
        <div className="card-footer">
          {footer}
        </div>
      )}
    </div>
  )
}

export default Card
</file>

<file path="frontend/src/components/common/index.js">
export { default as Alert } from './Alert'
export { default as Button } from './Button'
export { default as Card } from './Card'
export { default as Input } from './Input'
export { default as LoadingSpinner } from './LoadingSpinner'
export { default as Modal } from './Modal'
export { default as Table } from './Table'
</file>

<file path="frontend/src/components/common/Input.jsx">
import React, { forwardRef } from 'react'

const Input = forwardRef(({
  label,
  type = 'text',
  value,
  onChange,
  placeholder,
  disabled = false,
  error,
  helperText,
  required = false,
  className = '',
  icon: Icon,
  ...props
}, ref) => {
  return (
    <div className={`form-group ${className}`}>
      {label && (
        <label className="form-label">
          {label}
          {required && <span className="text-error ml-1">*</span>}
        </label>
      )}
      
      <div className="input-wrapper">
        {Icon && (
          <div className="input-icon">
            <Icon size={18} />
          </div>
        )}
        <input
          ref={ref}
          type={type}
          value={value}
          onChange={onChange}
          placeholder={placeholder}
          disabled={disabled}
          required={required}
          className={`form-input ${Icon ? 'input-with-icon' : ''} ${error ? 'input-error' : ''}`}
          {...props}
        />
      </div>
      
      {error && (
        <p className="form-error">{error}</p>
      )}
      
      {helperText && !error && (
        <p className="form-helper">{helperText}</p>
      )}
    </div>
  )
})

Input.displayName = 'Input'

export default Input
</file>

<file path="frontend/src/components/common/LoadingSpinner.jsx">
import React from 'react'
import { Loader2 } from 'lucide-react'

const LoadingSpinner = ({ size = 'md', text, className = '' }) => {
  const sizes = {
    sm: 16,
    md: 24,
    lg: 32,
    xl: 48
  }
  
  return (
    <div className={`loading-spinner ${className}`}>
      <Loader2 className="animate-spin" size={sizes[size]} />
      {text && <p className="loading-text">{text}</p>}
    </div>
  )
}

export default LoadingSpinner
</file>

<file path="frontend/src/components/common/Modal.jsx">
import React, { useEffect } from 'react'
import { X } from 'lucide-react'

const Modal = ({
  isOpen,
  onClose,
  title,
  children,
  footer,
  size = 'md',
  closeOnOverlayClick = true,
  showCloseButton = true
}) => {
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden'
    } else {
      document.body.style.overflow = 'unset'
    }
    
    return () => {
      document.body.style.overflow = 'unset'
    }
  }, [isOpen])
  
  if (!isOpen) return null
  
  const handleOverlayClick = (e) => {
    if (closeOnOverlayClick && e.target === e.currentTarget) {
      onClose()
    }
  }
  
  return (
    <div className="modal-overlay" onClick={handleOverlayClick}>
      <div className={`modal modal-${size}`}>
        {(title || showCloseButton) && (
          <div className="modal-header">
            {title && <h3 className="modal-title">{title}</h3>}
            {showCloseButton && (
              <button className="modal-close" onClick={onClose}>
                <X size={20} />
              </button>
            )}
          </div>
        )}
        
        <div className="modal-body">
          {children}
        </div>
        
        {footer && (
          <div className="modal-footer">
            {footer}
          </div>
        )}
      </div>
    </div>
  )
}

export default Modal
</file>

<file path="frontend/src/components/common/Table.jsx">
import React from 'react'
import { ChevronUp, ChevronDown } from 'lucide-react'
import LoadingSpinner from './LoadingSpinner'

const Table = ({
  columns,
  data,
  loading = false,
  emptyMessage = 'No data available',
  onSort,
  sortColumn,
  sortDirection,
  className = ''
}) => {
  const handleSort = (column) => {
    if (onSort && column.sortable !== false) {
      onSort(column.key)
    }
  }
  
  if (loading) {
    return (
      <div className="table-loading">
        <LoadingSpinner text="Loading data..." />
      </div>
    )
  }
  
  if (!data || data.length === 0) {
    return (
      <div className="table-empty">
        <p>{emptyMessage}</p>
      </div>
    )
  }
  
  return (
    <div className={`table-container ${className}`}>
      <table className="table">
        <thead>
          <tr>
            {columns.map((column) => (
              <th
                key={column.key}
                style={{ width: column.width }}
                className={column.sortable !== false ? 'sortable' : ''}
                onClick={() => handleSort(column)}
              >
                <div className="th-content">
                  <span>{column.header}</span>
                  {column.sortable !== false && sortColumn === column.key && (
                    <span className="sort-icon">
                      {sortDirection === 'asc' ? (
                        <ChevronUp size={16} />
                      ) : (
                        <ChevronDown size={16} />
                      )}
                    </span>
                  )}
                </div>
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {data.map((row, rowIndex) => (
            <tr key={row.id || rowIndex}>
              {columns.map((column) => (
                <td key={column.key}>
                  {column.render
                    ? column.render(row, rowIndex)
                    : row[column.key]}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  )
}

export default Table
</file>

<file path="frontend/src/components/features/activities/ActivitiesList.jsx">
import React, { useState } from 'react'
import { useActivities } from '@hooks'
import { Card, Table, LoadingSpinner, Button, Modal } from '@components/common'
import { formatRelativeTime, formatClientType, truncateText } from '@utils'
import { RefreshCw, Eye, Filter } from 'lucide-react'
import ActivityDetails from './ActivityDetails'
import ActivityFilters from './ActivityFilters'

const ActivitiesList = () => {
  const [selectedActivity, setSelectedActivity] = useState(null)
  const [showDetails, setShowDetails] = useState(false)
  const [showFilters, setShowFilters] = useState(false)
  const [filters, setFilters] = useState({
    client_id: '',
    category: '',
    start_date: null,
    end_date: null
  })
  
  const { activities, loading, error, refetch } = useActivities(true, {
    ...filters,
    limit: 100
  })
  
  const handleViewActivity = (activity) => {
    setSelectedActivity(activity)
    setShowDetails(true)
  }
  
  const handleCloseDetails = () => {
    setShowDetails(false)
    setSelectedActivity(null)
  }
  
  const handleApplyFilters = (newFilters) => {
    setFilters(newFilters)
    setShowFilters(false)
    refetch(newFilters)
  }
  
  const columns = [
    {
      key: 'timestamp',
      header: 'Time',
      width: '15%',
      render: (activity) => formatRelativeTime(activity.timestamp)
    },
    {
      key: 'client_id',
      header: 'Client',
      width: '18%',
      render: (activity) => (
        <span className="font-mono text-sm">{activity.client_id}</span>
      )
    },
    {
      key: 'active_application',
      header: 'Application',
      width: '18%',
      render: (activity) => activity.active_application || 'Unknown'
    },
    {
      key: 'active_window',
      header: 'Window',
      width: '25%',
      render: (activity) => truncateText(activity.active_window || 'No active window', 40)
    },
    {
      key: 'category',
      header: 'Category',
      width: '12%',
      render: (activity) => (
        <span className={`badge badge-${activity.activity_category || 'other'}`}>
          {activity.activity_category || 'other'}
        </span>
      )
    },
    {
      key: 'productivity',
      header: 'Score',
      width: '8%',
      render: (activity) => {
        const score = activity.productivity_score
        if (!score) return 'N/A'
        
        let className = 'text-gray-500'
        if (score >= 70) className = 'text-success'
        else if (score >= 40) className = 'text-warning'
        else className = 'text-error'
        
        return <span className={className}>{score}%</span>
      }
    },
    {
      key: 'actions',
      header: '',
      width: '4%',
      sortable: false,
      render: (activity) => (
        <Button
          variant="secondary"
          size="sm"
          icon={Eye}
          onClick={() => handleViewActivity(activity)}
        >
          View
        </Button>
      )
    }
  ]
  
  const activeFiltersCount = Object.values(filters).filter(v => v && v !== '').length
  
  return (
    <>
      <Card
        title="Activity Log"
        subtitle={`${activities.length} activit${activities.length !== 1 ? 'ies' : 'y'}`}
        actions={
          <div className="flex gap-2">
            <Button
              variant="secondary"
              size="sm"
              icon={Filter}
              onClick={() => setShowFilters(true)}
            >
              Filters {activeFiltersCount > 0 && `(${activeFiltersCount})`}
            </Button>
            
            <Button
              variant="secondary"
              size="sm"
              icon={RefreshCw}
              onClick={() => refetch(filters)}
              disabled={loading}
            >
              Refresh
            </Button>
          </div>
        }
      >
        {loading ? (
          <LoadingSpinner text="Loading activities..." />
        ) : error ? (
          <div className="error-state">
            <p>Failed to load activities: {error}</p>
          </div>
        ) : (
          <Table
            columns={columns}
            data={activities}
            emptyMessage="No activities found"
          />
        )}
      </Card>
      
      {showDetails && selectedActivity && (
        <Modal
          isOpen={showDetails}
          onClose={handleCloseDetails}
          title="Activity Details"
          size="xl"
        >
          <ActivityDetails activity={selectedActivity} onClose={handleCloseDetails} />
        </Modal>
      )}
      
      {showFilters && (
        <Modal
          isOpen={showFilters}
          onClose={() => setShowFilters(false)}
          title="Filter Activities"
          size="md"
        >
          <ActivityFilters
            initialFilters={filters}
            onApply={handleApplyFilters}
            onClose={() => setShowFilters(false)}
          />
        </Modal>
      )}
    </>
  )
}

export default ActivitiesList
</file>

<file path="frontend/src/components/features/activities/ActivityDetails.jsx">
import React from 'react'
import { formatDate, formatPercentage, formatProductivityScore } from '@utils'
import { Activity, Monitor, Cpu, HardDrive, Clock } from 'lucide-react'

const ActivityDetails = ({ activity }) => {
  return (
    <div className="activity-details">
      {/* Basic Information */}
      <div className="detail-section">
        <h3 className="detail-section-title">
          <Activity size={20} />
          Activity Information
        </h3>
        <div className="detail-grid">
          <div className="detail-item">
            <label>Client ID</label>
            <span className="font-mono">{activity.client_id}</span>
          </div>
          <div className="detail-item">
            <label>Timestamp</label>
            <span>{formatDate(activity.timestamp, 'PPpp')}</span>
          </div>
          <div className="detail-item">
            <label>Category</label>
            <span className={`badge badge-${activity.activity_category || 'other'}`}>
              {activity.activity_category || 'other'}
            </span>
          </div>
          <div className="detail-item">
            <label>Productivity Score</label>
            <span style={{ color: formatProductivityScore(activity.productivity_score).color }}>
              {formatProductivityScore(activity.productivity_score).text}
            </span>
          </div>
        </div>
      </div>
      
      {/* Application Information */}
      <div className="detail-section">
        <h3 className="detail-section-title">
          <Monitor size={20} />
          Application Activity
        </h3>
        <div className="detail-list">
          <div className="detail-item">
            <label>Application</label>
            <span>{activity.active_application || 'Unknown'}</span>
          </div>
          <div className="detail-item">
            <label>Window Title</label>
            <span className="break-words">{activity.active_window || 'No active window'}</span>
          </div>
          {activity.active_url && (
            <div className="detail-item">
              <label>URL</label>
              <span className="break-all text-blue-600">{activity.active_url}</span>
            </div>
          )}
        </div>
      </div>
      
      {/* System Metrics */}
      {activity.system_metrics && (
        <div className="detail-section">
          <h3 className="detail-section-title">
            <Cpu size={20} />
            System Metrics
          </h3>
          <div className="detail-grid">
            {activity.cpu_percent !== null && (
              <div className="detail-item">
                <label>CPU Usage</label>
                <span>{formatPercentage(activity.cpu_percent)}</span>
              </div>
            )}
            {activity.memory_percent !== null && (
              <div className="detail-item">
                <label>Memory Usage</label>
                <span>{formatPercentage(activity.memory_percent)}</span>
              </div>
            )}
            {activity.disk_percent !== null && (
              <div className="detail-item">
                <label>Disk Usage</label>
                <span>{formatPercentage(activity.disk_percent)}</span>
              </div>
            )}
          </div>
          
          {activity.system_metrics && typeof activity.system_metrics === 'object' && (
            <div className="mt-4">
              <details className="details-expandable">
                <summary className="cursor-pointer font-medium">
                  View Full Metrics
                </summary>
                <pre className="mt-2 p-4 bg-gray-50 rounded text-xs overflow-auto">
                  {JSON.stringify(activity.system_metrics, null, 2)}
                </pre>
              </details>
            </div>
          )}
        </div>
      )}
      
      {/* Processes */}
      {activity.processes && activity.processes.length > 0 && (
        <div className="detail-section">
          <h3 className="detail-section-title">
            <HardDrive size={20} />
            Running Processes ({activity.process_count})
          </h3>
          <div className="process-list">
            {activity.processes.slice(0, 20).map((process, index) => (
              <div key={index} className="process-item">
                <div className="process-info">
                  <span className="process-name font-mono text-sm">
                    {typeof process === 'string' ? process : process.name}
                  </span>
                  {typeof process === 'object' && process.pid && (
                    <span className="process-meta text-xs text-gray-500">
                      PID: {process.pid}
                    </span>
                  )}
                </div>
                {typeof process === 'object' && (
                  <div className="process-stats text-xs">
                    {process.cpu_percent !== undefined && (
                      <span className="text-gray-600">CPU: {process.cpu_percent}%</span>
                    )}
                    {process.memory_percent !== undefined && (
                      <span className="text-gray-600 ml-2">MEM: {process.memory_percent}%</span>
                    )}
                  </div>
                )}
              </div>
            ))}
            {activity.processes.length > 20 && (
              <div className="text-sm text-gray-500 mt-2">
                ... and {activity.processes.length - 20} more processes
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

export default ActivityDetails
</file>

<file path="frontend/src/components/features/activities/ActivityFilters.jsx">
import React, { useState } from 'react'
import { Input, Button } from '@components/common'
import { useClients } from '@hooks'
import { ACTIVITY_CATEGORIES } from '@utils'

const ActivityFilters = ({ initialFilters, onApply, onClose }) => {
  const [filters, setFilters] = useState(initialFilters)
  const { clients } = useClients()
  
  const handleChange = (field, value) => {
    setFilters(prev => ({
      ...prev,
      [field]: value
    }))
  }
  
  const handleReset = () => {
    const resetFilters = {
      client_id: '',
      category: '',
      start_date: null,
      end_date: null
    }
    setFilters(resetFilters)
  }
  
  const handleApply = () => {
    onApply(filters)
  }
  
  return (
    <div className="filters-form">
      <div className="form-group">
        <label className="form-label">Client</label>
        <select
          className="form-input"
          value={filters.client_id}
          onChange={(e) => handleChange('client_id', e.target.value)}
        >
          <option value="">All Clients</option>
          {clients.map(client => (
            <option key={client.client_id} value={client.client_id}>
              {client.client_id}
            </option>
          ))}
        </select>
      </div>
      
      <div className="form-group">
        <label className="form-label">Category</label>
        <select
          className="form-input"
          value={filters.category}
          onChange={(e) => handleChange('category', e.target.value)}
        >
          <option value="">All Categories</option>
          {Object.entries(ACTIVITY_CATEGORIES).map(([key, label]) => (
            <option key={key} value={key}>
              {label}
            </option>
          ))}
        </select>
      </div>
      
      <div className="form-group">
        <label className="form-label">Start Date</label>
        <Input
          type="datetime-local"
          value={filters.start_date || ''}
          onChange={(e) => handleChange('start_date', e.target.value)}
        />
      </div>
      
      <div className="form-group">
        <label className="form-label">End Date</label>
        <Input
          type="datetime-local"
          value={filters.end_date || ''}
          onChange={(e) => handleChange('end_date', e.target.value)}
        />
      </div>
      
      <div className="form-actions">
        <Button variant="secondary" onClick={handleReset}>
          Reset
        </Button>
        <Button variant="primary" onClick={handleApply}>
          Apply Filters
        </Button>
      </div>
    </div>
  )
}

export default ActivityFilters
</file>

<file path="frontend/src/components/features/activities/index.js">
export { default as ActivitiesList } from './ActivitiesList'
export { default as ActivityDetails } from './ActivityDetails'
export { default as ActivityFilters } from './ActivityFilters'
</file>

<file path="frontend/src/components/features/auth/ChangePassword.jsx">
import React, { useState } from 'react'
import { useAuth, useNotification } from '@contexts'
import { useNavigate } from 'react-router-dom'
import { Input, Button, Card, Alert } from '@components/common'
import { Lock, Check } from 'lucide-react'
import { validatePassword } from '@utils'

const ChangePassword = ({ forceChange = false }) => {
  const [currentPassword, setCurrentPassword] = useState('')
  const [newPassword, setNewPassword] = useState('')
  const [confirmPassword, setConfirmPassword] = useState('')
  const [loading, setLoading] = useState(false)
  const [errors, setErrors] = useState({})
  const [passwordStrength, setPasswordStrength] = useState(null)
  
  const { changePassword } = useAuth()
  const { success, error: notifyError } = useNotification()
  const navigate = useNavigate()
  
  const handleNewPasswordChange = (value) => {
    setNewPassword(value)
    
    if (value) {
      const validation = validatePassword(value)
      setPasswordStrength(validation)
    } else {
      setPasswordStrength(null)
    }
  }
  
  const validateForm = () => {
    const newErrors = {}
    
    if (!currentPassword) {
      newErrors.currentPassword = 'Current password is required'
    }
    
    if (!newPassword) {
      newErrors.newPassword = 'New password is required'
    } else {
      const validation = validatePassword(newPassword)
      if (!validation.isValid) {
        newErrors.newPassword = validation.errors[0]
      }
    }
    
    if (!confirmPassword) {
      newErrors.confirmPassword = 'Please confirm your new password'
    } else if (newPassword !== confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match'
    }
    
    setErrors(newErrors)
    return Object.keys(newErrors).length === 0
  }
  
  const handleSubmit = async (e) => {
    e.preventDefault()
    
    if (!validateForm()) {
      return
    }
    
    setLoading(true)
    
    try {
      const result = await changePassword(currentPassword, newPassword)
      
      if (result.success) {
        success('Password changed successfully!')
        setCurrentPassword('')
        setNewPassword('')
        setConfirmPassword('')
        setPasswordStrength(null)
        
        if (forceChange) {
          navigate('/dashboard')
        }
      } else {
        notifyError(result.error || 'Failed to change password')
        setErrors({ currentPassword: result.error })
      }
    } catch (err) {
      notifyError('An unexpected error occurred')
    } finally {
      setLoading(false)
    }
  }
  
  return (
    <div className="page">
      <div className="page-container max-w-2xl">
        <Card
          title={forceChange ? 'Password Change Required' : 'Change Password'}
          subtitle={forceChange ? 'You must change your password before continuing' : 'Update your account password'}
        >
          {forceChange && (
            <Alert
              type="warning"
              message="For security reasons, you must change your password before accessing the system."
              className="mb-4"
            />
          )}
          
          <form onSubmit={handleSubmit} className="space-y-4">
            <Input
              label="Current Password"
              type="password"
              value={currentPassword}
              onChange={(e) => setCurrentPassword(e.target.value)}
              placeholder="Enter current password"
              required
              disabled={loading}
              error={errors.currentPassword}
              icon={Lock}
            />
            
            <Input
              label="New Password"
              type="password"
              value={newPassword}
              onChange={(e) => handleNewPasswordChange(e.target.value)}
              placeholder="Enter new password"
              required
              disabled={loading}
              error={errors.newPassword}
              icon={Lock}
            />
            
            {passwordStrength && (
              <div className="password-requirements">
                <h4 className="text-sm font-medium mb-2">Password Requirements:</h4>
                <ul className="space-y-1">
                  <li className={newPassword.length >= 8 ? 'text-success' : 'text-gray-500'}>
                    <Check size={14} className="inline mr-1" />
                    At least 8 characters
                  </li>
                  <li className={/[a-z]/.test(newPassword) ? 'text-success' : 'text-gray-500'}>
                    <Check size={14} className="inline mr-1" />
                    One lowercase letter
                  </li>
                  <li className={/[A-Z]/.test(newPassword) ? 'text-success' : 'text-gray-500'}>
                    <Check size={14} className="inline mr-1" />
                    One uppercase letter
                  </li>
                  <li className={/\d/.test(newPassword) ? 'text-success' : 'text-gray-500'}>
                    <Check size={14} className="inline mr-1" />
                    One number
                  </li>
                  <li className={/[!@#$%^&*(),.?":{}|<>]/.test(newPassword) ? 'text-success' : 'text-gray-500'}>
                    <Check size={14} className="inline mr-1" />
                    One special character
                  </li>
                </ul>
              </div>
            )}
            
            <Input
              label="Confirm New Password"
              type="password"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              placeholder="Confirm new password"
              required
              disabled={loading}
              error={errors.confirmPassword}
              icon={Lock}
            />
            
            <div className="form-actions">
              <Button
                type="submit"
                variant="primary"
                size="lg"
                loading={loading}
                disabled={loading}
                className="w-full"
              >
                Change Password
              </Button>
              
              {!forceChange && (
                <Button
                  type="button"
                  variant="secondary"
                  size="lg"
                  onClick={() => navigate('/dashboard')}
                  disabled={loading}
                  className="w-full"
                >
                  Cancel
                </Button>
              )}
            </div>
          </form>
        </Card>
      </div>
    </div>
  )
}

export default ChangePassword
</file>

<file path="frontend/src/components/features/auth/index.js">
export { default as Login } from './Login'
export { default as ChangePassword } from './ChangePassword'
</file>

<file path="frontend/src/components/features/auth/Login.jsx">
import React, { useState, useEffect } from 'react'
import { useAuth, useNotification } from '@contexts'
import { Input, Button, Alert } from '@components/common'
import { LogIn, User, Lock, Eye, EyeOff } from 'lucide-react'

const Login = () => {
  const [username, setUsername] = useState('')
  const [password, setPassword] = useState('')
  const [showPassword, setShowPassword] = useState(false)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState('')
  
  const { login } = useAuth()
  const { error: notifyError } = useNotification()
  
  useEffect(() => {
    // Clear any existing tokens on login page
    localStorage.removeItem('sentinel_token')
  }, [])
  
  const handleSubmit = async (e) => {
    e.preventDefault()
    setError('')
    setLoading(true)
    
    try {
      const result = await login(username, password)
      
      if (!result.success) {
        setError(result.error || 'Login failed. Please check your credentials.')
        notifyError(result.error || 'Login failed')
      }
    } catch (err) {
      setError('An unexpected error occurred. Please try again.')
      notifyError('An unexpected error occurred')
    } finally {
      setLoading(false)
    }
  }
  
  return (
    <div className="login-page">
      <div className="login-container">
        <div className="login-card">
          {/* Logo Section */}
          <div className="login-header">
            <div className="login-logo">S</div>
            <h1 className="login-title">Sentinel</h1>
            <p className="login-subtitle">Employee Monitoring System</p>
          </div>
          
          {/* Login Form */}
          <form onSubmit={handleSubmit} className="login-form">
            {error && (
              <Alert
                type="error"
                message={error}
                onClose={() => setError('')}
              />
            )}
            
            <Input
              label="Username"
              type="text"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              placeholder="Enter your username"
              required
              disabled={loading}
              icon={User}
              autoComplete="username"
            />
            
            <div className="form-group">
              <label className="form-label">Password</label>
              <div className="password-input-wrapper">
                <Input
                  type={showPassword ? 'text' : 'password'}
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  placeholder="Enter your password"
                  required
                  disabled={loading}
                  icon={Lock}
                  autoComplete="current-password"
                />
                <button
                  type="button"
                  className="password-toggle"
                  onClick={() => setShowPassword(!showPassword)}
                  tabIndex={-1}
                >
                  {showPassword ? <EyeOff size={18} /> : <Eye size={18} />}
                </button>
              </div>
            </div>
            
            <Button
              type="submit"
              variant="primary"
              size="lg"
              loading={loading}
              disabled={loading || !username || !password}
              icon={LogIn}
              className="w-full"
            >
              Sign In
            </Button>
          </form>
          
          {/* Information */}
          <div className="login-footer">
            <div className="login-info">
              <h4>Security Notice</h4>
              <ul className="login-info-list">
                <li>Strong passwords required (8+ chars, uppercase, lowercase, numbers, special chars)</li>
                <li>Your session will expire after 24 hours of inactivity</li>
                <li>All login attempts are logged for security</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

export default Login
</file>

<file path="frontend/src/components/features/clients/ClientDetails.jsx">
import React from 'react'
import { useActivities } from '@hooks'
import { Table, LoadingSpinner } from '@components/common'
import { formatDate, formatClientType, formatRelativeTime } from '@utils'
import { Monitor, HardDrive, Cpu, Calendar } from 'lucide-react'

const ClientDetails = ({ client, onClose }) => {
  const { activities, loading } = useActivities(true, {
    client_id: client.client_id,
    limit: 20
  })
  
  const activityColumns = [
    {
      key: 'timestamp',
      header: 'Time',
      width: '20%',
      render: (activity) => formatRelativeTime(activity.timestamp)
    },
    {
      key: 'active_application',
      header: 'Application',
      width: '25%',
      render: (activity) => activity.active_application || 'Unknown'
    },
    {
      key: 'category',
      header: 'Category',
      width: '15%',
      render: (activity) => (
        <span className={`badge badge-${activity.activity_category || 'other'}`}>
          {activity.activity_category || 'other'}
        </span>
      )
    },
    {
      key: 'productivity',
      header: 'Productivity',
      width: '15%',
      render: (activity) => 
        activity.productivity_score ? `${activity.productivity_score}%` : 'N/A'
    },
    {
      key: 'processes',
      header: 'Processes',
      width: '15%',
      render: (activity) => `${activity.process_count || 0}`
    }
  ]
  
  return (
    <div className="client-details">
      {/* Client Information */}
      <div className="detail-section">
        <h3 className="detail-section-title">
          <Monitor size={20} />
          Client Information
        </h3>
        <div className="detail-grid">
          <div className="detail-item">
            <label>Client ID</label>
            <span className="font-mono">{client.client_id}</span>
          </div>
          <div className="detail-item">
            <label>Type</label>
            <span>{formatClientType(client.client_type)}</span>
          </div>
          <div className="detail-item">
            <label>Hostname</label>
            <span>{client.hostname || 'Unknown'}</span>
          </div>
          <div className="detail-item">
            <label>IP Address</label>
            <span>{client.ip_address || 'Unknown'}</span>
          </div>
          <div className="detail-item">
            <label>Last Seen</label>
            <span>{formatRelativeTime(client.last_seen)}</span>
          </div>
          <div className="detail-item">
            <label>Created</label>
            <span>{formatDate(client.created_at, 'PP')}</span>
          </div>
          <div className="detail-item">
            <label>Status</label>
            <span className={new Date(client.last_seen) > new Date(Date.now() - 5 * 60 * 1000) 
              ? 'text-success' 
              : 'text-error'
            }>
              {new Date(client.last_seen) > new Date(Date.now() - 5 * 60 * 1000) 
                ? 'Online' 
                : 'Offline'}
            </span>
          </div>
          <div className="detail-item">
            <label>Consent</label>
            <span className={client.employee_consent ? 'text-success' : 'text-warning'}>
              {client.employee_consent ? 'Granted' : 'Not granted'}
            </span>
          </div>
        </div>
      </div>
      
      {/* Platform Information */}
      {client.platform_info && (
        <div className="detail-section">
          <h3 className="detail-section-title">
            <HardDrive size={20} />
            Platform Information
          </h3>
          <div className="detail-grid">
            <div className="detail-item">
              <label>System</label>
              <span>{client.platform_info.system || 'Unknown'}</span>
            </div>
            <div className="detail-item">
              <label>Release</label>
              <span>{client.platform_info.release || 'Unknown'}</span>
            </div>
            <div className="detail-item">
              <label>Architecture</label>
              <span>{client.platform_info.architecture || 'Unknown'}</span>
            </div>
            <div className="detail-item">
              <label>Processor</label>
              <span>{client.platform_info.processor || 'Unknown'}</span>
            </div>
            {client.platform_info.memory_total_gb && (
              <div className="detail-item">
                <label>Total Memory</label>
                <span>{client.platform_info.memory_total_gb} GB</span>
              </div>
            )}
            {client.platform_info.disk_total_gb && (
              <div className="detail-item">
                <label>Total Disk</label>
                <span>{client.platform_info.disk_total_gb} GB</span>
              </div>
            )}
          </div>
        </div>
      )}
      
      {/* Recent Activities */}
      <div className="detail-section">
        <h3 className="detail-section-title">
          <Calendar size={20} />
          Recent Activities
        </h3>
        {loading ? (
          <LoadingSpinner text="Loading activities..." />
        ) : (
          <Table
            columns={activityColumns}
            data={activities}
            emptyMessage="No recent activities"
          />
        )}
      </div>
    </div>
  )
}

export default ClientDetails
</file>

<file path="frontend/src/components/features/clients/ClientsList.jsx">
import React, { useState } from 'react'
import { useClients } from '@hooks'
import { Card, Table, LoadingSpinner, Button, Modal } from '@components/common'
import { formatRelativeTime, formatClientType } from '@utils'
import { Monitor, RefreshCw, Eye } from 'lucide-react'
import ClientDetails from './ClientDetails'

const ClientsList = () => {
  const [selectedClient, setSelectedClient] = useState(null)
  const [showDetails, setShowDetails] = useState(false)
  const [filter, setFilter] = useState('all') // all, online, offline
  
  const { clients, loading, error, refetch } = useClients(true, {
    is_active: filter === 'all' ? undefined : true
  })
  
  const handleViewClient = (client) => {
    setSelectedClient(client)
    setShowDetails(true)
  }
  
  const handleCloseDetails = () => {
    setShowDetails(false)
    setSelectedClient(null)
  }
  
  const getStatusBadge = (lastSeen) => {
    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000)
    const isOnline = new Date(lastSeen) > fiveMinutesAgo
    
    return (
      <span className={`status-badge ${isOnline ? 'status-online' : 'status-offline'}`}>
        {isOnline ? 'Online' : 'Offline'}
      </span>
    )
  }
  
  const filteredClients = filter === 'online'
    ? clients.filter(c => new Date(c.last_seen) > new Date(Date.now() - 5 * 60 * 1000))
    : filter === 'offline'
    ? clients.filter(c => new Date(c.last_seen) <= new Date(Date.now() - 5 * 60 * 1000))
    : clients
  
  const columns = [
    {
      key: 'client_id',
      header: 'Client ID',
      width: '25%',
      render: (client) => (
        <span className="font-mono text-sm">{client.client_id}</span>
      )
    },
    {
      key: 'client_type',
      header: 'Type',
      width: '15%',
      render: (client) => formatClientType(client.client_type)
    },
    {
      key: 'hostname',
      header: 'Hostname',
      width: '20%',
      render: (client) => client.hostname || 'Unknown'
    },
    {
      key: 'last_seen',
      header: 'Last Seen',
      width: '20%',
      render: (client) => formatRelativeTime(client.last_seen)
    },
    {
      key: 'status',
      header: 'Status',
      width: '10%',
      render: (client) => getStatusBadge(client.last_seen)
    },
    {
      key: 'actions',
      header: 'Actions',
      width: '10%',
      sortable: false,
      render: (client) => (
        <Button
          variant="secondary"
          size="sm"
          icon={Eye}
          onClick={() => handleViewClient(client)}
        >
          View
        </Button>
      )
    }
  ]
  
  return (
    <>
      <Card
        title="Connected Clients"
        subtitle={`${filteredClients.length} client${filteredClients.length !== 1 ? 's' : ''}`}
        actions={
          <div className="flex gap-2">
            <div className="filter-buttons">
              <button
                className={`filter-btn ${filter === 'all' ? 'active' : ''}`}
                onClick={() => setFilter('all')}
              >
                All
              </button>
              <button
                className={`filter-btn ${filter === 'online' ? 'active' : ''}`}
                onClick={() => setFilter('online')}
              >
                Online
              </button>
              <button
                className={`filter-btn ${filter === 'offline' ? 'active' : ''}`}
                onClick={() => setFilter('offline')}
              >
                Offline
              </button>
            </div>
            
            <Button
              variant="secondary"
              size="sm"
              icon={RefreshCw}
              onClick={refetch}
              disabled={loading}
            >
              Refresh
            </Button>
          </div>
        }
      >
        {loading ? (
          <LoadingSpinner text="Loading clients..." />
        ) : error ? (
          <div className="error-state">
            <p>Failed to load clients: {error}</p>
          </div>
        ) : (
          <Table
            columns={columns}
            data={filteredClients}
            emptyMessage="No clients found"
          />
        )}
      </Card>
      
      {showDetails && selectedClient && (
        <Modal
          isOpen={showDetails}
          onClose={handleCloseDetails}
          title="Client Details"
          size="xl"
        >
          <ClientDetails client={selectedClient} onClose={handleCloseDetails} />
        </Modal>
      )}
    </>
  )
}

export default ClientsList
</file>

<file path="frontend/src/components/features/clients/ClientStats.jsx">
import React from 'react'
import { useClientStats } from '@hooks'
import { Card, LoadingSpinner } from '@components/common'
import { PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip } from 'recharts'

const COLORS = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6']

const ClientStats = () => {
  const { stats, loading, error } = useClientStats()
  
  if (loading) {
    return (
      <Card title="Client Statistics">
        <LoadingSpinner text="Loading statistics..." />
      </Card>
    )
  }
  
  if (error) {
    return (
      <Card title="Client Statistics">
        <div className="error-state">
          <p>Failed to load statistics: {error}</p>
        </div>
      </Card>
    )
  }
  
  const chartData = Object.entries(stats?.clients_by_type || {}).map(([name, value]) => ({
    name: name.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase()),
    value
  }))
  
  return (
    <Card title="Client Distribution" subtitle="Clients by type">
      {chartData.length > 0 ? (
        <ResponsiveContainer width="100%" height={300}>
          <PieChart>
            <Pie
              data={chartData}
              cx="50%"
              cy="50%"
              labelLine={false}
              label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
              outerRadius={80}
              fill="#8884d8"
              dataKey="value"
            >
              {chartData.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Pie>
            <Tooltip />
            <Legend />
          </PieChart>
        </ResponsiveContainer>
      ) : (
        <div className="empty-state">
          <p>No client data available</p>
        </div>
      )}
    </Card>
  )
}

export default ClientStats
</file>

<file path="frontend/src/components/features/clients/index.js">
export { default as ClientsList } from './ClientsList'
export { default as ClientDetails } from './ClientDetails'
export { default as ClientStats } from './ClientStats'
</file>

<file path="frontend/src/components/features/dashboard/Dashboard.jsx">
import React from 'react'
import StatsCards from './StatsCards'
import RecentActivity from './RecentActivity'

const Dashboard = () => {
  return (
    <div className="page">
      <div className="page-header">
        <h2>Dashboard</h2>
        <p>Overview of your monitoring system</p>
      </div>
      
      <div className="dashboard-content">
        <StatsCards />
        <RecentActivity />
      </div>
    </div>
  )
}

export default Dashboard
</file>

<file path="frontend/src/components/features/dashboard/index.js">
export { default as Dashboard } from './Dashboard'
export { default as StatsCards } from './StatsCards'
export { default as RecentActivity } from './RecentActivity'
</file>

<file path="frontend/src/components/features/dashboard/RecentActivity.jsx">
import React from 'react'
import { useActivities } from '@hooks'
import { Card, Table, LoadingSpinner } from '@components/common'
import { formatRelativeTime, formatClientType, truncateText } from '@utils'
import { ExternalLink } from 'lucide-react'

const RecentActivity = () => {
  const { activities, loading, error, refetch } = useActivities(true, { limit: 10 })
  
  const columns = [
    {
      key: 'timestamp',
      header: 'Time',
      width: '15%',
      render: (activity) => formatRelativeTime(activity.timestamp)
    },
    {
      key: 'client_id',
      header: 'Client',
      width: '20%',
      render: (activity) => (
        <span className="font-mono text-sm">{activity.client_id}</span>
      )
    },
    {
      key: 'active_application',
      header: 'Application',
      width: '20%',
      render: (activity) => activity.active_application || 'Unknown'
    },
    {
      key: 'active_window',
      header: 'Window Title',
      width: '30%',
      render: (activity) => truncateText(activity.active_window || 'No active window', 50)
    },
    {
      key: 'category',
      header: 'Category',
      width: '15%',
      render: (activity) => (
        <span className={`badge badge-${activity.activity_category || 'other'}`}>
          {activity.activity_category || 'other'}
        </span>
      )
    }
  ]
  
  return (
    <Card
      title="Recent Activity"
      subtitle="Latest activity from all clients"
      actions={
        <button 
          onClick={refetch}
          className="btn btn-secondary btn-sm"
          disabled={loading}
        >
          Refresh
        </button>
      }
    >
      {loading ? (
        <LoadingSpinner text="Loading activities..." />
      ) : error ? (
        <div className="error-state">
          <p>Failed to load activities: {error}</p>
        </div>
      ) : (
        <Table
          columns={columns}
          data={activities}
          emptyMessage="No recent activity"
        />
      )}
    </Card>
  )
}

export default RecentActivity
</file>

<file path="frontend/src/components/features/dashboard/StatsCards.jsx">
import React, { useEffect, useState } from 'react'
import { Monitor, Activity, TrendingUp, Clock } from 'lucide-react'
import { useClientStats, useActivityStats } from '@hooks'
import { LoadingSpinner, Card } from '@components/common'
import { formatNumber } from '@utils'

const StatsCards = () => {
  const { stats: clientStats, loading: clientsLoading } = useClientStats()
  const { stats: activityStats, loading: activitiesLoading } = useActivityStats({ days: 7 })
  
  const loading = clientsLoading || activitiesLoading
  
  const stats = [
    {
      title: 'Total Clients',
      value: clientStats?.total_clients || 0,
      icon: Monitor,
      color: 'blue',
      description: 'Registered devices'
    },
    {
      title: 'Online Now',
      value: clientStats?.online_clients || 0,
      icon: Activity,
      color: 'green',
      description: 'Active in last 5 minutes'
    },
    {
      title: 'Activities (7d)',
      value: activityStats?.total_activities || 0,
      icon: TrendingUp,
      color: 'purple',
      description: 'Last 7 days'
    },
    {
      title: 'Avg Productivity',
      value: activityStats?.avg_productivity ? `${formatNumber(activityStats.avg_productivity, 1)}%` : 'N/A',
      icon: Clock,
      color: 'orange',
      description: 'Based on activity analysis'
    }
  ]
  
  if (loading) {
    return (
      <div className="stats-loading">
        <LoadingSpinner text="Loading statistics..." />
      </div>
    )
  }
  
  return (
    <div className="stats-grid">
      {stats.map((stat, index) => (
        <Card key={index} className="stat-card">
          <div className="stat-card-content">
            <div className={`stat-icon stat-icon-${stat.color}`}>
              <stat.icon size={24} />
            </div>
            <div className="stat-info">
              <p className="stat-label">{stat.title}</p>
              <h3 className="stat-value">{stat.value}</h3>
              <p className="stat-description">{stat.description}</p>
            </div>
          </div>
        </Card>
      ))}
    </div>
  )
}

export default StatsCards
</file>

<file path="frontend/src/components/features/settings/ApiKeys.jsx">
import React, { useState, useEffect } from 'react'
import { authService } from '@services'
import { Card, Table, Button, Modal, Input, Alert } from '@components/common'
import { useNotification } from '@contexts'
import { formatDate, copyToClipboard } from '@utils'
import { Key, Plus, Trash2, Copy, Check } from 'lucide-react'

const ApiKeys = () => {
  const [apiKeys, setApiKeys] = useState([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)
  const [showCreateModal, setShowCreateModal] = useState(false)
  const [newKeyName, setNewKeyName] = useState('')
  const [creating, setCreating] = useState(false)
  const [newKeyData, setNewKeyData] = useState(null)
  const [copiedKey, setCopiedKey] = useState(false)
  
  const { success, error: notifyError } = useNotification()
  
  useEffect(() => {
    console.log('ApiKeys component mounted')
    loadApiKeys()
  }, [])
  
  const loadApiKeys = async () => {
    console.log('Loading API keys...')
    setLoading(true)
    setError(null)
    
    try {
      const result = await authService.getApiKeys()
      console.log('API Keys result:', result)
      
      if (result.success) {
        setApiKeys(result.apiKeys || [])
      } else {
        const errorMsg = result.error || 'Failed to load API keys'
        setError(errorMsg)
        notifyError(errorMsg)
      }
    } catch (err) {
      console.error('Error loading API keys:', err)
      const errorMsg = err.message || 'Failed to load API keys'
      setError(errorMsg)
      notifyError(errorMsg)
    } finally {
      setLoading(false)
    }
  }
  
  const handleCreateKey = async () => {
    if (!newKeyName.trim()) {
      notifyError('Please enter a name for the API key')
      return
    }
    
    setCreating(true)
    const result = await authService.createApiKey(newKeyName.trim())
    
    if (result.success) {
      setNewKeyData(result.apiKey)
      setNewKeyName('')
      loadApiKeys()
      success('API key created successfully')
    } else {
      notifyError(result.error || 'Failed to create API key')
      setShowCreateModal(false)
    }
    setCreating(false)
  }
  
  const handleCopyKey = async (key) => {
    const result = await copyToClipboard(key)
    if (result.success) {
      setCopiedKey(true)
      success('API key copied to clipboard')
      setTimeout(() => setCopiedKey(false), 2000)
    } else {
      notifyError('Failed to copy API key')
    }
  }
  
  const handleRevokeKey = async (keyId, keyName) => {
    if (!window.confirm(`Are you sure you want to revoke the API key "${keyName}"? This action cannot be undone.`)) {
      return
    }
    
    const result = await authService.revokeApiKey(keyId)
    
    if (result.success) {
      loadApiKeys()
      success('API key revoked successfully')
    } else {
      notifyError(result.error || 'Failed to revoke API key')
    }
  }
  
  const handleCloseNewKeyModal = () => {
    setNewKeyData(null)
    setShowCreateModal(false)
  }
  
  const columns = [
    {
      key: 'name',
      header: 'Name',
      width: '25%'
    },
    {
      key: 'key_prefix',
      header: 'Key Prefix',
      width: '15%',
      render: (apiKey) => (
        <span className="font-mono text-sm">{apiKey.key_prefix}...</span>
      )
    },
    {
      key: 'usage_count',
      header: 'Usage Count',
      width: '15%',
      render: (apiKey) => apiKey.usage_count.toLocaleString()
    },
    {
      key: 'last_used',
      header: 'Last Used',
      width: '20%',
      render: (apiKey) => apiKey.last_used ? formatDate(apiKey.last_used, 'PPp') : 'Never'
    },
    {
      key: 'created_at',
      header: 'Created',
      width: '15%',
      render: (apiKey) => formatDate(apiKey.created_at, 'PP')
    },
    {
      key: 'actions',
      header: '',
      width: '10%',
      sortable: false,
      render: (apiKey) => (
        <Button
          variant="danger"
          size="sm"
          icon={Trash2}
          onClick={() => handleRevokeKey(apiKey.id, apiKey.name)}
        >
          Revoke
        </Button>
      )
    }
  ]
  
  console.log('Render state:', { loading, error, apiKeysCount: apiKeys.length })
  
  if (loading) {
    return (
      <Card title="API Keys">
        <div className="loading-spinner">
          <p>Loading API keys...</p>
        </div>
      </Card>
    )
  }
  
  if (error) {
    return (
      <Card title="API Keys">
        <Alert
          type="error"
          title="Error Loading API Keys"
          message={error}
        />
        <div className="mt-4">
          <Button onClick={loadApiKeys}>
            Retry
          </Button>
        </div>
      </Card>
    )
  }
  
  return (
    <>
      <Card
        title="API Keys"
        subtitle="Manage API keys for monitoring clients"
        actions={
          <Button
            variant="primary"
            icon={Plus}
            onClick={() => setShowCreateModal(true)}
          >
            Create API Key
          </Button>
        }
      >
        <Alert
          type="info"
          message="API keys are used by monitoring clients to authenticate with the server. Keep them secure and never share them publicly."
          className="mb-4"
        />
        
        <Table
          columns={columns}
          data={apiKeys}
          loading={loading}
          emptyMessage="No API keys created yet"
        />
      </Card>
      
      {/* Create API Key Modal */}
      <Modal
        isOpen={showCreateModal && !newKeyData}
        onClose={() => setShowCreateModal(false)}
        title="Create New API Key"
        size="md"
      >
        <div className="space-y-4">
          <Input
            label="Key Name"
            placeholder="e.g., Production Server 1"
            value={newKeyName}
            onChange={(e) => setNewKeyName(e.target.value)}
            helperText="Choose a descriptive name to identify this key"
            autoFocus
          />
          
          <div className="form-actions">
            <Button
              variant="secondary"
              onClick={() => setShowCreateModal(false)}
              disabled={creating}
            >
              Cancel
            </Button>
            <Button
              variant="primary"
              onClick={handleCreateKey}
              loading={creating}
              disabled={creating || !newKeyName.trim()}
            >
              Create Key
            </Button>
          </div>
        </div>
      </Modal>
      
      {/* New API Key Display Modal */}
      <Modal
        isOpen={!!newKeyData}
        onClose={handleCloseNewKeyModal}
        title="API Key Created"
        size="md"
        closeOnOverlayClick={false}
      >
        <div className="space-y-4">
          <Alert
            type="warning"
            title="Important!"
            message="This is the only time you will see this API key. Make sure to copy it now and store it securely."
          />
          
          <div className="detail-item">
            <label>Key Name</label>
            <span>{newKeyData?.name}</span>
          </div>
          
          <div className="detail-item">
            <label>API Key</label>
            <div className="flex gap-2">
              <code className="flex-1 p-3 bg-gray-100 rounded font-mono text-sm break-all">
                {newKeyData?.key}
              </code>
              <Button
                variant="secondary"
                icon={copiedKey ? Check : Copy}
                onClick={() => handleCopyKey(newKeyData?.key)}
                disabled={copiedKey}
              >
                {copiedKey ? 'Copied' : 'Copy'}
              </Button>
            </div>
          </div>
          
          <div className="detail-item">
            <label>Usage Instructions</label>
            <div className="text-sm text-gray-600 space-y-2">
              <p>Use this API key in your monitoring client configuration:</p>
              <pre className="p-3 bg-gray-100 rounded overflow-auto">
{`{
  "api_key": "${newKeyData?.key}",
  "server_url": "${window.location.origin}"
}`}
              </pre>
            </div>
          </div>
          
          <div className="form-actions">
            <Button
              variant="primary"
              onClick={handleCloseNewKeyModal}
              className="w-full"
            >
              I've Saved the Key
            </Button>
          </div>
        </div>
      </Modal>
    </>
  )
}

export default ApiKeys
</file>

<file path="frontend/src/components/features/settings/index.js">
export { default as ApiKeys } from './ApiKeys'
export { default as SecuritySettings } from './SecuritySettings'
</file>

<file path="frontend/src/components/features/settings/SecuritySettings.jsx">
import React from 'react'
import ChangePassword from '../auth/ChangePassword'

const SecuritySettings = () => {
  return (
    <div className="page">
      <div className="page-header">
        <h2>Security Settings</h2>
        <p>Manage your account security and password</p>
      </div>
      
      <ChangePassword forceChange={false} />
    </div>
  )
}

export default SecuritySettings
</file>

<file path="frontend/src/components/layout/Header.jsx">
import React from 'react'
import { Menu, LogOut, User, Bell } from 'lucide-react'
import { useAuth } from '@contexts'

const Header = ({ onMenuClick }) => {
  const { user, logout } = useAuth()
  
  return (
    <header className="header">
      <div className="header-left">
        <button className="menu-button" onClick={onMenuClick}>
          <Menu size={24} />
        </button>
        
        <div className="header-brand">
          <div className="brand-logo">S</div>
          <div className="brand-info">
            <h1 className="brand-name">Sentinel</h1>
            <span className="brand-subtitle">Monitoring System</span>
          </div>
        </div>
      </div>
      
      <div className="header-right">
        <button className="header-icon-button">
          <Bell size={20} />
        </button>
        
        <div className="user-menu">
          <div className="user-info">
            <User size={18} />
            <div className="user-details">
              <span className="user-name">{user?.username}</span>
              <span className="user-role">{user?.is_admin ? 'Administrator' : 'User'}</span>
            </div>
          </div>
          
          <button className="logout-button" onClick={logout} title="Logout">
            <LogOut size={18} />
          </button>
        </div>
      </div>
    </header>
  )
}

export default Header
</file>

<file path="frontend/src/components/layout/index.js">
export { default as Header } from './Header'
export { default as Sidebar } from './Sidebar'
export { default as Layout } from './Layout'
</file>

<file path="frontend/src/components/layout/Layout.jsx">
import React, { useState, useEffect } from 'react'
import { Outlet } from 'react-router-dom'
// Assuming Header is in the same directory and exports correctly
// FIX: Added .jsx extension to resolve import errors
import Header from './Header.jsx' 
import Sidebar from './Sidebar.jsx'

const Layout = () => {
  // Initialize based on screen width: Open on Desktop (>1024px), Closed on Mobile
  const [sidebarOpen, setSidebarOpen] = useState(window.innerWidth > 1024)
  
  // Add resize listener to handle responsive changes automatically
  useEffect(() => {
    const handleResize = () => {
      // If resizing to mobile width, ensure it's closed (to prevent trapping the user)
      if (window.innerWidth <= 1024) {
        setSidebarOpen(false)
      } else {
        // If resizing to desktop width, ensure it's open by default
        setSidebarOpen(true)
      }
    }
    
    window.addEventListener('resize', handleResize)
    return () => window.removeEventListener('resize', handleResize)
  }, [])
  
  const toggleSidebar = () => {
    setSidebarOpen(!sidebarOpen)
  }
  
  const closeSidebar = () => {
    setSidebarOpen(false)
  }
  
  return (
    <div className="app-layout">
      {/* The sidebar component */}
      <Sidebar 
        isOpen={sidebarOpen} 
        onClose={closeSidebar} 
        onToggle={toggleSidebar} 
      />
      
      {/* Main content area */}
      <div className="app-main">
        {/* Header needs to know how to toggle the sidebar (for mobile/global menu button) */}
        <Header onMenuClick={toggleSidebar} />
        
        <main className="app-content">
          {/* Renders child routes */}
          <Outlet />
        </main>
      </div>
    </div>
  )
}

export default Layout
</file>

<file path="frontend/src/components/layout/Sidebar.jsx">
import React from 'react'
import { NavLink } from 'react-router-dom'
import { useAuth } from '@contexts' 
import {
  LayoutDashboard,
  Monitor,
  Activity,
  Key,
  Settings,
  X,
  PanelLeftClose
} from 'lucide-react'

const Sidebar = ({ isOpen, onClose, onToggle }) => {
  const { user } = useAuth()
  
  const navItems = [
    {
      to: '/dashboard',
      icon: LayoutDashboard,
      label: 'Dashboard'
    },
    {
      to: '/clients',
      icon: Monitor,
      label: 'Clients'
    },
    {
      to: '/activities',
      icon: Activity,
      label: 'Activities'
    },
    // Safe optional chaining handles cases where user is null (not logged in)
    ...(user?.is_admin ? [{
      to: '/api-keys',
      icon: Key,
      label: 'API Keys'
    }] : []),
    {
      to: '/settings',
      icon: Settings,
      label: 'Settings'
    }
  ]
  
  return (
    <>
      <div 
        className={`sidebar-overlay ${isOpen ? 'active' : ''}`}
        onClick={onClose}
      />
      
      <aside className={`sidebar ${isOpen ? 'open' : 'closed'}`}>
        <div className="sidebar-header">
          <h2 className="sidebar-title">Navigation</h2>
          
          <button 
            className="sidebar-toggle" 
            onClick={onToggle} 
            title="Collapse Sidebar"
          >
            <PanelLeftClose size={20} />
          </button>

          <button className="sidebar-close-mobile" onClick={onClose}>
            <X size={24} />
          </button>
        </div>
        
        <nav className="sidebar-nav">
          {navItems.map((item) => (
            <NavLink
              key={item.to}
              to={item.to}
              className={({ isActive }) => 
                `nav-item ${isActive ? 'active' : ''}`
              }
              onClick={() => {
                if (window.innerWidth <= 1024) onClose()
              }}
            >
              <item.icon className="nav-icon" size={20} />
              <span className="nav-label">{item.label}</span>
            </NavLink>
          ))}
        </nav>
        
        <div className="sidebar-footer">
          <div className="sidebar-info">
            <p className="text-sm text-gray-500">Sentinel v2.0.0</p>
            <p className="text-xs text-gray-400">© 2024 All rights reserved</p>
          </div>
        </div>
      </aside>
    </>
  )
}

export default Sidebar
</file>

<file path="frontend/src/components/ui/Button.jsx">
import React from 'react'

const Button = ({ 
  children, 
  variant = 'primary',
  size = 'md',
  disabled = false,
  loading = false,
  onClick,
  type = 'button',
  className = '',
  ...props 
}) => {
  const baseClasses = 'btn inline-flex items-center justify-center transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2'
  
  const variants = {
    primary: 'bg-primary-500 text-white hover:bg-primary-600 focus:ring-primary-500',
    danger: 'bg-error-500 text-white hover:bg-error-600 focus:ring-error-500',
    success: 'bg-success-500 text-white hover:bg-success-600 focus:ring-success-500',
    outline: 'border border-gray-300 text-gray-700 hover:bg-gray-50 focus:ring-primary-500'
  }
  
  const sizes = {
    sm: 'px-3 py-1.5 text-sm',
    md: 'px-4 py-2 text-base',
    lg: 'px-6 py-3 text-lg'
  }
  
  const classes = `
    ${baseClasses}
    ${variants[variant]}
    ${sizes[size]}
    ${disabled || loading ? 'opacity-50 cursor-not-allowed' : ''}
    ${className}
  `.trim()

  return (
    <button
      type={type}
      className={classes}
      disabled={disabled || loading}
      onClick={onClick}
      {...props}
    >
      {loading && (
        <svg className="animate-spin -ml-1 mr-2 h-4 w-4" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
      )}
      {children}
    </button>
  )
}

export default Button
</file>

<file path="frontend/src/components/ui/Card.jsx">
import React from 'react'

const Card = ({ 
  children, 
  title,
  actions,
  className = ''
}) => {
  return (
    <div className={`card ${className}`}>
      {(title || actions) && (
        <div className="card-header flex items-center justify-between">
          {title && (
            <h3 className="text-lg font-semibold text-gray-900">
              {title}
            </h3>
          )}
          {actions && (
            <div className="flex items-center gap-2">
              {actions}
            </div>
          )}
        </div>
      )}
      <div className="card-content">
        {children}
      </div>
    </div>
  )
}

export default Card
</file>

<file path="frontend/src/components/ui/Input.jsx">
import React from 'react'

const Input = ({
  label,
  type = 'text',
  value,
  onChange,
  placeholder,
  disabled = false,
  error,
  className = '',
  ...props
}) => {
  return (
    <div className="form-group">
      {label && (
        <label className="form-label">
          {label}
        </label>
      )}
      <input
        type={type}
        value={value}
        onChange={onChange}
        placeholder={placeholder}
        disabled={disabled}
        className={`form-input ${error ? 'border-error-500' : ''} ${className}`}
        {...props}
      />
      {error && (
        <p className="text-error-500 text-sm mt-1">{error}</p>
      )}
    </div>
  )
}

export default Input
</file>

<file path="frontend/src/components/ui/LoadingSpinner.jsx">
import React from 'react'

const LoadingSpinner = ({ size = 'md', className = '' }) => {
  const sizes = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12'
  }

  return (
    <div className={`flex justify-center items-center ${className}`}>
      <div className={`animate-spin rounded-full border-2 border-gray-300 border-t-primary-500 ${sizes[size]}`}></div>
    </div>
  )
}

export default LoadingSpinner
</file>

<file path="frontend/src/components/ui/Modal.jsx">
import React from 'react'

const Modal = ({ 
  isOpen, 
  onClose, 
  title, 
  children,
  size = 'md'
}) => {
  if (!isOpen) return null

  const sizes = {
    sm: 'max-w-md',
    md: 'max-w-lg',
    lg: 'max-w-2xl',
    xl: 'max-w-4xl'
  }

  return (
    <div className="fixed inset-0 z-50 overflow-y-auto">
      <div className="flex items-center justify-center min-h-screen px-4 pt-4 pb-20 text-center sm:block sm:p-0">
        <div 
          className="fixed inset-0 transition-opacity bg-gray-500 bg-opacity-75"
          onClick={onClose}
        ></div>

        <div className={`relative inline-block w-full ${sizes[size]} p-6 px-4 pt-5 pb-4 overflow-hidden text-left align-bottom transition-all transform bg-white rounded-lg shadow-xl sm:my-8 sm:align-middle sm:p-6`}>
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-lg font-medium text-gray-900">
              {title}
            </h3>
            <button
              onClick={onClose}
              className="text-gray-400 hover:text-gray-600 transition-colors"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
          
          <div>
            {children}
          </div>
        </div>
      </div>
    </div>
  )
}

export default Modal
</file>

<file path="frontend/src/components/ui/Table.jsx">
import React from 'react'

const Table = ({ 
  columns, 
  data, 
  emptyMessage = 'No data available',
  className = ''
}) => {
  if (!data || data.length === 0) {
    return (
      <div className="empty-state">
        <p>{emptyMessage}</p>
      </div>
    )
  }

  return (
    <div className={`table-container ${className}`}>
      <table className="table">
        <thead>
          <tr>
            {columns.map((column, index) => (
              <th key={index} style={{ width: column.width }}>
                {column.header}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {data.map((row, rowIndex) => (
            <tr key={rowIndex}>
              {columns.map((column, colIndex) => (
                <td key={colIndex}>
                  {column.render ? column.render(row) : row[column.key]}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  )
}

export default Table
</file>

<file path="frontend/src/components/index.js">
// Common components
export * from './common'

// Layout components
export * from './layout'

// Feature components
export * from './features/auth'
export * from './features/dashboard'
export * from './features/clients'
export * from './features/activities'
export * from './features/settings'
</file>

<file path="frontend/src/contexts/AuthContext.jsx">
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react'
import { authService } from '@services'
import { useNavigate } from 'react-router-dom'

const AuthContext = createContext(null)

export const useAuth = () => {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  return context
}

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null)
  const [loading, setLoading] = useState(true)
  const [forcePasswordChange, setForcePasswordChange] = useState(false)
  const navigate = useNavigate()
  
  const loadUser = useCallback(async () => {
    try {
      const { success, user: userData } = await authService.getCurrentUser()
      if (success) {
        setUser(userData)
        setForcePasswordChange(userData.force_password_change)
      } else {
        setUser(null)
      }
    }
     catch (error) {
      console.error('Failed to load user:', error)
      setUser(null)
    } finally {
      setLoading(false)
    }
  }, [])
  
  useEffect(() => {
    loadUser()
  }, [loadUser])
  
  const login = async (username, password) => {
    try {
      const result = await authService.login(username, password)
      
      if (result.success) {
        await loadUser()
        setForcePasswordChange(result.forcePasswordChange)
        
        if (result.forcePasswordChange) {
          navigate('/change-password')
        } else {
          navigate('/dashboard')
        }
        
        return { success: true }
      }
      
      return { success: false, error: result.error }
    } catch (error) {
      return { success: false, error: 'Login failed' }
    }
  }
  
  const logout = async () => {
    await authService.logout()
    setUser(null)
    navigate('/login')
  }
  
  const changePassword = async (currentPassword, newPassword) => {
    const result = await authService.changePassword(currentPassword, newPassword)
    
    if (result.success) {
      setForcePasswordChange(false)
      await loadUser()
    }
    
    return result
  }
  
  const value = {
    user,
    loading,
    forcePasswordChange,
    isAuthenticated: !!user,
    isAdmin: user?.is_admin || false,
    login,
    logout,
    changePassword,
    refreshUser: loadUser
  }
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  )
}
</file>

<file path="frontend/src/contexts/index.js">
export { AuthProvider, useAuth } from './AuthContext'
export { NotificationProvider, useNotification } from './NotificationContext'
</file>

<file path="frontend/src/contexts/NotificationContext.jsx">
import React, { createContext, useContext, useState, useCallback } from 'react'

const NotificationContext = createContext(null)

export const useNotification = () => {
  const context = useContext(NotificationContext)
  if (!context) {
    throw new Error('useNotification must be used within NotificationProvider')
  }
  return context
}

export const NotificationProvider = ({ children }) => {
  const [notifications, setNotifications] = useState([])
  
  const addNotification = useCallback((message, type = 'info', duration = 5000) => {
    const id = Date.now() + Math.random()
    
    setNotifications(prev => [...prev, { id, message, type }])
    
    if (duration > 0) {
      setTimeout(() => {
        removeNotification(id)
      }, duration)
    }
    
    return id
  }, [])
  
  const removeNotification = useCallback((id) => {
    setNotifications(prev => prev.filter(notif => notif.id !== id))
  }, [])
  
  const success = useCallback((message, duration) => {
    return addNotification(message, 'success', duration)
  }, [addNotification])
  
  const error = useCallback((message, duration) => {
    return addNotification(message, 'error', duration)
  }, [addNotification])
  
  const warning = useCallback((message, duration) => {
    return addNotification(message, 'warning', duration)
  }, [addNotification])
  
  const info = useCallback((message, duration) => {
    return addNotification(message, 'info', duration)
  }, [addNotification])
  
  const value = {
    notifications,
    addNotification,
    removeNotification,
    success,
    error,
    warning,
    info
  }
  
  return (
    <NotificationContext.Provider value={value}>
      {children}
      <NotificationContainer notifications={notifications} onClose={removeNotification} />
    </NotificationContext.Provider>
  )
}

const NotificationContainer = ({ notifications, onClose }) => {
  if (notifications.length === 0) return null
  
  return (
    <div className="notification-container">
      {notifications.map(notification => (
        <div
          key={notification.id}
          className={`notification notification-${notification.type}`}
        >
          <div className="notification-content">
            <span>{notification.message}</span>
            <button
              className="notification-close"
              onClick={() => onClose(notification.id)}
            >
              ×
            </button>
          </div>
        </div>
      ))}
    </div>
  )
}
</file>

<file path="frontend/src/hooks/index.js">
export * from './useApi'
export * from './useClients'
export * from './useActivities'
</file>

<file path="frontend/src/hooks/useActivities.js">
import { useState, useEffect, useCallback, useRef } from 'react'
import { activitiesService } from '@services'

export const useActivities = (autoFetch = true, params = {}) => {
  const [activities, setActivities] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  const isMounted = useRef(true)
  const hasFetched = useRef(false)
  
  const fetchActivities = useCallback(async (fetchParams = {}) => {
    if (!isMounted.current) return
    
    try {
      setLoading(true)
      setError(null)
      
      const mergedParams = { ...params, ...fetchParams }
      const result = await activitiesService.getActivities(mergedParams)
      
      if (isMounted.current) {
        if (result.success) {
          setActivities(result.activities)
        } else {
          setError(result.error)
        }
      }
    } catch (err) {
      if (isMounted.current) {
        setError(err.message)
      }
    } finally {
      if (isMounted.current) {
        setLoading(false)
      }
    }
  }, []) // Empty - stable function
  
  useEffect(() => {
    isMounted.current = true
    
    if (autoFetch && !hasFetched.current) {
      hasFetched.current = true
      fetchActivities()
    }
    
    return () => {
      isMounted.current = false
    }
  }, []) // Empty - only run once on mount
  
  return {
    activities,
    loading,
    error,
    refetch: fetchActivities
  }
}

export const useActivity = (activityId) => {
  const [activity, setActivity] = useState(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  const isMounted = useRef(true)
  const lastFetchedId = useRef(null)
  
  const fetchActivity = useCallback(async () => {
    if (!activityId || !isMounted.current) return
    
    try {
      setLoading(true)
      setError(null)
      
      const result = await activitiesService.getActivity(activityId)
      
      if (isMounted.current) {
        if (result.success) {
          setActivity(result.activity)
        } else {
          setError(result.error)
        }
      }
    } catch (err) {
      if (isMounted.current) {
        setError(err.message)
      }
    } finally {
      if (isMounted.current) {
        setLoading(false)
      }
    }
  }, [activityId])
  
  useEffect(() => {
    isMounted.current = true
    
    // Only fetch if activityId changed
    if (activityId && activityId !== lastFetchedId.current) {
      lastFetchedId.current = activityId
      fetchActivity()
    }
    
    return () => {
      isMounted.current = false
    }
  }, [activityId]) // Only re-run if activityId changes
  
  return {
    activity,
    loading,
    error,
    refetch: fetchActivity
  }
}

export const useActivityStats = (params = {}) => {
  const [stats, setStats] = useState(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  const isMounted = useRef(true)
  const hasFetched = useRef(false)
  
  const fetchStats = useCallback(async (fetchParams = {}) => {
    if (!isMounted.current) return
    
    try {
      setLoading(true)
      setError(null)
      
      const mergedParams = { ...params, ...fetchParams }
      const result = await activitiesService.getActivityStats(mergedParams)
      
      if (isMounted.current) {
        if (result.success) {
          setStats(result.stats)
        } else {
          setError(result.error)
        }
      }
    } catch (err) {
      if (isMounted.current) {
        setError(err.message)
      }
    } finally {
      if (isMounted.current) {
        setLoading(false)
      }
    }
  }, []) // Empty - stable function
  
  useEffect(() => {
    isMounted.current = true
    
    if (!hasFetched.current) {
      hasFetched.current = true
      fetchStats()
    }
    
    return () => {
      isMounted.current = false
    }
  }, []) // Empty - only run once on mount
  
  return {
    stats,
    loading,
    error,
    refetch: fetchStats
  }
}
</file>

<file path="frontend/src/hooks/useApi.js">
import { useState, useCallback, useEffect, useRef } from 'react'

export const useApi = (apiFunction) => {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  const isMounted = useRef(true)
  
  useEffect(() => {
    isMounted.current = true
    return () => {
      isMounted.current = false
    }
  }, [])
  
  const execute = useCallback(async (...args) => {
    if (!isMounted.current) return { success: false, error: 'Component unmounted' }
    
    try {
      setLoading(true)
      setError(null)
      
      const result = await apiFunction(...args)
      
      if (isMounted.current) {
        if (result.success) {
          setData(result.data || result)
          return { success: true, data: result.data || result }
        } else {
          setError(result.error)
          return { success: false, error: result.error }
        }
      }
    } catch (err) {
      const errorMessage = err.message || 'An error occurred'
      if (isMounted.current) {
        setError(errorMessage)
      }
      return { success: false, error: errorMessage }
    } finally {
      if (isMounted.current) {
        setLoading(false)
      }
    }
  }, [apiFunction])
  
  const reset = useCallback(() => {
    if (!isMounted.current) return
    setData(null)
    setError(null)
    setLoading(false)
  }, [])
  
  return { data, loading, error, execute, reset }
}
</file>

<file path="frontend/src/hooks/useAuth.js">
import { useAuth } from '../contexts/AuthContext.jsx'

export { useAuth }
</file>

<file path="frontend/src/hooks/useClients.js">
import { useState, useEffect, useCallback, useRef } from 'react'
import { clientsService } from '@services'

export const useClients = (autoFetch = true, params = {}) => {
  const [clients, setClients] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  const isMounted = useRef(true)
  const hasFetched = useRef(false)
  
  const fetchClients = useCallback(async (fetchParams = {}) => {
    if (!isMounted.current) return
    
    try {
      setLoading(true)
      setError(null)
      
      const mergedParams = { ...params, ...fetchParams }
      const result = await clientsService.getClients(mergedParams)
      
      if (isMounted.current) {
        if (result.success) {
          setClients(result.clients)
        } else {
          setError(result.error)
        }
      }
    } catch (err) {
      if (isMounted.current) {
        setError(err.message)
      }
    } finally {
      if (isMounted.current) {
        setLoading(false)
      }
    }
  }, []) // Empty - stable function
  
  useEffect(() => {
    isMounted.current = true
    
    if (autoFetch && !hasFetched.current) {
      hasFetched.current = true
      fetchClients()
    }
    
    return () => {
      isMounted.current = false
    }
  }, []) // Empty - only run once on mount
  
  return {
    clients,
    loading,
    error,
    refetch: fetchClients
  }
}

export const useClient = (clientId) => {
  const [client, setClient] = useState(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  const isMounted = useRef(true)
  const lastFetchedId = useRef(null)
  
  const fetchClient = useCallback(async () => {
    if (!clientId || !isMounted.current) return
    
    try {
      setLoading(true)
      setError(null)
      
      const result = await clientsService.getClient(clientId)
      
      if (isMounted.current) {
        if (result.success) {
          setClient(result.client)
        } else {
          setError(result.error)
        }
      }
    } catch (err) {
      if (isMounted.current) {
        setError(err.message)
      }
    } finally {
      if (isMounted.current) {
        setLoading(false)
      }
    }
  }, [clientId])
  
  useEffect(() => {
    isMounted.current = true
    
    // Only fetch if clientId changed
    if (clientId && clientId !== lastFetchedId.current) {
      lastFetchedId.current = clientId
      fetchClient()
    }
    
    return () => {
      isMounted.current = false
    }
  }, [clientId]) // Only re-run if clientId changes
  
  return {
    client,
    loading,
    error,
    refetch: fetchClient
  }
}

export const useClientStats = () => {
  const [stats, setStats] = useState(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  const isMounted = useRef(true)
  const hasFetched = useRef(false)
  
  const fetchStats = useCallback(async () => {
    if (!isMounted.current) return
    
    try {
      setLoading(true)
      setError(null)
      
      const result = await clientsService.getClientStats()
      
      if (isMounted.current) {
        if (result.success) {
          setStats(result.stats)
        } else {
          setError(result.error)
        }
      }
    } catch (err) {
      if (isMounted.current) {
        setError(err.message)
      }
    } finally {
      if (isMounted.current) {
        setLoading(false)
      }
    }
  }, []) // Empty - stable function
  
  useEffect(() => {
    isMounted.current = true
    
    if (!hasFetched.current) {
      hasFetched.current = true
      fetchStats()
    }
    
    return () => {
      isMounted.current = false
    }
  }, []) // Empty - only run once on mount
  
  return {
    stats,
    loading,
    error,
    refetch: fetchStats
  }
}
</file>

<file path="frontend/src/pages/ActivitiesPage.jsx">
import React from 'react'
import { ActivitiesList } from '@components/features/activities'

const ActivitiesPage = () => {
  return (
    <div className="page">
      <div className="page-header">
        <h2>Activities</h2>
        <p>View and analyze client activities</p>
      </div>
      
      <ActivitiesList />
    </div>
  )
}

export default ActivitiesPage
</file>

<file path="frontend/src/pages/ApiKeysPage.jsx">
import React from 'react'
import { ApiKeys } from '@components/features/settings'

const ApiKeysPage = () => {
  return (
    <div className="page">
      <div className="page-header">
        <h2>API Keys</h2>
        <p>Manage API keys for monitoring clients</p>
      </div>
      
      <ApiKeys />
    </div>
  )
}

export default ApiKeysPage
</file>

<file path="frontend/src/pages/ClientsPage.jsx">
import React from 'react'
import { ClientsList, ClientStats } from '@components/features/clients'

const ClientsPage = () => {
  return (
    <div className="page">
      <div className="page-header">
        <h2>Clients</h2>
        <p>Monitor and manage connected clients</p>
      </div>
      
      <div className="page-content">
        <ClientStats />
        <ClientsList />
      </div>
    </div>
  )
}

export default ClientsPage
</file>

<file path="frontend/src/pages/DashboardPage.jsx">
import React from 'react'
import { Dashboard } from '@components/features/dashboard'

const DashboardPage = () => {
  return <Dashboard />
}

export default DashboardPage
</file>

<file path="frontend/src/pages/LoginPage.jsx">
import React from 'react'
import Login from '../components/features/auth/Login.jsx'

const LoginPage = () => {
  return <Login />
}

export default LoginPage
</file>

<file path="frontend/src/pages/SettingsPage.jsx">
import React from 'react'
import { SecuritySettings } from '@components/features/settings'

const SettingsPage = () => {
  return <SecuritySettings />
}

export default SettingsPage
</file>

<file path="frontend/src/services/activities.service.js">
import api from './api'

class ActivitiesService {
  async getActivities(params = {}) {
    try {
      const response = await api.get('/activities/', { params })
      return {
        success: true,
        activities: response.data
      }
    } catch (error) {
      return {
        success: false,
        error: error.message
      }
    }
  }
  
  async getActivity(activityId) {
    try {
      const response = await api.get(`/activities/${activityId}`)
      return {
        success: true,
        activity: response.data
      }
    } catch (error) {
      return {
        success: false,
        error: error.message
      }
    }
  }
  
  async getActivityStats(params = {}) {
    try {
      const response = await api.get('/activities/stats', { params })
      return {
        success: true,
        stats: response.data
      }
    } catch (error) {
      return {
        success: false,
        error: error.message
      }
    }
  }
  
  async cleanupOldActivities(days = 90) {
    try {
      const response = await api.post('/activities/cleanup', null, {
        params: { days }
      })
      return {
        success: true,
        data: response.data
      }
    } catch (error) {
      return {
        success: false,
        error: error.message
      }
    }
  }
}

export default new ActivitiesService()
</file>

<file path="frontend/src/services/api.js">
import axios from 'axios'

// In production with nginx proxy, we use /api which proxies to backend:8000/api/
// In development, we use the full backend URL
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || '/api'
const API_VERSION = import.meta.env.VITE_API_VERSION || 'v1'
const API_TIMEOUT = parseInt(import.meta.env.VITE_API_TIMEOUT || '30000')

// Create axios instance
const api = axios.create({
  baseURL: `${API_BASE_URL}/${API_VERSION}`,
  timeout: API_TIMEOUT,
  headers: {
    'Content-Type': 'application/json'
  }
})

// Request interceptor
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('sentinel_token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    
    // Add request timestamp
    config.metadata = { startTime: new Date() }
    
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// Response interceptor
api.interceptors.response.use(
  (response) => {
    // Calculate request duration
    const duration = new Date() - response.config.metadata.startTime
    if (import.meta.env.VITE_ENABLE_DEBUG === 'true') {
      console.log(`API Request: ${response.config.url} - ${duration}ms`)
    }
    
    return response
  },
  (error) => {
    // Handle errors
    if (error.response) {
      const { status, data } = error.response
      
      switch (status) {
        case 401:
          // Unauthorized - clear token and redirect to login
          localStorage.removeItem('sentinel_token')
          // Prevent redirect loop if already on login page
          if (window.location.pathname !== '/login') {
            window.location.href = '/login'
          }
          break
          
        case 403:
          // Forbidden
          console.error('Access forbidden:', data.detail)
          break
          
        case 404:
          // Not found
          console.error('Resource not found:', data.detail)
          break
          
        case 429:
          // Rate limited
          console.error('Rate limit exceeded. Please try again later.')
          break
          
        case 500:
          // Server error
          console.error('Server error:', data.detail)
          break
          
        default:
          console.error('API Error:', data.detail || error.message)
      }
      
      return Promise.reject({
        status,
        message: data?.detail || 'An error occurred',
        data
      })
    } else if (error.request) {
      // Network error
      console.error('Network error:', error.message)
      return Promise.reject({
        status: 0,
        message: 'Network error. Please check your connection.',
        data: null
      })
    } else {
      // Other errors
      console.error('Error:', error.message)
      return Promise.reject({
        status: 0,
        message: error.message,
        data: null
      })
    }
  }
)

// Helper functions
export const setAuthToken = (token) => {
  if (token) {
    localStorage.setItem('sentinel_token', token)
    api.defaults.headers.common['Authorization'] = `Bearer ${token}`
  } else {
    localStorage.removeItem('sentinel_token')
    delete api.defaults.headers.common['Authorization']
  }
}

export const getAuthToken = () => {
  return localStorage.getItem('sentinel_token')
}

export const isAuthenticated = () => {
  return !!getAuthToken()
}

export default api
</file>

<file path="frontend/src/services/auth.service.js">
import api, { setAuthToken } from './api'

class AuthService {
  async login(username, password) {
    try {
      console.log('AuthService.login called for:', username)
      const response = await api.post('/auth/login', {
        username,
        password
      })
      
      console.log('Login response:', response.data)
      
      const { access_token, force_password_change } = response.data
      setAuthToken(access_token)
      
      return {
        success: true,
        token: access_token,
        forcePasswordChange: force_password_change
      }
    } catch (error) {
      console.error('Login error:', error)
      return {
        success: false,
        error: error.message || 'Login failed'
      }
    }
  }
  
  async logout() {
    try {
      await api.post('/auth/logout')
    } catch (error) {
      console.error('Logout error:', error)
    } finally {
      setAuthToken(null)
    }
  }
  
  async getCurrentUser() {
    try {
      console.log('AuthService.getCurrentUser called')
      const response = await api.get('/auth/me')
      console.log('Current user response:', response.data)
      return {
        success: true,
        user: response.data
      }
    } catch (error) {
      console.error('Get current user error:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }
  
  async changePassword(currentPassword, newPassword) {
    try {
      const response = await api.post('/auth/change-password', {
        current_password: currentPassword,
        new_password: newPassword
      })
      
      return {
        success: true,
        message: response.data.message
      }
    } catch (error) {
      return {
        success: false,
        error: error.message || 'Failed to change password'
      }
    }
  }
  
  async createApiKey(name, options = {}) {
    try {
      console.log('Creating API key:', name)
      const response = await api.post('/auth/keys', {
        name,
        ...options
      })
      
      console.log('Create API key response:', response.data)
      
      return {
        success: true,
        apiKey: response.data
      }
    } catch (error) {
      console.error('Create API key error:', error)
      return {
        success: false,
        error: error.message || 'Failed to create API key'
      }
    }
  }
  
  async getApiKeys() {
    try {
      console.log('Getting API keys...')
      const response = await api.get('/auth/keys')
      console.log('Get API keys response:', response.data)
      
      // Ensure we always return an array
      const apiKeys = Array.isArray(response.data) ? response.data : []
      
      return {
        success: true,
        apiKeys: apiKeys
      }
    } catch (error) {
      console.error('Get API keys error:', error)
      return {
        success: false,
        error: error.message || 'Failed to load API keys',
        apiKeys: []
      }
    }
  }
  
  async revokeApiKey(keyId) {
    try {
      console.log('Revoking API key:', keyId)
      await api.delete(`/auth/keys/${keyId}`)
      return {
        success: true
      }
    } catch (error) {
      console.error('Revoke API key error:', error)
      return {
        success: false,
        error: error.message || 'Failed to revoke API key'
      }
    }
  }
}

export default new AuthService()
</file>

<file path="frontend/src/services/clients.service.js">
import api from './api'

class ClientsService {
  async getClients(params = {}) {
    try {
      const response = await api.get('/clients/', { params })
      return {
        success: true,
        clients: response.data
      }
    } catch (error) {
      return {
        success: false,
        error: error.message
      }
    }
  }
  
  async getClient(clientId) {
    try {
      const response = await api.get(`/clients/${clientId}`)
      return {
        success: true,
        client: response.data
      }
    } catch (error) {
      return {
        success: false,
        error: error.message
      }
    }
  }
  
  async getOnlineClients(minutes = 5) {
    try {
      const response = await api.get('/clients/online', {
        params: { minutes }
      })
      return {
        success: true,
        clients: response.data
      }
    } catch (error) {
      return {
        success: false,
        error: error.message
      }
    }
  }
  
  async getClientStats() {
    try {
      const response = await api.get('/clients/stats')
      return {
        success: true,
        stats: response.data
      }
    } catch (error) {
      return {
        success: false,
        error: error.message
      }
    }
  }
  
  async updateClient(clientId, data) {
    try {
      const response = await api.put(`/clients/${clientId}`, data)
      return {
        success: true,
        client: response.data
      }
    } catch (error) {
      return {
        success: false,
        error: error.message
      }
    }
  }
  
  async deleteClient(clientId) {
    try {
      await api.delete(`/clients/${clientId}`)
      return {
        success: true
      }
    } catch (error) {
      return {
        success: false,
        error: error.message
      }
    }
  }
}

export default new ClientsService()
</file>

<file path="frontend/src/services/index.js">
export { default as authService } from './auth.service'
export { default as clientsService } from './clients.service'
export { default as activitiesService } from './activities.service'
export { default as api } from './api'
</file>

<file path="frontend/src/styles/components.css">
/* Button Styles */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-sm) var(--spacing-md);
  border: none;
  border-radius: var(--radius-md);
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition-fast);
  white-space: nowrap;
}

.btn:disabled,
.btn.btn-disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-sm {
  padding: 0.375rem 0.75rem;
  font-size: 0.8125rem;
}

.btn-lg {
  padding: 0.75rem 1.5rem;
  font-size: 1rem;
}

.btn-primary {
  background: var(--color-primary);
  color: white;
}

.btn-primary:hover:not(:disabled) {
  background: var(--color-primary-dark);
}

.btn-secondary {
  background: var(--gray-200);
  color: var(--gray-700);
}

.btn-secondary:hover:not(:disabled) {
  background: var(--gray-300);
}

.btn-danger {
  background: var(--color-error);
  color: white;
}

.btn-danger:hover:not(:disabled) {
  background: var(--color-error-dark);
}

.btn-icon {
  flex-shrink: 0;
}

/* Card Styles */
.card {
  background: white;
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--gray-200);
  overflow: hidden;
}

.card-header {
  padding: var(--spacing-lg);
  border-bottom: 1px solid var(--gray-200);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.card-header-content {
  flex: 1;
}

.card-title {
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--gray-900);
  margin: 0;
}

.card-subtitle {
  font-size: 0.875rem;
  color: var(--gray-500);
  margin-top: 0.25rem;
}

.card-actions {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.card-body {
  padding: var(--spacing-lg);
}

.card-footer {
  padding: var(--spacing-lg);
  border-top: 1px solid var(--gray-200);
  background: var(--gray-50);
}

/* Form Styles */
.form-group {
  margin-bottom: var(--spacing-md);
}

.form-label {
  display: block;
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--gray-700);
  margin-bottom: var(--spacing-xs);
}

.form-input,
.form-textarea,
select.form-input {
  width: 100%;
  padding: var(--spacing-sm) var(--spacing-md);
  border: 1px solid var(--gray-300);
  border-radius: var(--radius-md);
  font-size: 0.875rem;
  color: var(--gray-900);
  background: white;
  transition: all var(--transition-fast);
}

.form-input:focus,
.form-textarea:focus,
select.form-input:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.form-input:disabled,
.form-textarea:disabled {
  background: var(--gray-100);
  cursor: not-allowed;
}

.input-wrapper {
  position: relative;
}

.input-icon {
  position: absolute;
  left: var(--spacing-md);
  top: 50%;
  transform: translateY(-50%);
  color: var(--gray-400);
  pointer-events: none;
}

.input-with-icon {
  padding-left: 2.5rem;
}

.input-error {
  border-color: var(--color-error);
}

.input-error:focus {
  box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1);
}

.form-error {
  margin-top: var(--spacing-xs);
  font-size: 0.875rem;
  color: var(--color-error);
}

.form-helper {
  margin-top: var(--spacing-xs);
  font-size: 0.875rem;
  color: var(--gray-500);
}

.form-actions {
  display: flex;
  gap: var(--spacing-md);
  margin-top: var(--spacing-lg);
}

/* Table Styles */
.table-container {
  overflow-x: auto;
  border-radius: var(--radius-lg);
  border: 1px solid var(--gray-200);
}

.table {
  width: 100%;
  border-collapse: collapse;
}

.table thead {
  background: var(--gray-50);
}

.table th {
  padding: var(--spacing-md);
  text-align: left;
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--gray-700);
  border-bottom: 1px solid var(--gray-200);
  white-space: nowrap;
}

.table th.sortable {
  cursor: pointer;
  user-select: none;
}

.table th.sortable:hover {
  background: var(--gray-100);
}

.th-content {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.sort-icon {
  color: var(--gray-400);
}

.table td {
  padding: var(--spacing-md);
  font-size: 0.875rem;
  color: var(--gray-900);
  border-bottom: 1px solid var(--gray-200);
}

.table tbody tr:last-child td {
  border-bottom: none;
}

.table tbody tr:hover {
  background: var(--gray-50);
}

.table-loading,
.table-empty {
  padding: var(--spacing-2xl);
  text-align: center;
  color: var(--gray-500);
}

/* Alert Styles */
.alert {
  display: flex;
  align-items: flex-start;
  gap: var(--spacing-md);
  padding: var(--spacing-md);
  border-radius: var(--radius-md);
  border: 1px solid;
}

.alert-icon {
  flex-shrink: 0;
  margin-top: 2px;
}

.alert-content {
  flex: 1;
}

.alert-title {
  font-weight: 600;
  margin-bottom: var(--spacing-xs);
}

.alert-message {
  font-size: 0.875rem;
}

.alert-close {
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
  padding: 0;
  margin-left: auto;
  opacity: 0.7;
  transition: opacity var(--transition-fast);
}

.alert-close:hover {
  opacity: 1;
}

.alert-success {
  background: rgba(16, 185, 129, 0.1);
  border-color: var(--color-success);
  color: var(--color-success-dark);
}

.alert-error {
  background: rgba(239, 68, 68, 0.1);
  border-color: var(--color-error);
  color: var(--color-error-dark);
}

.alert-warning {
  background: rgba(245, 158, 11, 0.1);
  border-color: var(--color-warning);
  color: var(--color-warning-dark);
}

.alert-info {
  background: rgba(59, 130, 246, 0.1);
  border-color: var(--color-info);
  color: var(--color-info-dark);
}

/* Modal Styles */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: var(--spacing-lg);
  animation: fadeIn 0.2s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.modal {
  background: white;
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-xl);
  max-height: 90vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  animation: scaleIn 0.2s ease-out;
}

@keyframes scaleIn {
  from {
    transform: scale(0.9);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}

.modal-md { width: 100%; max-width: 32rem; }
.modal-lg { width: 100%; max-width: 48rem; }
.modal-xl { width: 100%; max-width: 64rem; }

.modal-header {
  padding: var(--spacing-lg);
  border-bottom: 1px solid var(--gray-200);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.modal-title {
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--gray-900);
  margin: 0;
}

.modal-close {
  background: none;
  border: none;
  color: var(--gray-500);
  cursor: pointer;
  padding: var(--spacing-xs);
  border-radius: var(--radius-md);
  transition: all var(--transition-fast);
}

.modal-close:hover {
  background: var(--gray-100);
  color: var(--gray-700);
}

.modal-body {
  padding: var(--spacing-lg);
  overflow-y: auto;
  flex: 1;
}

.modal-footer {
  padding: var(--spacing-lg);
  border-top: 1px solid var(--gray-200);
  background: var(--gray-50);
}

/* Badge Styles */
.badge {
  display: inline-flex;
  align-items: center;
  padding: 0.25rem 0.75rem;
  border-radius: 9999px;
  font-size: 0.75rem;
  font-weight: 500;
  text-transform: capitalize;
}

.badge-work {
  background: rgba(16, 185, 129, 0.1);
  color: var(--color-success-dark);
}

.badge-break {
  background: rgba(245, 158, 11, 0.1);
  color: var(--color-warning-dark);
}

.badge-idle {
  background: rgba(107, 114, 128, 0.1);
  color: var(--gray-700);
}

.badge-other {
  background: rgba(59, 130, 246, 0.1);
  color: var(--color-info-dark);
}

/* Status Badge */
.status-badge {
  display: inline-flex;
  align-items: center;
  gap: 0.375rem;
  padding: 0.25rem 0.75rem;
  border-radius: 9999px;
  font-size: 0.75rem;
  font-weight: 500;
}

.status-badge::before {
  content: '';
  width: 0.5rem;
  height: 0.5rem;
  border-radius: 50%;
}

.status-online {
  background: rgba(16, 185, 129, 0.1);
  color: var(--color-success-dark);
}

.status-online::before {
  background: var(--color-success);
}

.status-offline {
  background: rgba(107, 114, 128, 0.1);
  color: var(--gray-700);
}

.status-offline::before {
  background: var(--gray-400);
}

/* Detail Styles */
.detail-section {
  margin-bottom: var(--spacing-xl);
}

.detail-section:last-child {
  margin-bottom: 0;
}

.detail-section-title {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  font-size: 1rem;
  font-weight: 600;
  color: var(--gray-900);
  margin-bottom: var(--spacing-md);
  padding-bottom: var(--spacing-sm);
  border-bottom: 2px solid var(--gray-200);
}

.detail-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: var(--spacing-md);
}

.detail-list {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

.detail-item {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
}

.detail-item label {
  font-size: 0.75rem;
  font-weight: 600;
  color: var(--gray-500);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.detail-item span {
  font-size: 0.875rem;
  color: var(--gray-900);
}

/* Process List */
.process-list {
  max-height: 400px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
}

.process-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--spacing-sm) var(--spacing-md);
  background: var(--gray-50);
  border-radius: var(--radius-md);
}

.process-info {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
}

.process-name {
  font-weight: 500;
  color: var(--gray-900);
}

.process-meta {
  color: var(--gray-500);
}

.process-stats {
  display: flex;
  gap: var(--spacing-md);
}

/* Empty State */
.empty-state,
.error-state {
  padding: var(--spacing-2xl);
  text-align: center;
  color: var(--gray-500);
}

/* Details Expandable */
.details-expandable {
  border: 1px solid var(--gray-200);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
}

.details-expandable summary {
  font-weight: 500;
  color: var(--gray-700);
}

.details-expandable[open] summary {
  margin-bottom: var(--spacing-md);
}

/* Filter Buttons */
.filter-buttons {
  display: inline-flex;
  border: 1px solid var(--gray-300);
  border-radius: var(--radius-md);
  overflow: hidden;
}

.filter-btn {
  padding: 0.375rem 0.75rem;
  background: white;
  border: none;
  border-right: 1px solid var(--gray-300);
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--gray-700);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.filter-btn:last-child {
  border-right: none;
}

.filter-btn:hover {
  background: var(--gray-50);
}

.filter-btn.active {
  background: var(--color-primary);
  color: white;
}

.filters-form {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

/* Login Page Styles */
.login-page {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
  padding: var(--spacing-lg);
}

.login-container {
  width: 100%;
  max-width: 400px;
}

.login-card {
  background: white;
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-2xl);
  padding: var(--spacing-2xl);
  width: 100%;
}

.login-header {
  text-align: center;
  margin-bottom: var(--spacing-2xl);
}

.login-logo {
  width: 64px;
  height: 64px;
  background: var(--color-primary);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-lg);
  font-size: 2rem;
  font-weight: 700;
  margin: 0 auto var(--spacing-md);
}

.login-title {
  font-size: 1.875rem;
  font-weight: 700;
  color: var(--gray-900);
  margin-bottom: var(--spacing-xs);
}

.login-subtitle {
  color: var(--gray-500);
  font-size: 1rem;
}

.login-form {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-lg);
}

.password-input-wrapper {
  position: relative;
}

.password-toggle {
  position: absolute;
  right: var(--spacing-md);
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: var(--gray-400);
  cursor: pointer;
  padding: var(--spacing-xs);
  border-radius: var(--radius-sm);
  transition: all var(--transition-fast);
}

.password-toggle:hover {
  color: var(--gray-600);
  background: var(--gray-100);
}

.login-footer {
  margin-top: var(--spacing-2xl);
  padding-top: var(--spacing-lg);
  border-top: 1px solid var(--gray-200);
}

.login-info {
  background: var(--gray-50);
  padding: var(--spacing-lg);
  border-radius: var(--radius-lg);
}

.login-info h4 {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--gray-700);
  margin-bottom: var(--spacing-sm);
}

.login-info-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.login-info-list li {
  font-size: 0.75rem;
  color: var(--gray-600);
  padding: var(--spacing-xs) 0;
  position: relative;
  padding-left: var(--spacing-md);
}

.login-info-list li::before {
  content: '•';
  position: absolute;
  left: 0;
  color: var(--color-primary);
}
</file>

<file path="frontend/src/styles/globals.css">
/* Reset and Base Styles */
*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  /* Colors */
  --color-primary: #3b82f6;
  --color-primary-dark: #2563eb;
  --color-primary-light: #60a5fa;
  
  --color-success: #10b981;
  --color-success-dark: #059669;
  --color-success-light: #34d399;
  
  --color-warning: #f59e0b;
  --color-warning-dark: #d97706;
  --color-warning-light: #fbbf24;
  
  --color-error: #ef4444;
  --color-error-dark: #dc2626;
  --color-error-light: #f87171;
  
  --color-info: #3b82f6;
  --color-info-dark: #2563eb;
  --color-info-light: #60a5fa;
  
  /* Grays */
  --gray-50: #f9fafb;
  --gray-100: #f3f4f6;
  --gray-200: #e5e7eb;
  --gray-300: #d1d5db;
  --gray-400: #9ca3af;
  --gray-500: #6b7280;
  --gray-600: #4b5563;
  --gray-700: #374151;
  --gray-800: #1f2937;
  --gray-900: #111827;
  
  /* Spacing */
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 1rem;
  --spacing-lg: 1.5rem;
  --spacing-xl: 2rem;
  --spacing-2xl: 3rem;
  
  /* Border Radius */
  --radius-sm: 0.25rem;
  --radius-md: 0.375rem;
  --radius-lg: 0.5rem;
  --radius-xl: 0.75rem;
  
  /* Shadows */
  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
  
  /* Transitions */
  --transition-fast: 150ms ease-in-out;
  --transition-normal: 200ms ease-in-out;
  --transition-slow: 300ms ease-in-out;
  
  /* Typography */
  --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  --font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
}

body {
  font-family: var(--font-sans);
  font-size: 16px;
  line-height: 1.5;
  color: var(--gray-900);
  background-color: var(--gray-50);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#root {
  min-height: 100vh;
}

/* Typography */
h1, h2, h3, h4, h5, h6 {
  font-weight: 600;
  line-height: 1.2;
  color: var(--gray-900);
}

h1 { font-size: 2.25rem; }
h2 { font-size: 1.875rem; }
h3 { font-size: 1.5rem; }
h4 { font-size: 1.25rem; }
h5 { font-size: 1.125rem; }
h6 { font-size: 1rem; }

p {
  margin-bottom: 1rem;
}

a {
  color: var(--color-primary);
  text-decoration: none;
  transition: color var(--transition-fast);
}

a:hover {
  color: var(--color-primary-dark);
}

/* Utility Classes */
.text-success { color: var(--color-success); }
.text-warning { color: var(--color-warning); }
.text-error { color: var(--color-error); }
.text-info { color: var(--color-info); }
.text-gray-500 { color: var(--gray-500); }
.text-gray-600 { color: var(--gray-600); }
.text-gray-700 { color: var(--gray-700); }

.font-mono { font-family: var(--font-mono); }
.font-medium { font-weight: 500; }
.font-semibold { font-weight: 600; }
.font-bold { font-weight: 700; }

.text-xs { font-size: 0.75rem; }
.text-sm { font-size: 0.875rem; }
.text-base { font-size: 1rem; }
.text-lg { font-size: 1.125rem; }
.text-xl { font-size: 1.25rem; }

.break-words { word-break: break-word; }
.break-all { word-break: break-all; }

.w-full { width: 100%; }
.max-w-2xl { max-width: 42rem; }

.flex { display: flex; }
.items-center { align-items: center; }
.justify-between { justify-content: space-between; }
.gap-2 { gap: var(--spacing-sm); }
.gap-4 { gap: var(--spacing-md); }

.space-y-1 > * + * { margin-top: 0.25rem; }
.space-y-2 > * + * { margin-top: 0.5rem; }
.space-y-4 > * + * { margin-top: 1rem; }

.ml-1 { margin-left: 0.25rem; }
.ml-2 { margin-left: 0.5rem; }
.mb-2 { margin-bottom: 0.5rem; }
.mb-4 { margin-bottom: 1rem; }
.mt-2 { margin-top: 0.5rem; }
.mt-4 { margin-top: 1rem; }

/* Scrollbar Styling */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--gray-100);
}

::-webkit-scrollbar-thumb {
  background: var(--gray-400);
  border-radius: var(--radius-md);
}

::-webkit-scrollbar-thumb:hover {
  background: var(--gray-500);
}

/* Loading State */
.page-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
}

.loading-spinner {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--spacing-md);
}

.loading-text {
  color: var(--gray-600);
  font-size: 0.875rem;
}

/* Animation */
@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.animate-spin {
  animation: spin 1s linear infinite;
}

/* Notification Container */
.notification-container {
  position: fixed;
  top: var(--spacing-lg);
  right: var(--spacing-lg);
  z-index: 9999;
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
  max-width: 400px;
}

.notification {
  background: white;
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-lg);
  padding: var(--spacing-md);
  display: flex;
  align-items: flex-start;
  gap: var(--spacing-md);
  animation: slideIn 0.3s ease-out;
  border-left: 4px solid;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

.notification-success { border-left-color: var(--color-success); }
.notification-error { border-left-color: var(--color-error); }
.notification-warning { border-left-color: var(--color-warning); }
.notification-info { border-left-color: var(--color-info); }

.notification-content {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--spacing-md);
}

.notification-close {
  background: none;
  border: none;
  color: var(--gray-500);
  cursor: pointer;
  font-size: 1.25rem;
  line-height: 1;
  padding: 0;
  transition: color var(--transition-fast);
}

.notification-close:hover {
  color: var(--gray-700);
}
</file>

<file path="frontend/src/styles/utilities.css">
/* Layout Styles */
.app-layout {
  display: flex;
  min-height: 100vh;
  background: var(--gray-50);
  overflow-x: hidden; /* Prevent horizontal scroll during transitions */
}

.app-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 0;
  transition: all var(--transition-normal);
  width: 100%;
}

.app-content {
  flex: 1;
  padding: var(--spacing-xl);
  overflow-y: auto;
}

/* Header */
.header {
  background: white;
  border-bottom: 1px solid var(--gray-200);
  padding: 0 var(--spacing-xl);
  height: 64px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: sticky;
  top: 0;
  z-index: 90;
}

.header-left,
.header-right {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
}

/* Global Menu Button (Header) */
.menu-button {
  background: none;
  border: none;
  color: var(--gray-600);
  cursor: pointer;
  padding: var(--spacing-sm);
  border-radius: var(--radius-md);
  transition: all var(--transition-fast);
  display: flex;
}

.menu-button:hover {
  background: var(--gray-100);
  color: var(--gray-900);
}

.header-brand {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
}

.brand-logo {
  width: 40px;
  height: 40px;
  background: var(--color-primary);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-lg);
  font-weight: 700;
  font-size: 1.25rem;
}

.brand-name {
  font-size: 1.25rem;
  font-weight: 700;
  color: var(--gray-900);
}

.brand-subtitle {
  font-size: 0.75rem;
  color: var(--gray-500);
}

.header-icon-button {
  background: none;
  border: none;
  color: var(--gray-600);
  cursor: pointer;
  padding: var(--spacing-sm);
  border-radius: var(--radius-md);
  transition: all var(--transition-fast);
}

.header-icon-button:hover {
  background: var(--gray-100);
  color: var(--gray-900);
}

.user-menu {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
}

.user-info {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-sm) var(--spacing-md);
  background: var(--gray-50);
  border-radius: var(--radius-md);
}

.user-details {
  display: flex;
  flex-direction: column;
}

.user-name {
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--gray-900);
}

.user-role {
  font-size: 0.75rem;
  color: var(--gray-500);
}

.logout-button {
  background: var(--color-error);
  color: white;
  border: none;
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all var(--transition-fast);
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  font-weight: 500;
  font-size: 0.875rem;
}

.logout-button:hover {
  background: var(--color-error-dark);
}

/* Sidebar Container */
.sidebar-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 999;
}

.sidebar {
  width: 280px;
  background: white;
  border-right: 1px solid var(--gray-200);
  display: flex;
  flex-direction: column;
  
  /* Sticky positioning for desktop flow */
  position: sticky;
  top: 0;
  height: 100vh;
  z-index: 1000;
  flex-shrink: 0;
  
  /* Smooth transitions for width and margin */
  transition: margin-left 0.3s ease, transform 0.3s ease;
}

/* Desktop Collapsed State */
.sidebar.closed {
  margin-left: -280px;
}

.sidebar-header {
  padding: var(--spacing-lg) var(--spacing-xl);
  border-bottom: 1px solid var(--gray-200);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.sidebar-title {
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--gray-900);
}

/* Sidebar Toggle Buttons */
.sidebar-toggle {
  background: none;
  border: none;
  color: var(--gray-600);
  cursor: pointer;
  padding: var(--spacing-xs);
  border-radius: var(--radius-md);
  transition: all var(--transition-fast);
  display: flex;
  align-items: center;
  justify-content: center;
}

.sidebar-toggle:hover {
  background: var(--gray-100);
  color: var(--gray-900);
}

.sidebar-close-mobile {
  display: none;
  background: none;
  border: none;
  color: var(--gray-600);
  cursor: pointer;
  padding: var(--spacing-xs);
}

.sidebar-nav {
  flex: 1;
  padding: var(--spacing-md) 0;
  overflow-y: auto;
}

.nav-item {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
  padding: var(--spacing-md) var(--spacing-xl);
  color: var(--gray-700);
  text-decoration: none;
  transition: all var(--transition-fast);
  border-left: 3px solid transparent;
  white-space: nowrap; /* Keep icon and text on one line during transition */
}

.nav-item:hover {
  background: var(--gray-50);
  color: var(--gray-900);
}

.nav-item.active {
  background: rgba(59, 130, 246, 0.1);
  color: var(--color-primary);
  border-left-color: var(--color-primary);
}

.nav-icon {
  flex-shrink: 0;
}

.nav-label {
  font-weight: 500;
}

.sidebar-footer {
  padding: var(--spacing-lg) var(--spacing-xl);
  border-top: 1px solid var(--gray-200);
  background: var(--gray-50);
}

.sidebar-info {
  text-align: center;
  color: var(--gray-500);
  white-space: nowrap;
}

/* Responsive Design */
@media (max-width: 1024px) {
  .sidebar {
    position: fixed;
    left: 0;
    top: 0;
    bottom: 0;
    transform: translateX(-100%); /* Hidden by default on mobile */
    margin-left: 0; /* Reset the desktop margin trick */
    box-shadow: var(--shadow-xl);
  }
  
  .sidebar.open {
    transform: translateX(0);
  }
  
  .sidebar.closed {
    margin-left: 0;
  }
  
  .sidebar-overlay.active {
    display: block;
  }
  
  .sidebar-close-mobile {
    display: block;
  }
  
  /* Hide the collapse toggle on mobile since we use the X button */
  .sidebar-toggle {
    display: none;
  }

  .app-content {
    padding: var(--spacing-lg);
  }
}

@media (max-width: 768px) {
  .header {
    padding: 0 var(--spacing-md);
  }
  
  .app-content {
    padding: var(--spacing-md);
  }
  
  .user-info {
    display: none;
  }
  
  .page-header h2 {
    font-size: 1.5rem;
  }
}
</file>

<file path="frontend/src/utils/constants.js">
export const CLIENT_TYPES = {
  linux_desktop: 'Linux Desktop',
  linux_server: 'Linux Server',
  windows_desktop: 'Windows Desktop',
  windows_server: 'Windows Server',
  macos_desktop: 'macOS Desktop'
}

export const CLIENT_TYPE_ICONS = {
  linux_desktop: '🐧',
  linux_server: '🖥️',
  windows_desktop: '🪟',
  windows_server: '🖥️',
  macos_desktop: '🍎'
}

export const ACTIVITY_CATEGORIES = {
  work: 'Work',
  break: 'Break',
  idle: 'Idle',
  other: 'Other'
}

export const ACTIVITY_CATEGORY_COLORS = {
  work: '#10b981',
  break: '#f59e0b',
  idle: '#6b7280',
  other: '#3b82f6'
}

export const STATUS_COLORS = {
  online: '#10b981',
  offline: '#ef4444',
  warning: '#f59e0b'
}

export const PRODUCTIVITY_LEVELS = {
  high: { min: 70, color: '#10b981', label: 'High' },
  medium: { min: 40, color: '#f59e0b', label: 'Medium' },
  low: { min: 0, color: '#ef4444', label: 'Low' }
}

export const DATE_RANGES = {
  today: 'Today',
  yesterday: 'Yesterday',
  last7days: 'Last 7 Days',
  last30days: 'Last 30 Days',
  last90days: 'Last 90 Days',
  custom: 'Custom Range'
}

export const REFRESH_INTERVALS = {
  realtime: 5000,
  normal: 30000,
  slow: 60000
}

export const PAGINATION = {
  defaultPageSize: 50,
  pageSizeOptions: [25, 50, 100, 200]
}
</file>

<file path="frontend/src/utils/formatters.js">
import { format, formatDistance, formatRelative, isValid, parseISO } from 'date-fns'

export const formatDate = (date, formatStr = 'PPpp') => {
  if (!date) return 'N/A'
  
  try {
    const dateObj = typeof date === 'string' ? parseISO(date) : date
    if (!isValid(dateObj)) return 'Invalid Date'
    return format(dateObj, formatStr)
  } catch (error) {
    console.error('Date formatting error:', error)
    return 'Invalid Date'
  }
}

export const formatRelativeTime = (date) => {
  if (!date) return 'N/A'
  
  try {
    const dateObj = typeof date === 'string' ? parseISO(date) : date
    if (!isValid(dateObj)) return 'Invalid Date'
    return formatDistance(dateObj, new Date(), { addSuffix: true })
  } catch (error) {
    return 'Invalid Date'
  }
}

export const formatRelativeDate = (date) => {
  if (!date) return 'N/A'
  
  try {
    const dateObj = typeof date === 'string' ? parseISO(date) : date
    if (!isValid(dateObj)) return 'Invalid Date'
    return formatRelative(dateObj, new Date())
  } catch (error) {
    return 'Invalid Date'
  }
}

export const formatBytes = (bytes, decimals = 2) => {
  if (bytes === 0) return '0 Bytes'
  if (!bytes) return 'N/A'
  
  const k = 1024
  const dm = decimals < 0 ? 0 : decimals
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']
  
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i]
}

export const formatPercentage = (value, decimals = 1) => {
  if (value === null || value === undefined) return 'N/A'
  return `${parseFloat(value).toFixed(decimals)}%`
}

export const formatNumber = (value, decimals = 0) => {
  if (value === null || value === undefined) return 'N/A'
  return parseFloat(value).toFixed(decimals)
}

export const formatDuration = (seconds) => {
  if (!seconds) return '0s'
  
  const hours = Math.floor(seconds / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const secs = seconds % 60
  
  const parts = []
  if (hours > 0) parts.push(`${hours}h`)
  if (minutes > 0) parts.push(`${minutes}m`)
  if (secs > 0 || parts.length === 0) parts.push(`${secs}s`)
  
  return parts.join(' ')
}

export const formatClientType = (type) => {
  const types = {
    linux_desktop: 'Linux Desktop',
    linux_server: 'Linux Server',
    windows_desktop: 'Windows Desktop',
    windows_server: 'Windows Server',
    macos_desktop: 'macOS Desktop'
  }
  return types[type] || type || 'Unknown'
}

export const formatActivityCategory = (category) => {
  const categories = {
    work: 'Work',
    break: 'Break',
    idle: 'Idle',
    other: 'Other'
  }
  return categories[category] || category || 'Unknown'
}

export const truncateText = (text, maxLength = 50) => {
  if (!text) return ''
  if (text.length <= maxLength) return text
  return text.substring(0, maxLength) + '...'
}

export const formatProductivityScore = (score) => {
  if (score === null || score === undefined) return { text: 'N/A', color: '#6b7280', level: 'unknown' }
  
  if (score >= 70) return { text: `${score}%`, color: '#10b981', level: 'high' }
  if (score >= 40) return { text: `${score}%`, color: '#f59e0b', level: 'medium' }
  return { text: `${score}%`, color: '#ef4444', level: 'low' }
}

export const capitalize = (str) => {
  if (!str) return ''
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()
}
</file>

<file path="frontend/src/utils/index.js">
export * from './constants'
export * from './formatters'
export * from './validators'

// Utility functions
export const debounce = (func, wait) => {
  let timeout
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout)
      func(...args)
    }
    clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

export const throttle = (func, limit) => {
  let inThrottle
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args)
      inThrottle = true
      setTimeout(() => inThrottle = false, limit)
    }
  }
}

export const copyToClipboard = async (text) => {
  try {
    await navigator.clipboard.writeText(text)
    return { success: true }
  } catch (error) {
    return { success: false, error: error.message }
  }
}

export const downloadFile = (data, filename, type = 'text/plain') => {
  const blob = new Blob([data], { type })
  const url = window.URL.createObjectURL(blob)
  const link = document.createElement('a')
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  window.URL.revokeObjectURL(url)
}

export const groupBy = (array, key) => {
  return array.reduce((result, item) => {
    const group = item[key]
    if (!result[group]) {
      result[group] = []
    }
    result[group].push(item)
    return result
  }, {})
}

export const sortBy = (array, key, order = 'asc') => {
  return [...array].sort((a, b) => {
    const aVal = a[key]
    const bVal = b[key]
    
    if (aVal < bVal) return order === 'asc' ? -1 : 1
    if (aVal > bVal) return order === 'asc' ? 1 : -1
    return 0
  })
}
</file>

<file path="frontend/src/utils/validators.js">
export const validateEmail = (email) => {
  const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return re.test(String(email).toLowerCase())
}

export const validatePassword = (password) => {
  const errors = []
  
  if (password.length < 8) {
    errors.push('Password must be at least 8 characters long')
  }
  
  if (!/[a-z]/.test(password)) {
    errors.push('Password must contain at least one lowercase letter')
  }
  
  if (!/[A-Z]/.test(password)) {
    errors.push('Password must contain at least one uppercase letter')
  }
  
  if (!/\d/.test(password)) {
    errors.push('Password must contain at least one number')
  }
  
  if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    errors.push('Password must contain at least one special character')
  }
  
  return {
    isValid: errors.length === 0,
    errors
  }
}

export const validateUsername = (username) => {
  const errors = []
  
  if (username.length < 3) {
    errors.push('Username must be at least 3 characters long')
  }
  
  if (username.length > 50) {
    errors.push('Username must be less than 50 characters')
  }
  
  if (!/^[a-zA-Z0-9_-]+$/.test(username)) {
    errors.push('Username can only contain letters, numbers, underscores, and hyphens')
  }
  
  return {
    isValid: errors.length === 0,
    errors
  }
}

export const validateRequired = (value, fieldName = 'Field') => {
  if (!value || (typeof value === 'string' && !value.trim())) {
    return {
      isValid: false,
      error: `${fieldName} is required`
    }
  }
  return { isValid: true }
}

export const validateLength = (value, min, max, fieldName = 'Field') => {
  const length = value ? value.length : 0
  
  if (length < min) {
    return {
      isValid: false,
      error: `${fieldName} must be at least ${min} characters`
    }
  }
  
  if (max && length > max) {
    return {
      isValid: false,
      error: `${fieldName} must be less than ${max} characters`
    }
  }
  
  return { isValid: true }
}
</file>

<file path="frontend/src/App.jsx">
import React from 'react'
import { BrowserRouter } from 'react-router-dom'
import { AuthProvider, NotificationProvider } from '@contexts'
import AppRouter from './router'
import './styles/globals.css'
import './styles/components.css'
import './styles/utilities.css'

function App() {
  return (
    <BrowserRouter>
      <NotificationProvider>
        <AuthProvider>
          <AppRouter />
        </AuthProvider>
      </NotificationProvider>
    </BrowserRouter>
  )
}

export default App
</file>

<file path="frontend/src/main.jsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'

// Remove StrictMode to prevent double rendering in development
ReactDOM.createRoot(document.getElementById('root')).render(
  <App />
)
</file>

<file path="frontend/src/router.jsx">
import React from 'react'
import { Routes, Route, Navigate } from 'react-router-dom'
import { useAuth } from '@contexts'
import { Layout } from '@components/layout'
import { Login, ChangePassword } from '@components/features/auth'
import { LoadingSpinner } from '@components/common'

// Lazy load pages
const DashboardPage = React.lazy(() => import('./pages/DashboardPage'))
const ClientsPage = React.lazy(() => import('./pages/ClientsPage'))
const ActivitiesPage = React.lazy(() => import('./pages/ActivitiesPage'))
const ApiKeysPage = React.lazy(() => import('./pages/ApiKeysPage'))
const SettingsPage = React.lazy(() => import('./pages/SettingsPage'))

const PrivateRoute = ({ children }) => {
  const { isAuthenticated, loading } = useAuth()
  
  console.log('PrivateRoute - isAuthenticated:', isAuthenticated, 'loading:', loading)
  
  if (loading) {
    return (
      <div className="page-loading">
        <LoadingSpinner size="lg" text="Loading..." />
      </div>
    )
  }
  
  if (!isAuthenticated) {
    console.log('PrivateRoute - Redirecting to login')
    return <Navigate to="/login" replace />
  }
  
  return children
}

const AdminRoute = ({ children }) => {
  const { isAuthenticated, isAdmin, loading, user } = useAuth()
  
  console.log('AdminRoute - isAuthenticated:', isAuthenticated, 'isAdmin:', isAdmin, 'loading:', loading, 'user:', user)
  
  if (loading) {
    return (
      <div className="page-loading">
        <LoadingSpinner size="lg" text="Checking permissions..." />
      </div>
    )
  }
  
  if (!isAuthenticated) {
    console.log('AdminRoute - Not authenticated, redirecting to login')
    return <Navigate to="/login" replace />
  }
  
  if (!isAdmin) {
    console.log('AdminRoute - Not admin, redirecting to dashboard')
    return <Navigate to="/dashboard" replace />
  }
  
  console.log('AdminRoute - Access granted')
  return children
}

const AppRouter = () => {
  const { isAuthenticated, forcePasswordChange, loading } = useAuth()
  
  console.log('AppRouter - isAuthenticated:', isAuthenticated, 'forcePasswordChange:', forcePasswordChange, 'loading:', loading)
  
  // Show loading spinner while checking auth
  if (loading) {
    return (
      <div className="page-loading">
        <LoadingSpinner size="lg" text="Loading..." />
      </div>
    )
  }
  
  return (
    <React.Suspense fallback={
      <div className="page-loading">
        <LoadingSpinner size="lg" text="Loading page..." />
      </div>
    }>
      <Routes>
        {/* Public routes */}
        <Route
          path="/login"
          element={
            isAuthenticated ? (
              forcePasswordChange ? (
                <Navigate to="/change-password" replace />
              ) : (
                <Navigate to="/dashboard" replace />
              )
            ) : (
              <Login />
            )
          }
        />
        
        {/* Password change route */}
        <Route
          path="/change-password"
          element={
            <PrivateRoute>
              <ChangePassword forceChange={forcePasswordChange} />
            </PrivateRoute>
          }
        />
        
        {/* Protected routes */}
        <Route
          path="/"
          element={
            <PrivateRoute>
              {forcePasswordChange ? (
                <Navigate to="/change-password" replace />
              ) : (
                <Layout />
              )}
            </PrivateRoute>
          }
        >
          <Route index element={<Navigate to="/dashboard" replace />} />
          <Route path="dashboard" element={<DashboardPage />} />
          <Route path="clients" element={<ClientsPage />} />
          <Route path="activities" element={<ActivitiesPage />} />
          <Route path="settings" element={<SettingsPage />} />
          
          {/* Admin only routes */}
          <Route
            path="api-keys"
            element={
              <AdminRoute>
                <ApiKeysPage />
              </AdminRoute>
            }
          />
        </Route>
        
        {/* Catch all */}
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </React.Suspense>
  )
}

export default AppRouter
</file>

<file path="frontend/.env.development">
# API Configuration - direct to backend in development
VITE_API_BASE_URL=http://localhost:8000/api
VITE_API_VERSION=v1
VITE_API_TIMEOUT=30000
VITE_ENABLE_DEBUG=true
</file>

<file path="frontend/.env.example">
# API Configuration
VITE_API_BASE_URL=http://localhost:8000
VITE_API_VERSION=v1
VITE_API_TIMEOUT=30000

# Application
VITE_APP_NAME=Sentinel
VITE_APP_VERSION=2.0.0

# Features
VITE_ENABLE_ANALYTICS=false
VITE_ENABLE_DEBUG=false
</file>

<file path="frontend/.env.production">
# API Configuration - nginx will proxy /api to backend
VITE_API_BASE_URL=/api
VITE_API_VERSION=v1
VITE_API_TIMEOUT=30000
VITE_ENABLE_DEBUG=false
</file>

<file path="frontend/.gitignore">
# Dependencies
node_modules/
.pnp
.pnp.js

# Testing
coverage/
.nyc_output/

# Production
dist/
build/

# Environment
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Editor
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Debug
*.log
</file>

<file path="frontend/Dockerfile">
# Frontend Dockerfile - fix the build stage
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package.json package-lock.json* ./

# Install ALL dependencies (including dev dependencies) for building
RUN if [ -f package-lock.json ]; then \
      npm ci --no-audit --no-fund; \
    else \
      npm install --no-audit --no-fund; \
    fi

# Copy source code
COPY . .

# Build the application
RUN npm run build

# Production stage
FROM nginx:alpine

# Copy built assets from builder stage
COPY --from=builder /app/dist /usr/share/nginx/html

# Copy nginx configuration
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
</file>

<file path="frontend/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Sentinel - Employee Monitoring System with Enhanced Security and Compliance" />
    <meta name="theme-color" content="#3b82f6" />
    
    <!-- Security Headers -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' http://localhost:8000 https://api.sentinel.local;" />
    
    <title>Sentinel - Employee Monitoring System</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="frontend/nginx.conf">
events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # Logging
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    # Performance
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss application/rss+xml font/truetype font/opentype application/vnd.ms-fontobject image/svg+xml;

    server {
        listen 80;
        server_name localhost;
        root /usr/share/nginx/html;
        index index.html;

        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;

        # Cache static assets
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            try_files $uri =404;
        }

        # API proxy - CRITICAL FIX: proxy_pass must end with / and include /api/
        location /api/ {
            proxy_pass http://backend:8000/api/;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
            proxy_read_timeout 60s;
            proxy_connect_timeout 60s;
        }

        # Health check endpoint
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }

        # SPA fallback
        location / {
            try_files $uri $uri/ /index.html;
            add_header Cache-Control "no-cache, no-store, must-revalidate";
        }

        # Deny access to hidden files
        location ~ /\. {
            deny all;
            access_log off;
            log_not_found off;
        }
    }
}
</file>

<file path="frontend/package.json">
{
  "name": "sentinel-frontend",
  "version": "1.0.0",
  "type": "module",
  "description": "Employee Monitoring System - Frontend",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0",
    "format": "prettier --write \"src/**/*.{js,jsx,css}\"",
    "test": "vitest"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.21.1",
    "axios": "^1.6.5",
    "date-fns": "^3.0.6",
    "recharts": "^2.10.3",
    "lucide-react": "^0.303.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.2.1",
    "vite": "^5.0.11",
    "eslint": "^8.56.0",
    "eslint-plugin-react": "^7.33.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "prettier": "^3.1.1",
    "vitest": "^1.1.3"
  }
}
</file>

<file path="frontend/README.md">
# Sentinel Frontend - Employee Monitoring System

Modern React-based frontend for the Sentinel employee monitoring system.

## Features

- ✅ Modern React 18 with Hooks
- ✅ React Router for navigation
- ✅ Context API for state management
- ✅ Axios for API calls
- ✅ Responsive design
- ✅ Role-based access control
- ✅ Real-time updates
- ✅ Comprehensive activity tracking
- ✅ Client management
- ✅ API key management
- ✅ Dark mode support (coming soon)

## Tech Stack

- **React 18** - UI library
- **React Router 6** - Routing
- **Axios** - HTTP client
- **date-fns** - Date formatting
- **Recharts** - Data visualization
- **Lucide React** - Icons
- **Vite** - Build tool

## Getting Started

### Prerequisites

- Node.js 18+ 
- npm or yarn

### Installation

1. **Install dependencies**
```bash
npm install
```

2. **Configure environment**
```bash
cp .env.example .env.development
```

Edit `.env.development`:
```env
VITE_API_BASE_URL=http://localhost:8000
VITE_API_VERSION=v1
```

3. **Start development server**
```bash
npm run dev
```

The app will be available at `http://localhost:3000`

### Build for Production
```bash
npm run build
```

Build output will be in the `dist/` directory.

### Preview Production Build
```bash
npm run preview
```

## Docker Deployment

### Build Docker Image
```bash
docker build -t sentinel-frontend:latest .
```

### Run Container
```bash
docker run -d \
  --name sentinel-frontend \
  -p 3000:80 \
  -e NODE_ENV=production \
  sentinel-frontend:latest
```

### Docker Compose
```bash
docker-compose up -d
```

## Project Structure
```
src/
├── components/          # React components
│   ├── common/         # Reusable UI components
│   ├── layout/         # Layout components
│   └── features/       # Feature-specific components
├── contexts/           # React contexts
├── hooks/              # Custom React hooks
├── services/           # API services
├── utils/              # Utility functions
├── styles/             # CSS files
├── pages/              # Page components
├── App.jsx             # Main app component
├── main.jsx            # Entry point
└── router.jsx          # Route configuration
```

## Component Guidelines

### Creating New Components
```javascript
// components/features/example/ExampleComponent.jsx
import React from 'react'
import { Card, Button } from '@components/common'

const ExampleComponent = ({ data }) => {
  return (
    <Card title="Example">
      <div>{data}</div>
    </Card>
  )
}

export default ExampleComponent
```

### Using Custom Hooks
```javascript
import { useClients } from '@hooks'

const MyComponent = () => {
  const { clients, loading, error, refetch } = useClients()
  
  // Use the data
}
```

### API Calls
```javascript
import { clientsService } from '@services'

const fetchData = async () => {
  const result = await clientsService.getClients()
  if (result.success) {
    // Handle success
  }
}
```

## Styling

### CSS Variables

All colors and spacing use CSS variables defined in `globals.css`:
```css
var(--color-primary)
var(--spacing-md)
var(--radius-lg)
```

### Component Styles

Component-specific styles are in `components.css`:
```css
.btn-primary { /* styles */ }
.card { /* styles */ }
```

### Utility Classes

Utility classes in `utilities.css`:
```html
<div className="flex items-center gap-4">
  <span className="text-sm text-gray-600">Text</span>
</div>
```

## State Management

### Auth Context
```javascript
import { useAuth } from '@contexts'

const Component = () => {
  const { user, isAuthenticated, login, logout } = useAuth()
}
```

### Notification Context
```javascript
import { useNotification } from '@contexts'

const Component = () => {
  const { success, error, warning, info } = useNotification()
  
  success('Operation completed!')
}
```

## API Integration

### Configuration

API base URL is configured via environment variables:
```env
VITE_API_BASE_URL=http://localhost:8000
VITE_API_VERSION=v1
```

### Authentication

JWT tokens are automatically attached to requests:
```javascript
// Stored in localStorage as 'sentinel_token'
// Automatically added to Authorization header
```

### Error Handling

API errors are intercepted and handled:

- 401: Redirect to login
- 403: Access forbidden
- 429: Rate limited
- 500: Server error

## Features

### Dashboard

- System statistics
- Online clients count
- Recent activity feed
- Productivity metrics

### Clients Management

- View all connected clients
- Filter by status (online/offline)
- Client details and platform info
- Activity history per client

### Activities Tracking

- Comprehensive activity log
- Filter by client, date, category
- Activity details with processes
- System metrics visualization

### API Keys

- Create and manage API keys
- Secure key display (one-time)
- Usage tracking
- Revoke keys

### Settings

- Change password
- Security settings
- Account management

## Security

### Password Requirements

- Minimum 8 characters
- At least one uppercase letter
- At least one lowercase letter
- At least one number
- At least one special character

### API Key Security

- Generated with `sk_` prefix
- Only shown once upon creation
- Hashed on server
- Can be revoked anytime

### Session Management

- 24-hour token expiration
- Automatic logout on token expiry
- Secure token storage

## Performance

### Code Splitting

Pages are lazy-loaded using React.lazy():
```javascript
const DashboardPage = React.lazy(() => import('./pages/DashboardPage'))
```

### Optimizations

- Gzip compression
- Asset caching
- Minimize bundle size
- Tree shaking

## Testing
```bash
# Run tests
npm test

# Run tests with coverage
npm test -- --coverage
```

## Troubleshooting

### API Connection Issues

Check that:
1. Backend is running
2. CORS is configured correctly
3. API URL is correct in `.env`

### Build Errors
```bash
# Clear node_modules and reinstall
rm -rf node_modules package-lock.json
npm install
```

### Proxy Issues in Development

Vite proxy is configured in `vite.config.js`:
```javascript
proxy: {
  '/api': {
    target: 'http://localhost:8000',
    changeOrigin: true
  }
}
```

## Browser Support

- Chrome/Edge (last 2 versions)
- Firefox (last 2 versions)
- Safari (last 2 versions)

## License

Proprietary - Employee Monitoring System

## Support

For issues and questions:
- Check browser console for errors
- Review network tab for API calls
- Check backend logs

---

**Version:** 2.0.0
</file>

<file path="frontend/vite.config.js">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@components': path.resolve(__dirname, './src/components'),
      '@services': path.resolve(__dirname, './src/services'),
      '@hooks': path.resolve(__dirname, './src/hooks'),
      '@utils': path.resolve(__dirname, './src/utils'),
      '@contexts': path.resolve(__dirname, './src/contexts'),
      '@styles': path.resolve(__dirname, './src/styles')
    }
  },
  server: {
    host: true,
    port: 3000,
    proxy: {
      // Proxy /api to backend in development
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
        secure: false
      }
    }
  },
  build: {
    outDir: 'dist',
    sourcemap: false,
    chunkSizeWarningLimit: 1000,
    rollupOptions: {
      output: {
        manualChunks: {
          'react-vendor': ['react', 'react-dom', 'react-router-dom'],
          'ui-vendor': ['recharts', 'lucide-react'],
          'utils-vendor': ['axios', 'date-fns']
        }
      }
    }
  },
  optimizeDeps: {
    include: ['react', 'react-dom', 'react-router-dom']
  }
})
</file>

<file path="docker-compose.yml">
services:
  # PostgreSQL Database
  postgres:
    image: postgres:15-alpine
    container_name: sentinel-postgres
    environment:
      POSTGRES_DB: sentinel_db
      POSTGRES_USER: sentinel_user
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-change_this_secure_password}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backend/init-db.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    networks:
      - sentinel-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U sentinel_user -d sentinel_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis Cache
  redis:
    image: redis:7-alpine
    container_name: sentinel-redis
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD:-change_this_secure_password}
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    networks:
      - sentinel-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Backend API
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: sentinel-backend
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      - DATABASE_URL=postgresql://sentinel_user:${POSTGRES_PASSWORD:-change_this_secure_password}@postgres:5432/sentinel_db
      - REDIS_URL=redis://:${REDIS_PASSWORD:-change_this_secure_password}@redis:6379/0
      - SECRET_KEY=${SECRET_KEY:-CHANGE_THIS_TO_SECURE_RANDOM_KEY}
      - INITIAL_ADMIN_PASSWORD=${INITIAL_ADMIN_PASSWORD:-Admin123!@#}
      - ENVIRONMENT=production
      - DEBUG=false
      - ALLOWED_ORIGINS=http://localhost:3000,http://localhost
      - REQUIRE_HTTPS=false
    volumes:
      - ./backend/app:/app/app
      - backend_logs:/app/logs
    ports:
      - "8000:8000"
    networks:
      - sentinel-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Frontend
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: sentinel-frontend
    depends_on:
      backend:
        condition: service_healthy
    environment:
      - NODE_ENV=production
    ports:
      - "3000:80"
    networks:
      - sentinel-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:80/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  backend_logs:
    driver: local

networks:
  sentinel-network:
    driver: bridge
</file>

</files>
