This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
alembic/
  versions/
    001_initial_schema.py
  env.py
app/
  api/
    routes/
      __init__.py
      activities.py
      auth.py
      clients.py
    __init__.py
    deps.py
  core/
    __init__.py
    config.py
    database.py
    security.py
  middleware/
    __init__.py
    logging.py
    rate_limit.py
  models/
    __init__.py
    activity.py
    api_key.py
    client.py
    user.py
  schemas/
    __init__.py
    activity.py
    api_key.py
    client.py
    user.py
  services/
    __init__.py
    activity_service.py
    auth_service.py
    client_service.py
  tests/
    __init__.py
    conftest.py
    test_activities.py
    test_auth.py
    test_clients.py
  __init__.py
  main.py
.env.example
.gitignore
alembic.ini
docker-entrypoint.sh
Dockerfile
init-db.sql
README.md
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="alembic/versions/001_initial_schema.py">
"""Initial schema

Revision ID: 001
Revises: 
Create Date: 2024-01-01 00:00:00.000000

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers
revision = '001'
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    # Users table
    op.create_table(
        'users',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('username', sa.String(50), nullable=False),
        sa.Column('email', sa.String(255), nullable=True),
        sa.Column('hashed_password', sa.String(255), nullable=False),
        sa.Column('is_admin', sa.Boolean(), nullable=False, server_default='false'),
        sa.Column('is_active', sa.Boolean(), nullable=False, server_default='true'),
        sa.Column('force_password_change', sa.Boolean(), nullable=False, server_default='false'),
        sa.Column('failed_login_attempts', sa.Integer(), nullable=False, server_default='0'),
        sa.Column('last_login', sa.DateTime(), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('username'),
        sa.UniqueConstraint('email')
    )
    op.create_index('ix_users_username', 'users', ['username'])
    op.create_index('ix_users_email', 'users', ['email'])
    
    # Clients table
    op.create_table(
        'clients',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('client_id', sa.String(255), nullable=False),
        sa.Column('client_type', sa.String(50), nullable=False),
        sa.Column('hostname', sa.String(255), nullable=True),
        sa.Column('ip_address', sa.String(50), nullable=True),
        sa.Column('platform_info', sa.Text(), nullable=True),
        sa.Column('is_active', sa.Boolean(), nullable=False, server_default='true'),
        sa.Column('last_seen', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('employee_consent', sa.Boolean(), nullable=False, server_default='false'),
        sa.Column('consent_date', sa.DateTime(), nullable=True),
        sa.Column('consent_ip', sa.String(50), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('client_id')
    )
    op.create_index('ix_clients_client_id', 'clients', ['client_id'])
    op.create_index('ix_clients_last_seen', 'clients', ['last_seen'])
    op.create_index('ix_clients_type_active', 'clients', ['client_type', 'is_active'])
    
    # Activities table with foreign key
    op.create_table(
        'activities',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('client_id', sa.String(255), nullable=False),
        sa.Column('timestamp', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('active_window', sa.Text(), nullable=True),
        sa.Column('active_application', sa.String(255), nullable=True),
        sa.Column('active_url', sa.Text(), nullable=True),
        sa.Column('processes', sa.Text(), nullable=True),
        sa.Column('process_count', sa.Integer(), nullable=False, server_default='0'),
        sa.Column('system_metrics', sa.Text(), nullable=True),
        sa.Column('cpu_percent', sa.Float(), nullable=True),
        sa.Column('memory_percent', sa.Float(), nullable=True),
        sa.Column('disk_percent', sa.Float(), nullable=True),
        sa.Column('activity_category', sa.String(50), nullable=True),
        sa.Column('productivity_score', sa.Integer(), nullable=True),
        sa.Column('additional_data', sa.Text(), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.PrimaryKeyConstraint('id'),
        sa.ForeignKeyConstraint(['client_id'], ['clients.client_id'], ondelete='CASCADE')
    )
    op.create_index('ix_activities_client_id', 'activities', ['client_id'])
    op.create_index('ix_activities_timestamp', 'activities', ['timestamp'])
    op.create_index('ix_activities_client_timestamp', 'activities', ['client_id', 'timestamp'])
    op.create_index('ix_activities_category', 'activities', ['activity_category'])
    
    # API Keys table with foreign key
    op.create_table(
        'api_keys',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('key_hash', sa.String(255), nullable=False),
        sa.Column('key_prefix', sa.String(20), nullable=False),
        sa.Column('is_active', sa.Boolean(), nullable=False, server_default='true'),
        sa.Column('last_used', sa.DateTime(), nullable=True),
        sa.Column('usage_count', sa.Integer(), nullable=False, server_default='0'),
        sa.Column('allowed_ips', sa.Text(), nullable=True),
        sa.Column('rate_limit', sa.Integer(), nullable=True),
        sa.Column('expires_at', sa.DateTime(), nullable=True),
        sa.Column('created_by', sa.Integer(), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('key_hash'),
        sa.ForeignKeyConstraint(['created_by'], ['users.id'], ondelete='SET NULL')
    )
    op.create_index('ix_api_keys_key_hash', 'api_keys', ['key_hash'])


def downgrade() -> None:
    op.drop_table('api_keys')
    op.drop_table('activities')
    op.drop_table('clients')
    op.drop_table('users')
</file>

<file path="alembic/env.py">
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context
import os
import sys

# Add parent directory to path
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from app.core.config import settings
from app.core.database import Base
from app.models import User, Client, Activity, ApiKey

# Alembic Config object
config = context.config

# Interpret the config file for Python logging
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# Set SQLAlchemy URL from settings
config.set_main_option("sqlalchemy.url", settings.DATABASE_URL)

# Target metadata
target_metadata = Base.metadata


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="app/api/routes/__init__.py">
from app.api.routes.auth import router as auth_router
from app.api.routes.clients import router as clients_router
from app.api.routes.activities import router as activities_router

__all__ = ["auth_router", "clients_router", "activities_router"]
</file>

<file path="app/api/routes/activities.py">
from fastapi import APIRouter, Depends, HTTPException, Query, status, Header
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime, timedelta

from app.core.database import get_db
from app.core.config import settings
from app.api.deps import get_current_user, verify_api_key
from app.models.user import User
from app.schemas.activity import ActivityCreate, ActivityOut, ActivityStats
from app.schemas.client import ClientCreate
from app.services.activity_service import ActivityService
from app.services.client_service import ClientService

router = APIRouter()


@router.post("/report")
async def report_activity(
    activity: ActivityCreate,
    x_api_key: str = Header(..., alias="X-API-Key"),
    db: Session = Depends(get_db)
):
    """
    Report client activity (protected by API key)
    This endpoint is used by monitoring clients to submit activity data
    """
    # Verify API key
    await verify_api_key(x_api_key, db)
    
    # Check if compliance mode is enabled
    if settings.REQUIRE_EMPLOYEE_CONSENT:
        client_service = ClientService(db)
        client = client_service.get_client(activity.client_id)
        
        # Only block if client exists and consent is explicitly missing
        if client and not client.employee_consent:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Employee consent required for monitoring. Please contact administrator."
            )
    
    # Update or create client
    client_service = ClientService(db)
    client_data = ClientCreate(
        client_id=activity.client_id,
        client_type="unknown",
        employee_consent=False
    )
    
    # Extract client info from additional_data if available
    if activity.additional_data:
        client_data.client_type = activity.additional_data.get('client_type', 'unknown')
        client_data.hostname = activity.additional_data.get('hostname')
        client_data.ip_address = activity.additional_data.get('ip_address')
        client_data.platform_info = activity.additional_data.get('platform_info')
    
    client, is_new = client_service.create_or_update_client(client_data)
    
    # Create activity record
    activity_service = ActivityService(db)
    new_activity, error = activity_service.create_activity(activity)
    
    if not new_activity:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error
        )
    
    return {
        "status": "success",
        "message": "Activity recorded successfully",
        "activity_id": new_activity.id,
        "new_client": is_new
    }


@router.get("/", response_model=List[ActivityOut])
async def get_activities(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    client_id: Optional[str] = Query(None),
    start_date: Optional[datetime] = Query(None),
    end_date: Optional[datetime] = Query(None),
    category: Optional[str] = Query(None),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get activities with filtering and pagination"""
    activity_service = ActivityService(db)
    activities = activity_service.get_activities(
        skip=skip,
        limit=limit,
        client_id=client_id,
        start_date=start_date,
        end_date=end_date,
        category=category
    )
    # Pydantic handles JSON parsing automatically now
    return activities


@router.get("/stats", response_model=ActivityStats)
async def get_activity_stats(
    client_id: Optional[str] = Query(None),
    days: int = Query(7, ge=1, le=90),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get activity statistics"""
    activity_service = ActivityService(db)
    
    start_date = datetime.utcnow() - timedelta(days=days)
    stats = activity_service.get_activity_stats(
        client_id=client_id,
        start_date=start_date
    )
    
    return ActivityStats(**stats)


@router.get("/{activity_id}", response_model=ActivityOut)
async def get_activity(
    activity_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get specific activity by ID"""
    activity_service = ActivityService(db)
    activity = activity_service.get_activity(activity_id)
    
    if not activity:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Activity not found"
        )
    
    return activity


@router.post("/cleanup")
async def cleanup_old_activities(
    days: int = Query(90, ge=7, le=365),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Cleanup activities older than specified days (admin only)"""
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin privileges required"
        )
    
    activity_service = ActivityService(db)
    deleted_count = activity_service.cleanup_old_activities(days=days)
    
    return {
        "message": f"Cleanup completed",
        "deleted_count": deleted_count,
        "retention_days": days
    }
</file>

<file path="app/api/routes/auth.py">
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from app.core.database import get_db
from app.core.config import settings
from app.api.deps import get_current_user, get_current_admin_user
from app.models.user import User
from app.schemas.user import (
    UserLogin, UserCreate, UserOut, Token, ChangePassword
)
from app.schemas.api_key import ApiKeyCreate, ApiKeyOut, ApiKeyResponse
from app.services.auth_service import AuthService

router = APIRouter()


@router.post("/login", response_model=Token)
async def login(
    user_data: UserLogin,
    db: Session = Depends(get_db)
):
    """Login user and return access token"""
    auth_service = AuthService(db)
    user, error = auth_service.authenticate_user(
        user_data.username,
        user_data.password
    )
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=error,
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token = auth_service.create_access_token_for_user(user)
    
    return Token(
        access_token=access_token,
        token_type="bearer",
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,
        force_password_change=user.force_password_change
    )


@router.post("/register", response_model=UserOut)
async def register(
    user_data: UserCreate,
    current_user: User = Depends(get_current_admin_user),
    db: Session = Depends(get_db)
):
    """Register new user (admin only)"""
    auth_service = AuthService(db)
    user, error = auth_service.create_user(
        username=user_data.username,
        password=user_data.password,
        email=user_data.email,
        is_admin=user_data.is_admin
    )
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error
        )
    
    return user


@router.get("/me", response_model=UserOut)
async def get_current_user_info(
    current_user: User = Depends(get_current_user)
):
    """Get current user information"""
    return current_user


@router.post("/change-password")
async def change_password(
    password_data: ChangePassword,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Change user password"""
    auth_service = AuthService(db)
    success, error = auth_service.change_password(
        current_user,
        password_data.current_password,
        password_data.new_password
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error
        )
    
    return {
        "message": "Password changed successfully",
        "force_password_change": False
    }


@router.post("/keys", response_model=ApiKeyResponse)
async def create_api_key(
    key_data: ApiKeyCreate,
    current_user: User = Depends(get_current_admin_user),
    db: Session = Depends(get_db)
):
    """Create new API key (admin only)"""
    auth_service = AuthService(db)
    
    # Convert list of IPs to comma-separated string
    allowed_ips = ",".join(key_data.allowed_ips) if key_data.allowed_ips else None
    
    api_key, plain_key, error = auth_service.create_api_key(
        name=key_data.name,
        created_by=current_user.id,
        allowed_ips=allowed_ips,
        rate_limit=key_data.rate_limit,
        expires_at=key_data.expires_at
    )
    
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error
        )
    
    return ApiKeyResponse(
        id=api_key.id,
        name=api_key.name,
        key=plain_key,
        key_prefix=api_key.key_prefix,
        created_at=api_key.created_at
    )


@router.get("/keys", response_model=List[ApiKeyOut])
async def list_api_keys(
    current_user: User = Depends(get_current_admin_user),
    db: Session = Depends(get_db)
):
    """List all API keys (admin only)"""
    auth_service = AuthService(db)
    return auth_service.list_api_keys()


@router.delete("/keys/{key_id}")
async def revoke_api_key(
    key_id: int,
    current_user: User = Depends(get_current_admin_user),
    db: Session = Depends(get_db)
):
    """Revoke API key (admin only)"""
    auth_service = AuthService(db)
    success, error = auth_service.revoke_api_key(key_id)
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=error
        )
    
    return {"message": "API key revoked successfully"}


@router.post("/logout")
async def logout(
    current_user: User = Depends(get_current_user)
):
    """Logout user (client-side token removal)"""
    return {"message": "Logged out successfully"}
</file>

<file path="app/api/routes/clients.py">
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.orm import Session
from typing import List, Optional

from app.core.database import get_db
from app.api.deps import get_current_user
from app.models.user import User
from app.schemas.client import ClientOut, ClientUpdate
from app.services.client_service import ClientService

router = APIRouter()


@router.get("/", response_model=List[ClientOut])
async def get_clients(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    is_active: Optional[bool] = Query(None),
    client_type: Optional[str] = Query(None),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get all clients with filtering and pagination"""
    client_service = ClientService(db)
    clients = client_service.get_clients(
        skip=skip,
        limit=limit,
        is_active=is_active,
        client_type=client_type
    )
    # Pydantic handles JSON parsing automatically
    return clients


@router.get("/online", response_model=List[ClientOut])
async def get_online_clients(
    minutes: int = Query(5, ge=1, le=60),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get clients that were active in the last N minutes"""
    client_service = ClientService(db)
    clients = client_service.get_online_clients(minutes=minutes)
    return clients


@router.get("/stats")
async def get_client_stats(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get client statistics"""
    client_service = ClientService(db)
    
    total_clients = client_service.get_client_count()
    online_clients = len(client_service.get_online_clients(minutes=5))
    
    # Get clients by type
    clients_by_type = {}
    for client_type in ['linux_desktop', 'linux_server', 'windows_desktop', 'windows_server', 'macos_desktop']:
        count = len(client_service.get_clients(client_type=client_type, limit=1000))
        if count > 0:
            clients_by_type[client_type] = count
    
    return {
        "total_clients": total_clients,
        "online_clients": online_clients,
        "offline_clients": total_clients - online_clients,
        "clients_by_type": clients_by_type
    }


@router.get("/{client_id}", response_model=ClientOut)
async def get_client(
    client_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get specific client by ID"""
    client_service = ClientService(db)
    client = client_service.get_client(client_id)
    
    if not client:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Client not found"
        )
    
    return client


@router.put("/{client_id}", response_model=ClientOut)
async def update_client(
    client_id: str,
    update_data: ClientUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update client information"""
    client_service = ClientService(db)
    client, error = client_service.update_client(client_id, update_data)
    
    if not client:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=error
        )
    
    return client


@router.delete("/{client_id}")
async def delete_client(
    client_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete client and all associated activities"""
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin privileges required"
        )
    
    client_service = ClientService(db)
    success, error = client_service.delete_client(client_id)
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=error
        )
    
    return {"message": "Client deleted successfully"}
</file>

<file path="app/api/__init__.py">
"""API routes package"""
</file>

<file path="app/api/deps.py">
from fastapi import Depends, HTTPException, status, Header
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from typing import Optional

from app.core.database import get_db
from app.core.security import verify_token
from app.models.user import User
from app.services.auth_service import AuthService

security = HTTPBearer()


async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    """Get current authenticated user from JWT token"""
    try:
        token = credentials.credentials
        payload = verify_token(token)
        username: str = payload.get("sub")
        
        if username is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication credentials",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        user = db.query(User).filter(User.username == username).first()
        if user is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        if not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Inactive user"
            )
        
        return user
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(e),
            headers={"WWW-Authenticate": "Bearer"},
        )


async def get_current_admin_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """Get current user and verify admin privileges"""
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin privileges required"
        )
    return current_user


async def verify_api_key(
    x_api_key: Optional[str] = Header(None, alias="X-API-Key"),
    db: Session = Depends(get_db)
) -> bool:
    """Verify API key from header"""
    if not x_api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API key required",
            headers={"WWW-Authenticate": "ApiKey"},
        )
    
    auth_service = AuthService(db)
    api_key, error = auth_service.verify_api_key(x_api_key)
    
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=error,
            headers={"WWW-Authenticate": "ApiKey"},
        )
    
    return True
</file>

<file path="app/core/__init__.py">
"""
Core application configuration and utilities
"""
</file>

<file path="app/core/config.py">
from pydantic_settings import BaseSettings
from typing import List, Optional
import secrets


class Settings(BaseSettings):
    """Application settings with validation"""
    
    # Application
    PROJECT_NAME: str = "Sentinel"
    ENVIRONMENT: str = "development"
    DEBUG: bool = False
    API_VERSION: str = "v1"
    
    # Database
    DATABASE_URL: str
    DATABASE_POOL_SIZE: int = 20
    DATABASE_MAX_OVERFLOW: int = 40
    
    # Security
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 1440  # 24 hours
    
    # CORS - Changed to handle comma-separated string
    ALLOWED_ORIGINS: str = "http://localhost:3000"
    
    # Rate Limiting
    RATE_LIMIT_PER_MINUTE: int = 60
    RATE_LIMIT_PER_HOUR: int = 1000
    
    # Admin
    INITIAL_ADMIN_USERNAME: str = "admin"
    INITIAL_ADMIN_PASSWORD: str
    FORCE_ADMIN_PASSWORD_CHANGE: bool = True
    
    # Data Retention
    ACTIVITY_RETENTION_DAYS: int = 90
    LOG_RETENTION_DAYS: int = 30
    
    # Compliance
    REQUIRE_EMPLOYEE_CONSENT: bool = True
    ENABLE_AUDIT_LOGGING: bool = True
    
    # Redis
    REDIS_URL: Optional[str] = None
    
    # TLS
    REQUIRE_HTTPS: bool = False
    
    class Config:
        env_file = ".env"
        case_sensitive = True
    
    def get_allowed_origins(self) -> List[str]:
        """Parse ALLOWED_ORIGINS from comma-separated string"""
        if isinstance(self.ALLOWED_ORIGINS, str):
            return [origin.strip() for origin in self.ALLOWED_ORIGINS.split(",")]
        return self.ALLOWED_ORIGINS
    
    def validate_settings(self) -> List[str]:
        """Validate critical settings"""
        errors = []
        
        if self.SECRET_KEY == "CHANGE_THIS_TO_A_SECURE_RANDOM_KEY_AT_LEAST_32_CHARS":
            errors.append("SECRET_KEY must be changed from default value")
        
        if len(self.SECRET_KEY) < 32:
            errors.append("SECRET_KEY must be at least 32 characters")
        
        if self.INITIAL_ADMIN_PASSWORD == "CHANGE_THIS_IMMEDIATELY":
            errors.append("INITIAL_ADMIN_PASSWORD must be changed")
        
        if not self.DATABASE_URL.startswith("postgresql://"):
            errors.append("DATABASE_URL must be PostgreSQL")
        
        if self.ENVIRONMENT == "production" and self.DEBUG:
            errors.append("DEBUG must be False in production")
        
        if self.ENVIRONMENT == "production" and "*" in self.ALLOWED_ORIGINS:
            errors.append("ALLOWED_ORIGINS cannot contain '*' in production")
        
        return errors


settings = Settings()

# Validate settings on startup
validation_errors = settings.validate_settings()
if validation_errors and settings.ENVIRONMENT == "production":
    raise ValueError(f"Configuration errors: {', '.join(validation_errors)}")
elif validation_errors:
    print("⚠️  Configuration warnings:")
    for error in validation_errors:
        print(f"  - {error}")
</file>

<file path="app/core/database.py">
from sqlalchemy import create_engine, event, text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.pool import NullPool
import logging

from app.core.config import settings

logger = logging.getLogger(__name__)

# Create engine with connection pooling
engine = create_engine(
    settings.DATABASE_URL,
    pool_size=settings.DATABASE_POOL_SIZE,
    max_overflow=settings.DATABASE_MAX_OVERFLOW,
    pool_pre_ping=True,  # Verify connections before using
    echo=settings.DEBUG,
)

# Create session factory
SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

# Base class for models
Base = declarative_base()


def get_db():
    """Dependency to get database session"""
    db = SessionLocal()
    try:
        yield db
    except Exception as e:
        logger.error(f"Database error: {e}")
        db.rollback()
        raise
    finally:
        db.close()


def init_db():
    """Initialize database tables"""
    try:
        Base.metadata.create_all(bind=engine)
        logger.info("✅ Database tables created successfully")
    except Exception as e:
        logger.error(f"❌ Error creating database tables: {e}")
        raise


def check_db_connection() -> bool:
    """Check if database connection is working"""
    try:
        with engine.connect() as conn:
            conn.execute(text("SELECT 1"))
        return True
    except Exception as e:
        logger.error(f"Database connection failed: {e}")
        return False
</file>

<file path="app/core/security.py">
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from jose import JWTError, jwt
from passlib.context import CryptContext
import secrets
import hashlib
import re

from app.core.config import settings

# Password hashing context
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against a hash"""
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    """Hash a password"""
    return pwd_context.hash(password)


def validate_password_strength(password: str) -> tuple[bool, str]:
    """
    Validate password meets security requirements
    Returns: (is_valid, error_message)
    """
    if len(password) < 8:
        return False, "Password must be at least 8 characters long"
    
    if len(password) > 128:
        return False, "Password must be less than 128 characters"
    
    if not re.search(r"[a-z]", password):
        return False, "Password must contain at least one lowercase letter"
    
    if not re.search(r"[A-Z]", password):
        return False, "Password must contain at least one uppercase letter"
    
    if not re.search(r"\d", password):
        return False, "Password must contain at least one number"
    
    if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
        return False, "Password must contain at least one special character"
    
    # Check for common passwords
    common_passwords = ["Password123!", "Admin123!", "Welcome123!"]
    if password in common_passwords:
        return False, "Password is too common"
    
    return True, ""


def create_access_token(
    data: Dict[str, Any],
    expires_delta: Optional[timedelta] = None
) -> str:
    """Create JWT access token"""
    to_encode = data.copy()
    
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(
            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
        )
    
    to_encode.update({
        "exp": expire,
        "iat": datetime.utcnow(),
        "type": "access"
    })
    
    encoded_jwt = jwt.encode(
        to_encode,
        settings.SECRET_KEY,
        algorithm=settings.ALGORITHM
    )
    return encoded_jwt


def verify_token(token: str) -> Dict[str, Any]:
    """Verify JWT token and return payload"""
    try:
        payload = jwt.decode(
            token,
            settings.SECRET_KEY,
            algorithms=[settings.ALGORITHM]
        )
        return payload
    except JWTError as e:
        raise ValueError(f"Invalid token: {str(e)}")


def generate_api_key() -> str:
    """Generate a secure API key"""
    return f"sk_{secrets.token_urlsafe(32)}"


def hash_api_key(api_key: str) -> str:
    """Hash an API key for storage using bcrypt"""
    return pwd_context.hash(api_key)


def verify_api_key(plain_key: str, hashed_key: str) -> bool:
    """Verify an API key against its bcrypt hash"""
    return pwd_context.verify(plain_key, hashed_key)
</file>

<file path="app/middleware/__init__.py">
from app.middleware.rate_limit import RateLimitMiddleware
from app.middleware.logging import LoggingMiddleware

__all__ = ["RateLimitMiddleware", "LoggingMiddleware"]
</file>

<file path="app/middleware/logging.py">
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
import time
import logging

logger = logging.getLogger(__name__)


class LoggingMiddleware(BaseHTTPMiddleware):
    """Log all requests and responses"""
    
    async def dispatch(self, request: Request, call_next):
        start_time = time.time()
        
        # Log request
        logger.info(f"Request: {request.method} {request.url.path}")
        
        try:
            response = await call_next(request)
            process_time = time.time() - start_time
            
            # Log response
            logger.info(
                f"Response: {request.method} {request.url.path} "
                f"Status: {response.status_code} "
                f"Duration: {process_time:.3f}s"
            )
            
            # Add custom header
            response.headers["X-Process-Time"] = str(process_time)
            
            return response
        except Exception as e:
            process_time = time.time() - start_time
            logger.error(
                f"Error: {request.method} {request.url.path} "
                f"Duration: {process_time:.3f}s "
                f"Error: {str(e)}"
            )
            raise
</file>

<file path="app/middleware/rate_limit.py">
from fastapi import Request, HTTPException, status
from starlette.middleware.base import BaseHTTPMiddleware
from datetime import datetime, timedelta
from typing import Dict, List
import logging

logger = logging.getLogger(__name__)


class RateLimitMiddleware(BaseHTTPMiddleware):
    """
    Production-safe rate limiting middleware with Proxy support
    """

    def __init__(self, app, requests_per_minute: int = 100):
        super().__init__(app)
        self.requests_per_minute = requests_per_minute
        self.requests: Dict[str, List[datetime]] = {}
        # Trust traffic from Docker internal networks
        self.trusted_proxies = ("172.", "10.", "192.168.", "127.0.0.1")
        
        self.excluded_paths = {
            "/health",
            "/api/v1/auth/me",
            "/docs",
            "/redoc",
            "/openapi.json"
        }

    def _is_internal(self, ip: str) -> bool:
        """Check if IP is from internal network"""
        return ip.startswith(self.trusted_proxies)
    
    def _is_excluded_path(self, path: str) -> bool:
        return path in self.excluded_paths or path.startswith("/static/")

    def _get_client_ip(self, request: Request) -> str:
        """
        Get real client IP, respecting X-Forwarded-For only from trusted proxies.
        """
        client_host = request.client.host
        
        # If request comes from a trusted proxy (Nginx), use X-Forwarded-For
        if self._is_internal(client_host):
            forwarded_for = request.headers.get("X-Forwarded-For")
            if forwarded_for:
                # Get the first IP in the list (original client)
                return forwarded_for.split(",")[0].strip()
        
        return client_host

    def _get_identity(self, request: Request) -> str:
        user_id = getattr(request.state, "user_id", None)
        if user_id:
            return f"user:{user_id}"

        return f"ip:{self._get_client_ip(request)}"

    async def dispatch(self, request: Request, call_next):
        # Skip excluded paths
        if self._is_excluded_path(request.url.path):
            return await call_next(request)

        # We do NOT skip internal IPs here anymore, because Nginx is internal.
        # We now identify based on the _real_ IP resolved in _get_identity.
        
        identity = self._get_identity(request)
        now = datetime.utcnow()

        # Remove timestamps older than 1 minute
        bucket = self.requests.get(identity, [])
        bucket = [t for t in bucket if now - t < timedelta(minutes=1)]

        if len(bucket) >= self.requests_per_minute:
            logger.warning(f"Rate limit exceeded for {identity} on path {request.url.path}")
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail="Rate limit exceeded. Please try again later.",
                headers={"Retry-After": "60"}
            )

        bucket.append(now)
        self.requests[identity] = bucket

        return await call_next(request)
</file>

<file path="app/models/__init__.py">
from app.models.user import User
from app.models.client import Client
from app.models.activity import Activity
from app.models.api_key import ApiKey

__all__ = ["User", "Client", "Activity", "ApiKey"]
</file>

<file path="app/models/activity.py">
from sqlalchemy import Column, Integer, String, DateTime, Text, Index, Float, ForeignKey
from sqlalchemy.orm import relationship
from datetime import datetime
from app.core.database import Base


class Activity(Base):
    __tablename__ = "activities"
    
    id = Column(Integer, primary_key=True, index=True)
    client_id = Column(String(255), ForeignKey('clients.client_id', ondelete='CASCADE'), index=True, nullable=False)
    timestamp = Column(DateTime, default=datetime.utcnow, index=True, nullable=False)
    
    # Activity data
    active_window = Column(Text, nullable=True)
    active_application = Column(String(255), nullable=True)
    active_url = Column(Text, nullable=True)
    
    # Process information
    processes = Column(Text, nullable=True)  # JSON string
    process_count = Column(Integer, default=0)
    
    # System metrics
    system_metrics = Column(Text, nullable=True)  # JSON string
    cpu_percent = Column(Float, nullable=True)
    memory_percent = Column(Float, nullable=True)
    disk_percent = Column(Float, nullable=True)
    
    # Categorization
    activity_category = Column(String(50), nullable=True)
    productivity_score = Column(Integer, nullable=True)
    
    # Additional data
    additional_data = Column(Text, nullable=True)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Relationship
    client = relationship("Client", back_populates="activities")
    
    # Indexes
    __table_args__ = (
        Index('ix_activities_client_timestamp', 'client_id', 'timestamp'),
        Index('ix_activities_category', 'activity_category'),
    )
    
    def __repr__(self):
        return f"<Activity(id={self.id}, client_id='{self.client_id}', timestamp={self.timestamp})>"
</file>

<file path="app/models/api_key.py">
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text, ForeignKey
from sqlalchemy.orm import relationship
from datetime import datetime
from app.core.database import Base


class ApiKey(Base):
    __tablename__ = "api_keys"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False)
    key_hash = Column(String(255), unique=True, index=True, nullable=False)
    key_prefix = Column(String(20), nullable=False)
    
    # Status
    is_active = Column(Boolean, default=True, nullable=False)
    
    # Usage tracking
    last_used = Column(DateTime, nullable=True)
    usage_count = Column(Integer, default=0, nullable=False)
    
    # Restrictions
    allowed_ips = Column(Text, nullable=True)
    rate_limit = Column(Integer, nullable=True)
    expires_at = Column(DateTime, nullable=True)
    
    # Metadata
    created_by = Column(Integer, ForeignKey('users.id', ondelete='SET NULL'), nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationship
    creator = relationship("User")
    
    def __repr__(self):
        return f"<ApiKey(id={self.id}, name='{self.name}', active={self.is_active})>"
</file>

<file path="app/models/client.py">
from sqlalchemy import Column, Integer, String, DateTime, Text, Boolean, Index
from sqlalchemy.orm import relationship
from datetime import datetime
from app.core.database import Base


class Client(Base):
    __tablename__ = "clients"
    
    id = Column(Integer, primary_key=True, index=True)
    client_id = Column(String(255), unique=True, index=True, nullable=False)
    client_type = Column(String(50), nullable=False)
    hostname = Column(String(255), nullable=True)
    ip_address = Column(String(50), nullable=True)
    platform_info = Column(Text, nullable=True)
    
    # Status
    is_active = Column(Boolean, default=True, nullable=False)
    last_seen = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Consent and compliance
    employee_consent = Column(Boolean, default=False, nullable=False)
    consent_date = Column(DateTime, nullable=True)
    consent_ip = Column(String(50), nullable=True)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    activities = relationship("Activity", back_populates="client", cascade="all, delete-orphan")
    
    # Indexes
    __table_args__ = (
        Index('ix_clients_last_seen', 'last_seen'),
        Index('ix_clients_type_active', 'client_type', 'is_active'),
    )
    
    def __repr__(self):
        return f"<Client(id={self.id}, client_id='{self.client_id}', type='{self.client_type}')>"
</file>

<file path="app/models/user.py">
from sqlalchemy import Column, Integer, String, Boolean, DateTime
from datetime import datetime
from app.core.database import Base


class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, index=True, nullable=False)
    email = Column(String(255), unique=True, index=True, nullable=True)
    hashed_password = Column(String(255), nullable=False)
    is_admin = Column(Boolean, default=False, nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    force_password_change = Column(Boolean, default=False, nullable=False)
    failed_login_attempts = Column(Integer, default=0, nullable=False)
    last_login = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f"<User(id={self.id}, username='{self.username}', is_admin={self.is_admin})>"
</file>

<file path="app/schemas/__init__.py">
from app.schemas.user import (
    UserLogin, UserCreate, UserOut, UserUpdate,
    Token, ChangePassword
)
from app.schemas.client import ClientOut, ClientCreate, ClientUpdate
from app.schemas.activity import ActivityOut, ActivityCreate, ActivityStats
from app.schemas.api_key import ApiKeyCreate, ApiKeyOut, ApiKeyResponse

__all__ = [
    "UserLogin", "UserCreate", "UserOut", "UserUpdate",
    "Token", "ChangePassword",
    "ClientOut", "ClientCreate", "ClientUpdate",
    "ActivityOut", "ActivityCreate", "ActivityStats",
    "ApiKeyCreate", "ApiKeyOut", "ApiKeyResponse"
]
</file>

<file path="app/schemas/activity.py">
from pydantic import BaseModel, field_validator, HttpUrl, Field
from typing import Optional, List, Dict, Any
from datetime import datetime
import json
import re


class ActivityCreate(BaseModel):
    client_id: str = Field(..., min_length=1, max_length=255, pattern=r'^[a-zA-Z0-9_\-.:]+$')
    timestamp: Optional[datetime] = None
    active_window: Optional[str] = Field(None, max_length=1000)
    active_application: Optional[str] = Field(None, max_length=255)
    active_url: Optional[str] = Field(None, max_length=2000)
    processes: Optional[List[Dict[str, Any]]] = None
    system_metrics: Optional[Dict[str, Any]] = None
    additional_data: Optional[Dict[str, Any]] = None

    @field_validator('active_url')
    @classmethod
    def validate_url_length(cls, v):
        if v and len(v) > 2000:
            raise ValueError('URL too long')
        return v

    @field_validator('processes')
    @classmethod
    def validate_processes_length(cls, v):
        if v and len(v) > 1000:
            raise ValueError('Too many processes')
        return v

    @field_validator('system_metrics', 'additional_data')
    @classmethod
    def validate_json_size(cls, v):
        if v and len(json.dumps(v)) > 10000:
            raise ValueError('Data too large')
        return v
</file>

<file path="app/schemas/api_key.py">
from pydantic import BaseModel, validator
from typing import Optional, List
from datetime import datetime


class ApiKeyCreate(BaseModel):
    name: str
    allowed_ips: Optional[List[str]] = None
    rate_limit: Optional[int] = None
    expires_at: Optional[datetime] = None
    
    @validator('name')
    def name_length(cls, v):
        if len(v) < 3 or len(v) > 255:
            raise ValueError('Name must be between 3 and 255 characters')
        return v


class ApiKeyOut(BaseModel):
    id: int
    name: str
    key_prefix: str
    is_active: bool
    last_used: Optional[datetime] = None
    usage_count: int
    allowed_ips: Optional[str] = None
    rate_limit: Optional[int] = None
    expires_at: Optional[datetime] = None
    created_at: datetime
    
    class Config:
        from_attributes = True


class ApiKeyResponse(BaseModel):
    """Response when creating a new API key - includes full key"""
    id: int
    name: str
    key: str  # Full API key - only shown once
    key_prefix: str
    created_at: datetime
    
    class Config:
        from_attributes = True
</file>

<file path="app/schemas/client.py">
from pydantic import BaseModel, validator, field_validator, constr
from typing import Optional, Dict, Any
from datetime import datetime
import json
import ipaddress


class ClientCreate(BaseModel):
    client_id: constr(min_length=1, max_length=255, pattern=r'^[a-zA-Z0-9_\-.:]+$')
    client_type: str
    hostname: Optional[constr(max_length=255)] = None
    ip_address: Optional[str] = None
    platform_info: Optional[Dict[str, Any]] = None
    employee_consent: bool = False

    @validator('client_type')
    def validate_client_type(cls, v):
        valid_types = ['linux_desktop', 'linux_server', 'windows_desktop', 'windows_server', 'macos_desktop']
        if v not in valid_types:
            raise ValueError(f'client_type must be one of {valid_types}')
        return v

    @validator('ip_address')
    def validate_ip_address(cls, v):
        if v:
            try:
                ipaddress.ip_address(v)
            except ValueError:
                raise ValueError('Invalid IP address format')
        return v

    @validator('platform_info')
    def validate_platform_info_size(cls, v):
        if v and len(json.dumps(v)) > 5000:
            raise ValueError('Platform info too large')
        return v
</file>

<file path="app/schemas/user.py">
from pydantic import BaseModel, EmailStr, validator, Field
from typing import Optional
from datetime import datetime

from app.core.security import validate_password_strength


class UserLogin(BaseModel):
    username: str = Field(..., min_length=1, max_length=50)
    password: str


class UserCreate(BaseModel):
    username: str = Field(..., min_length=3, max_length=50, pattern=r'^[a-zA-Z0-9_-]+$')
    email: Optional[EmailStr] = None
    password: str
    is_admin: bool = False

    @validator('username')
    def username_alphanumeric(cls, v):
        if not v.replace('_', '').replace('-', '').isalnum():
            raise ValueError('Username must be alphanumeric (with _ or -)')
        return v


class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    is_active: Optional[bool] = None


class UserOut(BaseModel):
    id: int
    username: str
    email: Optional[str] = None
    is_admin: bool
    is_active: bool
    force_password_change: bool
    last_login: Optional[datetime] = None
    created_at: datetime

    class Config:
        from_attributes = True


class Token(BaseModel):
    access_token: str
    token_type: str
    expires_in: int
    force_password_change: bool = False


class ChangePassword(BaseModel):
    current_password: str
    new_password: str = Field(..., min_length=8, max_length=128)

    @validator('new_password')
    def password_strength(cls, v):
        is_valid, error = validate_password_strength(v)
        if not is_valid:
            raise ValueError(error)
        return v
</file>

<file path="app/services/__init__.py">
from app.services.auth_service import AuthService
from app.services.client_service import ClientService
from app.services.activity_service import ActivityService

__all__ = ["AuthService", "ClientService", "ActivityService"]
</file>

<file path="app/services/activity_service.py">
from sqlalchemy.orm import Session
from sqlalchemy import func, desc
from typing import Optional, List, Dict, Any, Tuple
from datetime import datetime, timedelta
import json
import logging
import html

from app.models.activity import Activity
from app.schemas.activity import ActivityCreate

logger = logging.getLogger(__name__)


class ActivityService:
    def __init__(self, db: Session):
        self.db = db
    
    def sanitize_string(self, text: Optional[str]) -> Optional[str]:
        """Sanitize string input to prevent XSS"""
        if not text:
            return None
        # Escape HTML characters
        return html.escape(text.strip())[:10000]  # Limit length
    
    def create_activity(self, activity_data: ActivityCreate) -> Tuple[Optional[Activity], str]:
        """
        Create new activity record with input sanitization
        Returns: (activity, error_message)
        """
        try:
            # Sanitize inputs
            sanitized_window = self.sanitize_string(activity_data.active_window)
            sanitized_application = self.sanitize_string(activity_data.active_application)
            sanitized_url = self.sanitize_string(activity_data.active_url)
            
            # Validate client_id format
            if not re.match(r'^[a-zA-Z0-9_\-.:]+$', activity_data.client_id):
                return None, "Invalid client ID format"
            
            # Extract metrics
            cpu_percent = None
            memory_percent = None
            disk_percent = None
            
            if activity_data.system_metrics:
                # Validate system metrics values
                cpu_percent = min(max(0, activity_data.system_metrics.get('cpu_percent', 0)), 100)
                memory_percent = min(max(0, activity_data.system_metrics.get('memory_percent', 0)), 100)
                disk_percent = min(max(0, activity_data.system_metrics.get('disk_percent', 0)), 100)
            
            # Validate process count
            process_count = len(activity_data.processes) if activity_data.processes else 0
            if process_count > 1000:
                process_count = 1000  # Cap at reasonable limit
            
            # Categorize activity
            category = self._categorize_activity(sanitized_window, sanitized_application, sanitized_url)
            
            # Calculate productivity score
            productivity_score = self._calculate_productivity_score(category, process_count, cpu_percent)
            
            activity = Activity(
                client_id=activity_data.client_id,
                timestamp=activity_data.timestamp or datetime.utcnow(),
                active_window=sanitized_window,
                active_application=sanitized_application,
                active_url=sanitized_url,
                processes=json.dumps(activity_data.processes[:100]) if activity_data.processes else None,  # Limit processes
                process_count=process_count,
                system_metrics=json.dumps(activity_data.system_metrics) if activity_data.system_metrics else None,
                cpu_percent=cpu_percent,
                memory_percent=memory_percent,
                disk_percent=disk_percent,
                activity_category=category,
                productivity_score=productivity_score,
                additional_data=json.dumps(activity_data.additional_data) if activity_data.additional_data else None
            )
            
            self.db.add(activity)
            self.db.commit()
            self.db.refresh(activity)
            
            return activity, ""
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error creating activity: {e}")
            return None, "Error creating activity"
    
    # ... rest of the class remains the same ...
</file>

<file path="app/services/auth_service.py">
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from typing import Optional, Tuple
import logging
from fastapi import Request

from app.core.security import (
    verify_password,
    get_password_hash,
    create_access_token,
    validate_password_strength,
)
from app.models.user import User
from app.models.api_key import ApiKey
from app.core.security import hash_api_key, verify_api_key, generate_api_key
from app.core.config import settings

logger = logging.getLogger(__name__)


class AuthService:
    def __init__(self, db: Session):
        self.db = db

    def authenticate_user(
        self,
        username: str,
        password: str,
        request: Optional[Request] = None,
    ) -> Tuple[Optional[User], str]:
        """
        Authenticate a user by username + password.
        Uses constant-time comparison principles where possible to reduce timing leaks.
        """
        user = self.db.query(User).filter(User.username == username).first()
        
        # If user doesn't exist, we still verify a dummy password to prevent timing attacks
        if not user:
            # This is a dummy verify to take up time
            verify_password(password, "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWrn.96pprCtk.iYF3d4.n.n.n.n")
            logger.warning(f"Login attempt for non-existent user: {username}")
            return None, "Invalid credentials"

        if not verify_password(password, user.hashed_password):
            user.failed_login_attempts += 1
            self.db.commit()
            logger.warning(f"Failed login attempt for user: {username}")
            return None, "Invalid credentials"

        # Check status after password verification to verify credentials first
        if not user.is_active:
            logger.warning(f"Login attempt for inactive user: {username}")
            return None, "Account is disabled"

        if user.failed_login_attempts >= 5:
            logger.warning(f"Account locked due to failed attempts: {username}")
            return None, "Account is temporarily locked. Contact administrator."

        # Successful login
        user.failed_login_attempts = 0
        user.last_login = datetime.utcnow()
        self.db.commit()

        # Inject user_id for rate limiting if request context is provided
        if request is not None:
            request.state.user_id = user.id

        logger.info(f"Successful login: {username}")
        return user, ""

    def create_user(
        self,
        username: str,
        password: str,
        email: Optional[str] = None,
        is_admin: bool = False,
    ) -> Tuple[Optional[User], str]:

        existing_user = self.db.query(User).filter(User.username == username).first()
        if existing_user:
            return None, "Username already exists"

        if email:
            existing_email = self.db.query(User).filter(User.email == email).first()
            if existing_email:
                return None, "Email already exists"

        is_valid, error = validate_password_strength(password)
        if not is_valid:
            return None, error

        try:
            user = User(
                username=username,
                email=email,
                hashed_password=get_password_hash(password),
                is_admin=is_admin,
                is_active=True,
            )
            self.db.add(user)
            self.db.commit()
            self.db.refresh(user)

            logger.info(f"User created: {username}")
            return user, ""
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error creating user: {e}")
            return None, "Error creating user"

    def change_password(
        self, user: User, current_password: str, new_password: str
    ) -> Tuple[bool, str]:
        if not verify_password(current_password, user.hashed_password):
            logger.warning(f"Failed password change attempt for user: {user.username}")
            return False, "Current password is incorrect"

        is_valid, error = validate_password_strength(new_password)
        if not is_valid:
            return False, error

        if verify_password(new_password, user.hashed_password):
            return False, "New password must be different from current password"

        try:
            user.hashed_password = get_password_hash(new_password)
            user.force_password_change = False
            self.db.commit()

            logger.info(f"Password changed for user: {user.username}")
            return True, ""
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error changing password: {e}")
            return False, "Error changing password"

    def create_access_token_for_user(self, user: User) -> str:
        access_token_expires = timedelta(
            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
        )
        access_token = create_access_token(
            data={"sub": user.username, "admin": user.is_admin},
            expires_delta=access_token_expires,
        )
        return access_token

    def create_api_key(
        self,
        name: str,
        created_by: int,
        allowed_ips: Optional[str] = None,
        rate_limit: Optional[int] = None,
        expires_at: Optional[datetime] = None,
    ) -> Tuple[Optional[ApiKey], Optional[str], str]:

        try:
            plain_key = generate_api_key()
            key_hash = hash_api_key(plain_key)
            key_prefix = plain_key[:10]

            api_key = ApiKey(
                name=name,
                key_hash=key_hash,
                key_prefix=key_prefix,
                created_by=created_by,
                allowed_ips=allowed_ips,
                rate_limit=rate_limit,
                expires_at=expires_at,
                is_active=True,
            )

            self.db.add(api_key)
            self.db.commit()
            self.db.refresh(api_key)

            logger.info(f"API key created: {name}")
            return api_key, plain_key, ""
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error creating API key: {e}")
            return None, None, "Error creating API key"

    def verify_api_key(self, api_key: str) -> Tuple[Optional[ApiKey], str]:
        if not api_key or not api_key.startswith("sk_"):
            return None, "Invalid API key format"

        key_hash = hash_api_key(api_key)

        db_api_key = (
            self.db.query(ApiKey)
            .filter(ApiKey.key_hash == key_hash, ApiKey.is_active == True)
            .first()
        )

        if not db_api_key:
            logger.warning(f"Invalid API key attempt: {api_key[:10]}...")
            return None, "Invalid API key"

        if db_api_key.expires_at and db_api_key.expires_at < datetime.utcnow():
            logger.warning(f"Expired API key used: {db_api_key.name}")
            return None, "API key has expired"

        db_api_key.last_used = datetime.utcnow()
        db_api_key.usage_count += 1
        self.db.commit()

        return db_api_key, ""

    def revoke_api_key(self, key_id: int) -> Tuple[bool, str]:
        api_key = self.db.query(ApiKey).filter(ApiKey.id == key_id).first()
        if not api_key:
            return False, "API key not found"

        try:
            api_key.is_active = False
            self.db.commit()
            logger.info(f"API key revoked: {api_key.name}")
            return True, ""
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error revoking API key: {e}")
            return False, "Error revoking API key"

    def list_api_keys(self) -> list[ApiKey]:
        return (
            self.db.query(ApiKey)
            .filter(ApiKey.is_active == True)
            .order_by(ApiKey.created_at.desc())
            .all()
        )


def create_initial_admin():
    from app.core.database import SessionLocal

    db = SessionLocal()
    try:
        admin = (
            db.query(User)
            .filter(User.username == settings.INITIAL_ADMIN_USERNAME)
            .first()
        )
        if not admin:
            is_valid, error = validate_password_strength(
                settings.INITIAL_ADMIN_PASSWORD
            )
            if not is_valid:
                logger.error(
                    f"Initial admin password not strong enough: {error}"
                )
                return

            admin = User(
                username=settings.INITIAL_ADMIN_USERNAME,
                email=None,
                hashed_password=get_password_hash(
                    settings.INITIAL_ADMIN_PASSWORD
                ),
                is_admin=True,
                is_active=True,
                force_password_change=settings.FORCE_ADMIN_PASSWORD_CHANGE,
            )
            db.add(admin)
            db.commit()
            logger.info(
                f"Created initial admin user: {settings.INITIAL_ADMIN_USERNAME}"
            )
        else:
            logger.info("Admin user already exists")
    except Exception as e:
        db.rollback()
        logger.error(f"Error creating initial admin: {e}")
    finally:
        db.close()
</file>

<file path="app/services/client_service.py">
from sqlalchemy.orm import Session
from typing import Optional, List, Tuple
from datetime import datetime, timedelta
import json
import logging

from app.models.client import Client
from app.schemas.client import ClientCreate, ClientUpdate

logger = logging.getLogger(__name__)


class ClientService:
    def __init__(self, db: Session):
        self.db = db
    
    def get_client(self, client_id: str) -> Optional[Client]:
        """Get client by ID"""
        return self.db.query(Client).filter(Client.client_id == client_id).first()
    
    def get_clients(
        self,
        skip: int = 0,
        limit: int = 100,
        is_active: Optional[bool] = None,
        client_type: Optional[str] = None
    ) -> List[Client]:
        """Get clients with filtering"""
        query = self.db.query(Client)
        
        if is_active is not None:
            query = query.filter(Client.is_active == is_active)
        
        if client_type:
            query = query.filter(Client.client_type == client_type)
        
        return query.order_by(Client.last_seen.desc()).offset(skip).limit(limit).all()
    
    def create_or_update_client(
        self,
        client_data: ClientCreate
    ) -> Tuple[Client, bool]:
        """
        Create or update client
        Returns: (client, is_new)
        """
        client = self.get_client(client_data.client_id)
        is_new = False
        
        try:
            if client:
                # Update existing client
                client.last_seen = datetime.utcnow()
                if client_data.hostname:
                    client.hostname = client_data.hostname
                if client_data.ip_address:
                    client.ip_address = client_data.ip_address
                if client_data.platform_info:
                    client.platform_info = json.dumps(client_data.platform_info)
                if client_data.employee_consent:
                    if not client.employee_consent:
                        client.employee_consent = True
                        client.consent_date = datetime.utcnow()
                        client.consent_ip = client_data.ip_address
            else:
                # Create new client
                is_new = True
                client = Client(
                    client_id=client_data.client_id,
                    client_type=client_data.client_type,
                    hostname=client_data.hostname,
                    ip_address=client_data.ip_address,
                    platform_info=json.dumps(client_data.platform_info) if client_data.platform_info else None,
                    employee_consent=client_data.employee_consent,
                    consent_date=datetime.utcnow() if client_data.employee_consent else None,
                    consent_ip=client_data.ip_address if client_data.employee_consent else None,
                    is_active=True
                )
                self.db.add(client)
            
            self.db.commit()
            self.db.refresh(client)
            
            if is_new:
                logger.info(f"New client registered: {client.client_id}")
            
            return client, is_new
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error creating/updating client: {e}")
            raise
    
    def update_client(
        self,
        client_id: str,
        update_data: ClientUpdate
    ) -> Tuple[Optional[Client], str]:
        """
        Update client
        Returns: (client, error_message)
        """
        client = self.get_client(client_id)
        if not client:
            return None, "Client not found"
        
        try:
            if update_data.hostname is not None:
                client.hostname = update_data.hostname
            if update_data.ip_address is not None:
                client.ip_address = update_data.ip_address
            if update_data.platform_info is not None:
                client.platform_info = json.dumps(update_data.platform_info)
            if update_data.is_active is not None:
                client.is_active = update_data.is_active
            if update_data.employee_consent is not None and update_data.employee_consent:
                if not client.employee_consent:
                    client.employee_consent = True
                    client.consent_date = datetime.utcnow()
            
            client.updated_at = datetime.utcnow()
            self.db.commit()
            self.db.refresh(client)
            
            logger.info(f"Client updated: {client_id}")
            return client, ""
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error updating client: {e}")
            return None, "Error updating client"
    
    def delete_client(self, client_id: str) -> Tuple[bool, str]:
        """
        Delete client
        Returns: (success, error_message)
        """
        client = self.get_client(client_id)
        if not client:
            return False, "Client not found"
        
        try:
            self.db.delete(client)
            self.db.commit()
            logger.info(f"Client deleted: {client_id}")
            return True, ""
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error deleting client: {e}")
            return False, "Error deleting client"
    
    def get_online_clients(self, minutes: int = 5) -> List[Client]:
        """Get clients that were active in the last N minutes"""
        threshold = datetime.utcnow() - timedelta(minutes=minutes)
        return self.db.query(Client).filter(
            Client.last_seen >= threshold,
            Client.is_active == True
        ).all()
    
    def get_client_count(self) -> int:
        """Get total client count"""
        return self.db.query(Client).filter(Client.is_active == True).count()
</file>

<file path="app/tests/__init__.py">
"""
Test suite for Sentinel backend
"""
</file>

<file path="app/tests/conftest.py">
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool

from app.main import app
from app.core.database import Base, get_db
from app.core.security import get_password_hash
from app.models.user import User

# Test database URL
SQLALCHEMY_DATABASE_URL = "sqlite:///:memory:"

# Create test engine
engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    connect_args={"check_same_thread": False},
    poolclass=StaticPool,
)

TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


@pytest.fixture(scope="function")
def db_session():
    """Create a fresh database for each test"""
    Base.metadata.create_all(bind=engine)
    session = TestingSessionLocal()
    try:
        yield session
    finally:
        session.close()
        Base.metadata.drop_all(bind=engine)


@pytest.fixture(scope="function")
def client(db_session):
    """Create test client with test database"""
    def override_get_db():
        try:
            yield db_session
        finally:
            pass
    
    app.dependency_overrides[get_db] = override_get_db
    with TestClient(app) as test_client:
        yield test_client
    app.dependency_overrides.clear()


@pytest.fixture(scope="function")
def test_user(db_session):
    """Create a test user"""
    user = User(
        username="testuser",
        email="test@example.com",
        hashed_password=get_password_hash("Test123!@#"),
        is_admin=False,
        is_active=True
    )
    db_session.add(user)
    db_session.commit()
    db_session.refresh(user)
    return user


@pytest.fixture(scope="function")
def test_admin(db_session):
    """Create a test admin user"""
    admin = User(
        username="admin",
        email="admin@example.com",
        hashed_password=get_password_hash("Admin123!@#"),
        is_admin=True,
        is_active=True
    )
    db_session.add(admin)
    db_session.commit()
    db_session.refresh(admin)
    return admin


@pytest.fixture(scope="function")
def auth_headers(client, test_user):
    """Get authentication headers for test user"""
    response = client.post(
        "/api/v1/auth/login",
        json={"username": "testuser", "password": "Test123!@#"}
    )
    token = response.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}


@pytest.fixture(scope="function")
def admin_headers(client, test_admin):
    """Get authentication headers for admin user"""
    response = client.post(
        "/api/v1/auth/login",
        json={"username": "admin", "password": "Admin123!@#"}
    )
    token = response.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}
</file>

<file path="app/tests/test_activities.py">
import pytest
from datetime import datetime


def test_get_activities(client, auth_headers):
    """Test getting list of activities"""
    response = client.get("/api/v1/activities/", headers=auth_headers)
    assert response.status_code == 200
    assert isinstance(response.json(), list)


def test_get_activities_unauthorized(client):
    """Test getting activities without authentication"""
    response = client.get("/api/v1/activities/")
    assert response.status_code == 403


def test_get_activity_stats(client, auth_headers):
    """Test getting activity statistics"""
    response = client.get("/api/v1/activities/stats", headers=auth_headers)
    assert response.status_code == 200
    data = response.json()
    assert "total_activities" in data
    assert "active_clients" in data
</file>

<file path="app/tests/test_auth.py">
import pytest
from app.core.security import get_password_hash, verify_password, validate_password_strength


def test_password_hashing():
    """Test password hashing and verification"""
    password = "TestPassword123!@#"
    hashed = get_password_hash(password)
    
    assert verify_password(password, hashed) is True
    assert verify_password("WrongPassword", hashed) is False


def test_password_strength_validation():
    """Test password strength validation"""
    # Valid password
    is_valid, error = validate_password_strength("ValidPass123!@#")
    assert is_valid is True
    assert error == ""
    
    # Too short
    is_valid, error = validate_password_strength("Short1!")
    assert is_valid is False
    assert "at least 8 characters" in error
    
    # No uppercase
    is_valid, error = validate_password_strength("lowercase123!")
    assert is_valid is False
    assert "uppercase" in error
    
    # No lowercase
    is_valid, error = validate_password_strength("UPPERCASE123!")
    assert is_valid is False
    assert "lowercase" in error
    
    # No number
    is_valid, error = validate_password_strength("NoNumber!@#")
    assert is_valid is False
    assert "number" in error
    
    # No special character
    is_valid, error = validate_password_strength("NoSpecial123")
    assert is_valid is False
    assert "special character" in error


def test_login_success(client, test_user):
    """Test successful login"""
    response = client.post(
        "/api/v1/auth/login",
        json={"username": "testuser", "password": "Test123!@#"}
    )
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"


def test_login_invalid_credentials(client, test_user):
    """Test login with invalid credentials"""
    response = client.post(
        "/api/v1/auth/login",
        json={"username": "testuser", "password": "WrongPassword"}
    )
    assert response.status_code == 401


def test_login_nonexistent_user(client):
    """Test login with non-existent user"""
    response = client.post(
        "/api/v1/auth/login",
        json={"username": "nonexistent", "password": "Password123!"}
    )
    assert response.status_code == 401


def test_get_current_user(client, auth_headers):
    """Test getting current user information"""
    response = client.get("/api/v1/auth/me", headers=auth_headers)
    assert response.status_code == 200
    data = response.json()
    assert data["username"] == "testuser"


def test_get_current_user_unauthorized(client):
    """Test getting current user without authentication"""
    response = client.get("/api/v1/auth/me")
    assert response.status_code == 403  # No credentials provided


def test_change_password_success(client, auth_headers):
    """Test successful password change"""
    response = client.post(
        "/api/v1/auth/change-password",
        headers=auth_headers,
        json={
            "current_password": "Test123!@#",
            "new_password": "NewPassword123!@#"
        }
    )
    assert response.status_code == 200


def test_change_password_wrong_current(client, auth_headers):
    """Test password change with wrong current password"""
    response = client.post(
        "/api/v1/auth/change-password",
        headers=auth_headers,
        json={
            "current_password": "WrongPassword",
            "new_password": "NewPassword123!@#"
        }
    )
    assert response.status_code == 400


def test_change_password_weak_new(client, auth_headers):
    """Test password change with weak new password"""
    response = client.post(
        "/api/v1/auth/change-password",
        headers=auth_headers,
        json={
            "current_password": "Test123!@#",
            "new_password": "weak"
        }
    )
    assert response.status_code == 422  # Validation error
</file>

<file path="app/tests/test_clients.py">
import pytest


def test_get_clients(client, auth_headers):
    """Test getting list of clients"""
    response = client.get("/api/v1/clients/", headers=auth_headers)
    assert response.status_code == 200
    assert isinstance(response.json(), list)


def test_get_clients_unauthorized(client):
    """Test getting clients without authentication"""
    response = client.get("/api/v1/clients/")
    assert response.status_code == 403


def test_get_client_stats(client, auth_headers):
    """Test getting client statistics"""
    response = client.get("/api/v1/clients/stats", headers=auth_headers)
    assert response.status_code == 200
    data = response.json()
    assert "total_clients" in data
    assert "online_clients" in data
</file>

<file path="app/__init__.py">
"""
Sentinel Backend Application
Employee Monitoring System with Enhanced Security and Compliance
"""

__version__ = "1.0.0"
__author__ = "Sentinel Team"
</file>

<file path="app/main.py">
# app/main.py

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
import logging

from app.core.config import settings
from app.core.database import init_db, check_db_connection
from app.api.routes import auth_router, clients_router, activities_router
from app.middleware import LoggingMiddleware, RateLimitMiddleware
from app.services.auth_service import create_initial_admin

logging.basicConfig(
    level=logging.INFO if not settings.DEBUG else logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

app = FastAPI(
    title=settings.PROJECT_NAME,
    version=settings.API_VERSION,
    docs_url="/docs" if settings.DEBUG else None,
    redoc_url="/redoc" if settings.DEBUG else None,
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.get_allowed_origins(),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Logging middleware
app.add_middleware(LoggingMiddleware)

# Rate limiting with higher limits (200 requests per minute)
app.add_middleware(RateLimitMiddleware, requests_per_minute=200)

# HTTPS enforcement
if settings.REQUIRE_HTTPS:
    app.add_middleware(TrustedHostMiddleware, allowed_hosts=["*"])


@app.on_event("startup")
async def startup_event():
    logger.info(f"🚀 Starting {settings.PROJECT_NAME} API v{settings.API_VERSION}")
    logger.info(f"Environment: {settings.ENVIRONMENT}")
    logger.info(f"Debug mode: {settings.DEBUG}")
    
    if not check_db_connection():
        logger.error("❌ Failed to connect to database")
        raise RuntimeError("Database connection failed")
    
    logger.info("✅ Database connection successful")
    
    try:
        init_db()
    except Exception as e:
        logger.error(f"❌ DB initialization failed: {e}")
        raise
    
    try:
        create_initial_admin()
    except Exception as e:
        logger.warning(f"⚠️ Initial admin creation: {e}")
    
    logger.info("✅ Application fully started")


@app.on_event("shutdown")
async def shutdown_event():
    logger.info("👋 Shutting down application")


@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "environment": settings.ENVIRONMENT,
        "version": settings.API_VERSION
    }


# API Routes
app.include_router(
    auth_router,
    prefix=f"/api/{settings.API_VERSION}/auth",
    tags=["Authentication"]
)

app.include_router(
    clients_router,
    prefix=f"/api/{settings.API_VERSION}/clients",
    tags=["Clients"]
)

app.include_router(
    activities_router,
    prefix=f"/api/{settings.API_VERSION}/activities",
    tags=["Activities"]
)


@app.get("/")
async def root():
    return {
        "message": f"Welcome to {settings.PROJECT_NAME} API",
        "version": settings.API_VERSION,
        "docs": "/docs" if settings.DEBUG else "Documentation disabled in production"
    }


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=settings.DEBUG
    )
</file>

<file path=".gitignore">
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/
env/

# Environment Variables
.env
.env.local
.env.*.local

# Database
*.db
*.sqlite
*.sqlite3
data/
backups/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# Testing
.pytest_cache/
.coverage
htmlcov/
.tox/

# Logs
*.log
logs/

# OS
.DS_Store
Thumbs.db

# Alembic
alembic/versions/*.pyc
</file>

<file path="alembic.ini">
[alembic]
script_location = alembic
prepend_sys_path = .
version_path_separator = os

[post_write_hooks]

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
</file>

<file path="docker-entrypoint.sh">
#!/bin/bash
set -e

echo "Waiting for PostgreSQL to be ready..."
max_retries=30
count=0
while ! pg_isready -h postgres -p 5432 -U sentinel_user > /dev/null 2>&1; do
    count=$((count + 1))
    if [ $count -gt $max_retries ]; then
        echo "PostgreSQL did not become ready in time"
        exit 1
    fi
    echo "Waiting for PostgreSQL... ($count/$max_retries)"
    sleep 2
done
echo "✅ PostgreSQL is ready!"

echo "Running database migrations..."
if [ -f "alembic.ini" ]; then
    alembic upgrade head
    echo "✅ Migrations completed successfully"
else
    echo "❌ alembic.ini not found!"
    exit 1
fi

echo "Creating initial admin user..."
python -c "
from app.services.auth_service import create_initial_admin
try:
    create_initial_admin()
    print('✅ Initial admin user created')
except Exception as e:
    print(f'ℹ️  Admin user setup: {e}')
" || echo "ℹ️  Admin user may already exist"

echo "🚀 Starting Sentinel application..."
exec uvicorn app.main:app --host 0.0.0.0 --port 8000
</file>

<file path="Dockerfile">
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Set environment variables
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

# Install system dependencies
RUN apt-get update && apt-get install -y \
    postgresql-client \
    curl \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first for better caching
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy alembic configuration
COPY alembic.ini .
COPY alembic ./alembic

# Copy application code
COPY app ./app
COPY init-db.sql .

# Create startup script
COPY docker-entrypoint.sh .
RUN chmod +x docker-entrypoint.sh

# Create non-root user
RUN useradd -m -u 1000 sentinel && \
    chown -R sentinel:sentinel /app && \
    mkdir -p /app/logs && \
    chown -R sentinel:sentinel /app/logs

# Switch to non-root user
USER sentinel

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Run application
ENTRYPOINT ["/app/docker-entrypoint.sh"]
</file>

<file path="init-db.sql">
-- Initial database setup
-- This file is automatically executed when PostgreSQL container starts

-- Create extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";

-- Grant permissions (tables will be created by Alembic migrations)
-- GRANT ALL PRIVILEGES ON DATABASE sentinel_db TO sentinel_user;
</file>

<file path="requirements.txt">
# FastAPI and Server
fastapi==0.109.0
uvicorn[standard]==0.27.0
python-multipart==0.0.6

# Database
sqlalchemy==2.0.25
psycopg2-binary==2.9.9
alembic==1.13.1

# Security - Fixed bcrypt version
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
bcrypt==4.0.1
cryptography==42.0.0

# Validation
pydantic==2.5.3
pydantic-settings==2.1.0
email-validator==2.1.0

# Utilities
python-dotenv==1.0.0
redis==5.0.1

# Rate Limiting
slowapi==0.1.9

# Monitoring
prometheus-client==0.19.0

# Development
pytest==7.4.4
pytest-asyncio==0.23.3
httpx==0.26.0
faker==22.0.0
</file>

</files>
